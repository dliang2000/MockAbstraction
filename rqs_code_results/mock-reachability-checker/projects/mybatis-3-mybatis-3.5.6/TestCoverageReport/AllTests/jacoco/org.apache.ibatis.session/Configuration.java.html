<!--

       Copyright ${license.git.copyrightYears} the original author or authors.

       Licensed under the Apache License, Version 2.0 (the "License");
       you may not use this file except in compliance with the License.
       You may obtain a copy of the License at

          http://www.apache.org/licenses/LICENSE-2.0

       Unless required by applicable law or agreed to in writing, software
       distributed under the License is distributed on an "AS IS" BASIS,
       WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       See the License for the specific language governing permissions and
       limitations under the License.

-->
<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>Configuration.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">mybatis</a> &gt; <a href="index.source.html" class="el_package">org.apache.ibatis.session</a> &gt; <span class="el_source">Configuration.java</span></div><h1>Configuration.java</h1><pre class="source lang-java linenums">/**
 *    Copyright 2009-2021 the original author or authors.
 *
 *    Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 *    you may not use this file except in compliance with the License.
 *    You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *    Unless required by applicable law or agreed to in writing, software
 *    distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *    See the License for the specific language governing permissions and
 *    limitations under the License.
 */
package org.apache.ibatis.session;

import java.util.Arrays;
import java.util.Collection;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Properties;
import java.util.Set;
import java.util.function.BiFunction;

import org.apache.ibatis.binding.MapperRegistry;
import org.apache.ibatis.builder.CacheRefResolver;
import org.apache.ibatis.builder.IncompleteElementException;
import org.apache.ibatis.builder.ResultMapResolver;
import org.apache.ibatis.builder.annotation.MethodResolver;
import org.apache.ibatis.builder.xml.XMLStatementBuilder;
import org.apache.ibatis.cache.Cache;
import org.apache.ibatis.cache.decorators.FifoCache;
import org.apache.ibatis.cache.decorators.LruCache;
import org.apache.ibatis.cache.decorators.SoftCache;
import org.apache.ibatis.cache.decorators.WeakCache;
import org.apache.ibatis.cache.impl.PerpetualCache;
import org.apache.ibatis.datasource.jndi.JndiDataSourceFactory;
import org.apache.ibatis.datasource.pooled.PooledDataSourceFactory;
import org.apache.ibatis.datasource.unpooled.UnpooledDataSourceFactory;
import org.apache.ibatis.executor.BatchExecutor;
import org.apache.ibatis.executor.CachingExecutor;
import org.apache.ibatis.executor.Executor;
import org.apache.ibatis.executor.ReuseExecutor;
import org.apache.ibatis.executor.SimpleExecutor;
import org.apache.ibatis.executor.keygen.KeyGenerator;
import org.apache.ibatis.executor.loader.ProxyFactory;
import org.apache.ibatis.executor.loader.cglib.CglibProxyFactory;
import org.apache.ibatis.executor.loader.javassist.JavassistProxyFactory;
import org.apache.ibatis.executor.parameter.ParameterHandler;
import org.apache.ibatis.executor.resultset.DefaultResultSetHandler;
import org.apache.ibatis.executor.resultset.ResultSetHandler;
import org.apache.ibatis.executor.statement.RoutingStatementHandler;
import org.apache.ibatis.executor.statement.StatementHandler;
import org.apache.ibatis.io.VFS;
import org.apache.ibatis.logging.Log;
import org.apache.ibatis.logging.LogFactory;
import org.apache.ibatis.logging.commons.JakartaCommonsLoggingImpl;
import org.apache.ibatis.logging.jdk14.Jdk14LoggingImpl;
import org.apache.ibatis.logging.log4j.Log4jImpl;
import org.apache.ibatis.logging.log4j2.Log4j2Impl;
import org.apache.ibatis.logging.nologging.NoLoggingImpl;
import org.apache.ibatis.logging.slf4j.Slf4jImpl;
import org.apache.ibatis.logging.stdout.StdOutImpl;
import org.apache.ibatis.mapping.BoundSql;
import org.apache.ibatis.mapping.Environment;
import org.apache.ibatis.mapping.MappedStatement;
import org.apache.ibatis.mapping.ParameterMap;
import org.apache.ibatis.mapping.ResultMap;
import org.apache.ibatis.mapping.ResultSetType;
import org.apache.ibatis.mapping.VendorDatabaseIdProvider;
import org.apache.ibatis.parsing.XNode;
import org.apache.ibatis.plugin.Interceptor;
import org.apache.ibatis.plugin.InterceptorChain;
import org.apache.ibatis.reflection.DefaultReflectorFactory;
import org.apache.ibatis.reflection.MetaObject;
import org.apache.ibatis.reflection.ReflectorFactory;
import org.apache.ibatis.reflection.factory.DefaultObjectFactory;
import org.apache.ibatis.reflection.factory.ObjectFactory;
import org.apache.ibatis.reflection.wrapper.DefaultObjectWrapperFactory;
import org.apache.ibatis.reflection.wrapper.ObjectWrapperFactory;
import org.apache.ibatis.scripting.LanguageDriver;
import org.apache.ibatis.scripting.LanguageDriverRegistry;
import org.apache.ibatis.scripting.defaults.RawLanguageDriver;
import org.apache.ibatis.scripting.xmltags.XMLLanguageDriver;
import org.apache.ibatis.transaction.Transaction;
import org.apache.ibatis.transaction.jdbc.JdbcTransactionFactory;
import org.apache.ibatis.transaction.managed.ManagedTransactionFactory;
import org.apache.ibatis.type.JdbcType;
import org.apache.ibatis.type.TypeAliasRegistry;
import org.apache.ibatis.type.TypeHandler;
import org.apache.ibatis.type.TypeHandlerRegistry;

/**
 * @author Clinton Begin
 */
public class Configuration {

  protected Environment environment;

  protected boolean safeRowBoundsEnabled;
<span class="fc" id="L106">  protected boolean safeResultHandlerEnabled = true;</span>
  protected boolean mapUnderscoreToCamelCase;
  protected boolean aggressiveLazyLoading;
<span class="fc" id="L109">  protected boolean multipleResultSetsEnabled = true;</span>
  protected boolean useGeneratedKeys;
<span class="fc" id="L111">  protected boolean useColumnLabel = true;</span>
<span class="fc" id="L112">  protected boolean cacheEnabled = true;</span>
  protected boolean callSettersOnNulls;
<span class="fc" id="L114">  protected boolean useActualParamName = true;</span>
  protected boolean returnInstanceForEmptyRow;
  protected boolean shrinkWhitespacesInSql;

  protected String logPrefix;
  protected Class&lt;? extends Log&gt; logImpl;
  protected Class&lt;? extends VFS&gt; vfsImpl;
  protected Class&lt;?&gt; defaultSqlProviderType;
<span class="fc" id="L122">  protected LocalCacheScope localCacheScope = LocalCacheScope.SESSION;</span>
<span class="fc" id="L123">  protected JdbcType jdbcTypeForNull = JdbcType.OTHER;</span>
<span class="fc" id="L124">  protected Set&lt;String&gt; lazyLoadTriggerMethods = new HashSet&lt;&gt;(Arrays.asList(&quot;equals&quot;, &quot;clone&quot;, &quot;hashCode&quot;, &quot;toString&quot;));</span>
  protected Integer defaultStatementTimeout;
  protected Integer defaultFetchSize;
  protected ResultSetType defaultResultSetType;
<span class="fc" id="L128">  protected ExecutorType defaultExecutorType = ExecutorType.SIMPLE;</span>
<span class="fc" id="L129">  protected AutoMappingBehavior autoMappingBehavior = AutoMappingBehavior.PARTIAL;</span>
<span class="fc" id="L130">  protected AutoMappingUnknownColumnBehavior autoMappingUnknownColumnBehavior = AutoMappingUnknownColumnBehavior.NONE;</span>

<span class="fc" id="L132">  protected Properties variables = new Properties();</span>
<span class="fc" id="L133">  protected ReflectorFactory reflectorFactory = new DefaultReflectorFactory();</span>
<span class="fc" id="L134">  protected ObjectFactory objectFactory = new DefaultObjectFactory();</span>
<span class="fc" id="L135">  protected ObjectWrapperFactory objectWrapperFactory = new DefaultObjectWrapperFactory();</span>

<span class="fc" id="L137">  protected boolean lazyLoadingEnabled = false;</span>
<span class="fc" id="L138">  protected ProxyFactory proxyFactory = new JavassistProxyFactory(); // #224 Using internal Javassist instead of OGNL</span>

  protected String databaseId;
  /**
   * Configuration factory class.
   * Used to create Configuration for loading deserialized unread properties.
   *
   * @see &lt;a href='https://github.com/mybatis/old-google-code-issues/issues/300'&gt;Issue 300 (google code)&lt;/a&gt;
   */
  protected Class&lt;?&gt; configurationFactory;

<span class="fc" id="L149">  protected final MapperRegistry mapperRegistry = new MapperRegistry(this);</span>
<span class="fc" id="L150">  protected final InterceptorChain interceptorChain = new InterceptorChain();</span>
<span class="fc" id="L151">  protected final TypeHandlerRegistry typeHandlerRegistry = new TypeHandlerRegistry(this);</span>
<span class="fc" id="L152">  protected final TypeAliasRegistry typeAliasRegistry = new TypeAliasRegistry();</span>
<span class="fc" id="L153">  protected final LanguageDriverRegistry languageRegistry = new LanguageDriverRegistry();</span>

<span class="fc" id="L155">  protected final Map&lt;String, MappedStatement&gt; mappedStatements = new StrictMap&lt;MappedStatement&gt;(&quot;Mapped Statements collection&quot;)</span>
<span class="fc" id="L156">      .conflictMessageProducer((savedValue, targetValue) -&gt;</span>
<span class="fc" id="L157">          &quot;. please check &quot; + savedValue.getResource() + &quot; and &quot; + targetValue.getResource());</span>
<span class="fc" id="L158">  protected final Map&lt;String, Cache&gt; caches = new StrictMap&lt;&gt;(&quot;Caches collection&quot;);</span>
<span class="fc" id="L159">  protected final Map&lt;String, ResultMap&gt; resultMaps = new StrictMap&lt;&gt;(&quot;Result Maps collection&quot;);</span>
<span class="fc" id="L160">  protected final Map&lt;String, ParameterMap&gt; parameterMaps = new StrictMap&lt;&gt;(&quot;Parameter Maps collection&quot;);</span>
<span class="fc" id="L161">  protected final Map&lt;String, KeyGenerator&gt; keyGenerators = new StrictMap&lt;&gt;(&quot;Key Generators collection&quot;);</span>

<span class="fc" id="L163">  protected final Set&lt;String&gt; loadedResources = new HashSet&lt;&gt;();</span>
<span class="fc" id="L164">  protected final Map&lt;String, XNode&gt; sqlFragments = new StrictMap&lt;&gt;(&quot;XML fragments parsed from previous mappers&quot;);</span>

<span class="fc" id="L166">  protected final Collection&lt;XMLStatementBuilder&gt; incompleteStatements = new LinkedList&lt;&gt;();</span>
<span class="fc" id="L167">  protected final Collection&lt;CacheRefResolver&gt; incompleteCacheRefs = new LinkedList&lt;&gt;();</span>
<span class="fc" id="L168">  protected final Collection&lt;ResultMapResolver&gt; incompleteResultMaps = new LinkedList&lt;&gt;();</span>
<span class="fc" id="L169">  protected final Collection&lt;MethodResolver&gt; incompleteMethods = new LinkedList&lt;&gt;();</span>

  /*
   * A map holds cache-ref relationship. The key is the namespace that
   * references a cache bound to another namespace and the value is the
   * namespace which the actual cache is bound to.
   */
<span class="fc" id="L176">  protected final Map&lt;String, String&gt; cacheRefMap = new HashMap&lt;&gt;();</span>

  public Configuration(Environment environment) {
<span class="fc" id="L179">    this();</span>
<span class="fc" id="L180">    this.environment = environment;</span>
<span class="fc" id="L181">  }</span>

<span class="fc" id="L183">  public Configuration() {</span>
<span class="fc" id="L184">    typeAliasRegistry.registerAlias(&quot;JDBC&quot;, JdbcTransactionFactory.class);</span>
<span class="fc" id="L185">    typeAliasRegistry.registerAlias(&quot;MANAGED&quot;, ManagedTransactionFactory.class);</span>

<span class="fc" id="L187">    typeAliasRegistry.registerAlias(&quot;JNDI&quot;, JndiDataSourceFactory.class);</span>
<span class="fc" id="L188">    typeAliasRegistry.registerAlias(&quot;POOLED&quot;, PooledDataSourceFactory.class);</span>
<span class="fc" id="L189">    typeAliasRegistry.registerAlias(&quot;UNPOOLED&quot;, UnpooledDataSourceFactory.class);</span>

<span class="fc" id="L191">    typeAliasRegistry.registerAlias(&quot;PERPETUAL&quot;, PerpetualCache.class);</span>
<span class="fc" id="L192">    typeAliasRegistry.registerAlias(&quot;FIFO&quot;, FifoCache.class);</span>
<span class="fc" id="L193">    typeAliasRegistry.registerAlias(&quot;LRU&quot;, LruCache.class);</span>
<span class="fc" id="L194">    typeAliasRegistry.registerAlias(&quot;SOFT&quot;, SoftCache.class);</span>
<span class="fc" id="L195">    typeAliasRegistry.registerAlias(&quot;WEAK&quot;, WeakCache.class);</span>

<span class="fc" id="L197">    typeAliasRegistry.registerAlias(&quot;DB_VENDOR&quot;, VendorDatabaseIdProvider.class);</span>

<span class="fc" id="L199">    typeAliasRegistry.registerAlias(&quot;XML&quot;, XMLLanguageDriver.class);</span>
<span class="fc" id="L200">    typeAliasRegistry.registerAlias(&quot;RAW&quot;, RawLanguageDriver.class);</span>

<span class="fc" id="L202">    typeAliasRegistry.registerAlias(&quot;SLF4J&quot;, Slf4jImpl.class);</span>
<span class="fc" id="L203">    typeAliasRegistry.registerAlias(&quot;COMMONS_LOGGING&quot;, JakartaCommonsLoggingImpl.class);</span>
<span class="fc" id="L204">    typeAliasRegistry.registerAlias(&quot;LOG4J&quot;, Log4jImpl.class);</span>
<span class="fc" id="L205">    typeAliasRegistry.registerAlias(&quot;LOG4J2&quot;, Log4j2Impl.class);</span>
<span class="fc" id="L206">    typeAliasRegistry.registerAlias(&quot;JDK_LOGGING&quot;, Jdk14LoggingImpl.class);</span>
<span class="fc" id="L207">    typeAliasRegistry.registerAlias(&quot;STDOUT_LOGGING&quot;, StdOutImpl.class);</span>
<span class="fc" id="L208">    typeAliasRegistry.registerAlias(&quot;NO_LOGGING&quot;, NoLoggingImpl.class);</span>

<span class="fc" id="L210">    typeAliasRegistry.registerAlias(&quot;CGLIB&quot;, CglibProxyFactory.class);</span>
<span class="fc" id="L211">    typeAliasRegistry.registerAlias(&quot;JAVASSIST&quot;, JavassistProxyFactory.class);</span>

<span class="fc" id="L213">    languageRegistry.setDefaultDriverClass(XMLLanguageDriver.class);</span>
<span class="fc" id="L214">    languageRegistry.register(RawLanguageDriver.class);</span>
<span class="fc" id="L215">  }</span>

  public String getLogPrefix() {
<span class="fc" id="L218">    return logPrefix;</span>
  }

  public void setLogPrefix(String logPrefix) {
<span class="fc" id="L222">    this.logPrefix = logPrefix;</span>
<span class="fc" id="L223">  }</span>

  public Class&lt;? extends Log&gt; getLogImpl() {
<span class="fc" id="L226">    return logImpl;</span>
  }

  public void setLogImpl(Class&lt;? extends Log&gt; logImpl) {
<span class="fc bfc" id="L230" title="All 2 branches covered.">    if (logImpl != null) {</span>
<span class="fc" id="L231">      this.logImpl = logImpl;</span>
<span class="fc" id="L232">      LogFactory.useCustomLogging(this.logImpl);</span>
    }
<span class="fc" id="L234">  }</span>

  public Class&lt;? extends VFS&gt; getVfsImpl() {
<span class="fc" id="L237">    return this.vfsImpl;</span>
  }

  public void setVfsImpl(Class&lt;? extends VFS&gt; vfsImpl) {
<span class="pc bpc" id="L241" title="1 of 2 branches missed.">    if (vfsImpl != null) {</span>
<span class="fc" id="L242">      this.vfsImpl = vfsImpl;</span>
<span class="fc" id="L243">      VFS.addImplClass(this.vfsImpl);</span>
    }
<span class="fc" id="L245">  }</span>

  /**
   * Gets an applying type when omit a type on sql provider annotation(e.g. {@link org.apache.ibatis.annotations.SelectProvider}).
   *
   * @return the default type for sql provider annotation
   * @since 3.5.6
   */
  public Class&lt;?&gt; getDefaultSqlProviderType() {
<span class="fc" id="L254">    return defaultSqlProviderType;</span>
  }

  /**
   * Sets an applying type when omit a type on sql provider annotation(e.g. {@link org.apache.ibatis.annotations.SelectProvider}).
   *
   * @param defaultSqlProviderType
   *          the default type for sql provider annotation
   * @since 3.5.6
   */
  public void setDefaultSqlProviderType(Class&lt;?&gt; defaultSqlProviderType) {
<span class="fc" id="L265">    this.defaultSqlProviderType = defaultSqlProviderType;</span>
<span class="fc" id="L266">  }</span>

  public boolean isCallSettersOnNulls() {
<span class="fc" id="L269">    return callSettersOnNulls;</span>
  }

  public void setCallSettersOnNulls(boolean callSettersOnNulls) {
<span class="fc" id="L273">    this.callSettersOnNulls = callSettersOnNulls;</span>
<span class="fc" id="L274">  }</span>

  public boolean isUseActualParamName() {
<span class="fc" id="L277">    return useActualParamName;</span>
  }

  public void setUseActualParamName(boolean useActualParamName) {
<span class="fc" id="L281">    this.useActualParamName = useActualParamName;</span>
<span class="fc" id="L282">  }</span>

  public boolean isReturnInstanceForEmptyRow() {
<span class="fc" id="L285">    return returnInstanceForEmptyRow;</span>
  }

  public void setReturnInstanceForEmptyRow(boolean returnEmptyInstance) {
<span class="fc" id="L289">    this.returnInstanceForEmptyRow = returnEmptyInstance;</span>
<span class="fc" id="L290">  }</span>

  public boolean isShrinkWhitespacesInSql() {
<span class="fc" id="L293">    return shrinkWhitespacesInSql;</span>
  }

  public void setShrinkWhitespacesInSql(boolean shrinkWhitespacesInSql) {
<span class="fc" id="L297">    this.shrinkWhitespacesInSql = shrinkWhitespacesInSql;</span>
<span class="fc" id="L298">  }</span>

  public String getDatabaseId() {
<span class="fc" id="L301">    return databaseId;</span>
  }

  public void setDatabaseId(String databaseId) {
<span class="fc" id="L305">    this.databaseId = databaseId;</span>
<span class="fc" id="L306">  }</span>

  public Class&lt;?&gt; getConfigurationFactory() {
<span class="fc" id="L309">    return configurationFactory;</span>
  }

  public void setConfigurationFactory(Class&lt;?&gt; configurationFactory) {
<span class="fc" id="L313">    this.configurationFactory = configurationFactory;</span>
<span class="fc" id="L314">  }</span>

  public boolean isSafeResultHandlerEnabled() {
<span class="fc" id="L317">    return safeResultHandlerEnabled;</span>
  }

  public void setSafeResultHandlerEnabled(boolean safeResultHandlerEnabled) {
<span class="fc" id="L321">    this.safeResultHandlerEnabled = safeResultHandlerEnabled;</span>
<span class="fc" id="L322">  }</span>

  public boolean isSafeRowBoundsEnabled() {
<span class="fc" id="L325">    return safeRowBoundsEnabled;</span>
  }

  public void setSafeRowBoundsEnabled(boolean safeRowBoundsEnabled) {
<span class="fc" id="L329">    this.safeRowBoundsEnabled = safeRowBoundsEnabled;</span>
<span class="fc" id="L330">  }</span>

  public boolean isMapUnderscoreToCamelCase() {
<span class="fc" id="L333">    return mapUnderscoreToCamelCase;</span>
  }

  public void setMapUnderscoreToCamelCase(boolean mapUnderscoreToCamelCase) {
<span class="fc" id="L337">    this.mapUnderscoreToCamelCase = mapUnderscoreToCamelCase;</span>
<span class="fc" id="L338">  }</span>

  public void addLoadedResource(String resource) {
<span class="fc" id="L341">    loadedResources.add(resource);</span>
<span class="fc" id="L342">  }</span>

  public boolean isResourceLoaded(String resource) {
<span class="fc" id="L345">    return loadedResources.contains(resource);</span>
  }

  public Environment getEnvironment() {
<span class="fc" id="L349">    return environment;</span>
  }

  public void setEnvironment(Environment environment) {
<span class="fc" id="L353">    this.environment = environment;</span>
<span class="fc" id="L354">  }</span>

  public AutoMappingBehavior getAutoMappingBehavior() {
<span class="fc" id="L357">    return autoMappingBehavior;</span>
  }

  public void setAutoMappingBehavior(AutoMappingBehavior autoMappingBehavior) {
<span class="fc" id="L361">    this.autoMappingBehavior = autoMappingBehavior;</span>
<span class="fc" id="L362">  }</span>

  /**
   * Gets the auto mapping unknown column behavior.
   *
   * @return the auto mapping unknown column behavior
   * @since 3.4.0
   */
  public AutoMappingUnknownColumnBehavior getAutoMappingUnknownColumnBehavior() {
<span class="fc" id="L371">    return autoMappingUnknownColumnBehavior;</span>
  }

  /**
   * Sets the auto mapping unknown column behavior.
   *
   * @param autoMappingUnknownColumnBehavior
   *          the new auto mapping unknown column behavior
   * @since 3.4.0
   */
  public void setAutoMappingUnknownColumnBehavior(AutoMappingUnknownColumnBehavior autoMappingUnknownColumnBehavior) {
<span class="fc" id="L382">    this.autoMappingUnknownColumnBehavior = autoMappingUnknownColumnBehavior;</span>
<span class="fc" id="L383">  }</span>

  public boolean isLazyLoadingEnabled() {
<span class="fc" id="L386">    return lazyLoadingEnabled;</span>
  }

  public void setLazyLoadingEnabled(boolean lazyLoadingEnabled) {
<span class="fc" id="L390">    this.lazyLoadingEnabled = lazyLoadingEnabled;</span>
<span class="fc" id="L391">  }</span>

  public ProxyFactory getProxyFactory() {
<span class="fc" id="L394">    return proxyFactory;</span>
  }

  public void setProxyFactory(ProxyFactory proxyFactory) {
<span class="fc bfc" id="L398" title="All 2 branches covered.">    if (proxyFactory == null) {</span>
<span class="fc" id="L399">      proxyFactory = new JavassistProxyFactory();</span>
    }
<span class="fc" id="L401">    this.proxyFactory = proxyFactory;</span>
<span class="fc" id="L402">  }</span>

  public boolean isAggressiveLazyLoading() {
<span class="fc" id="L405">    return aggressiveLazyLoading;</span>
  }

  public void setAggressiveLazyLoading(boolean aggressiveLazyLoading) {
<span class="fc" id="L409">    this.aggressiveLazyLoading = aggressiveLazyLoading;</span>
<span class="fc" id="L410">  }</span>

  public boolean isMultipleResultSetsEnabled() {
<span class="fc" id="L413">    return multipleResultSetsEnabled;</span>
  }

  public void setMultipleResultSetsEnabled(boolean multipleResultSetsEnabled) {
<span class="fc" id="L417">    this.multipleResultSetsEnabled = multipleResultSetsEnabled;</span>
<span class="fc" id="L418">  }</span>

  public Set&lt;String&gt; getLazyLoadTriggerMethods() {
<span class="fc" id="L421">    return lazyLoadTriggerMethods;</span>
  }

  public void setLazyLoadTriggerMethods(Set&lt;String&gt; lazyLoadTriggerMethods) {
<span class="fc" id="L425">    this.lazyLoadTriggerMethods = lazyLoadTriggerMethods;</span>
<span class="fc" id="L426">  }</span>

  public boolean isUseGeneratedKeys() {
<span class="fc" id="L429">    return useGeneratedKeys;</span>
  }

  public void setUseGeneratedKeys(boolean useGeneratedKeys) {
<span class="fc" id="L433">    this.useGeneratedKeys = useGeneratedKeys;</span>
<span class="fc" id="L434">  }</span>

  public ExecutorType getDefaultExecutorType() {
<span class="fc" id="L437">    return defaultExecutorType;</span>
  }

  public void setDefaultExecutorType(ExecutorType defaultExecutorType) {
<span class="fc" id="L441">    this.defaultExecutorType = defaultExecutorType;</span>
<span class="fc" id="L442">  }</span>

  public boolean isCacheEnabled() {
<span class="fc" id="L445">    return cacheEnabled;</span>
  }

  public void setCacheEnabled(boolean cacheEnabled) {
<span class="fc" id="L449">    this.cacheEnabled = cacheEnabled;</span>
<span class="fc" id="L450">  }</span>

  public Integer getDefaultStatementTimeout() {
<span class="fc" id="L453">    return defaultStatementTimeout;</span>
  }

  public void setDefaultStatementTimeout(Integer defaultStatementTimeout) {
<span class="fc" id="L457">    this.defaultStatementTimeout = defaultStatementTimeout;</span>
<span class="fc" id="L458">  }</span>

  /**
   * Gets the default fetch size.
   *
   * @return the default fetch size
   * @since 3.3.0
   */
  public Integer getDefaultFetchSize() {
<span class="fc" id="L467">    return defaultFetchSize;</span>
  }

  /**
   * Sets the default fetch size.
   *
   * @param defaultFetchSize
   *          the new default fetch size
   * @since 3.3.0
   */
  public void setDefaultFetchSize(Integer defaultFetchSize) {
<span class="fc" id="L478">    this.defaultFetchSize = defaultFetchSize;</span>
<span class="fc" id="L479">  }</span>

  /**
   * Gets the default result set type.
   *
   * @return the default result set type
   * @since 3.5.2
   */
  public ResultSetType getDefaultResultSetType() {
<span class="fc" id="L488">    return defaultResultSetType;</span>
  }

  /**
   * Sets the default result set type.
   *
   * @param defaultResultSetType
   *          the new default result set type
   * @since 3.5.2
   */
  public void setDefaultResultSetType(ResultSetType defaultResultSetType) {
<span class="fc" id="L499">    this.defaultResultSetType = defaultResultSetType;</span>
<span class="fc" id="L500">  }</span>

  public boolean isUseColumnLabel() {
<span class="fc" id="L503">    return useColumnLabel;</span>
  }

  public void setUseColumnLabel(boolean useColumnLabel) {
<span class="fc" id="L507">    this.useColumnLabel = useColumnLabel;</span>
<span class="fc" id="L508">  }</span>

  public LocalCacheScope getLocalCacheScope() {
<span class="fc" id="L511">    return localCacheScope;</span>
  }

  public void setLocalCacheScope(LocalCacheScope localCacheScope) {
<span class="fc" id="L515">    this.localCacheScope = localCacheScope;</span>
<span class="fc" id="L516">  }</span>

  public JdbcType getJdbcTypeForNull() {
<span class="fc" id="L519">    return jdbcTypeForNull;</span>
  }

  public void setJdbcTypeForNull(JdbcType jdbcTypeForNull) {
<span class="fc" id="L523">    this.jdbcTypeForNull = jdbcTypeForNull;</span>
<span class="fc" id="L524">  }</span>

  public Properties getVariables() {
<span class="fc" id="L527">    return variables;</span>
  }

  public void setVariables(Properties variables) {
<span class="fc" id="L531">    this.variables = variables;</span>
<span class="fc" id="L532">  }</span>

  public TypeHandlerRegistry getTypeHandlerRegistry() {
<span class="fc" id="L535">    return typeHandlerRegistry;</span>
  }

  /**
   * Set a default {@link TypeHandler} class for {@link Enum}.
   * A default {@link TypeHandler} is {@link org.apache.ibatis.type.EnumTypeHandler}.
   * @param typeHandler a type handler class for {@link Enum}
   * @since 3.4.5
   */
  public void setDefaultEnumTypeHandler(Class&lt;? extends TypeHandler&gt; typeHandler) {
<span class="fc bfc" id="L545" title="All 2 branches covered.">    if (typeHandler != null) {</span>
<span class="fc" id="L546">      getTypeHandlerRegistry().setDefaultEnumTypeHandler(typeHandler);</span>
    }
<span class="fc" id="L548">  }</span>

  public TypeAliasRegistry getTypeAliasRegistry() {
<span class="fc" id="L551">    return typeAliasRegistry;</span>
  }

  /**
   * Gets the mapper registry.
   *
   * @return the mapper registry
   * @since 3.2.2
   */
  public MapperRegistry getMapperRegistry() {
<span class="fc" id="L561">    return mapperRegistry;</span>
  }

  public ReflectorFactory getReflectorFactory() {
<span class="fc" id="L565">    return reflectorFactory;</span>
  }

  public void setReflectorFactory(ReflectorFactory reflectorFactory) {
<span class="fc" id="L569">    this.reflectorFactory = reflectorFactory;</span>
<span class="fc" id="L570">  }</span>

  public ObjectFactory getObjectFactory() {
<span class="fc" id="L573">    return objectFactory;</span>
  }

  public void setObjectFactory(ObjectFactory objectFactory) {
<span class="fc" id="L577">    this.objectFactory = objectFactory;</span>
<span class="fc" id="L578">  }</span>

  public ObjectWrapperFactory getObjectWrapperFactory() {
<span class="fc" id="L581">    return objectWrapperFactory;</span>
  }

  public void setObjectWrapperFactory(ObjectWrapperFactory objectWrapperFactory) {
<span class="fc" id="L585">    this.objectWrapperFactory = objectWrapperFactory;</span>
<span class="fc" id="L586">  }</span>

  /**
   * Gets the interceptors.
   *
   * @return the interceptors
   * @since 3.2.2
   */
  public List&lt;Interceptor&gt; getInterceptors() {
<span class="fc" id="L595">    return interceptorChain.getInterceptors();</span>
  }

  public LanguageDriverRegistry getLanguageRegistry() {
<span class="fc" id="L599">    return languageRegistry;</span>
  }

  public void setDefaultScriptingLanguage(Class&lt;? extends LanguageDriver&gt; driver) {
<span class="fc bfc" id="L603" title="All 2 branches covered.">    if (driver == null) {</span>
<span class="fc" id="L604">      driver = XMLLanguageDriver.class;</span>
    }
<span class="fc" id="L606">    getLanguageRegistry().setDefaultDriverClass(driver);</span>
<span class="fc" id="L607">  }</span>

  public LanguageDriver getDefaultScriptingLanguageInstance() {
<span class="fc" id="L610">    return languageRegistry.getDefaultDriver();</span>
  }

  /**
   * Gets the language driver.
   *
   * @param langClass
   *          the lang class
   * @return the language driver
   * @since 3.5.1
   */
  public LanguageDriver getLanguageDriver(Class&lt;? extends LanguageDriver&gt; langClass) {
<span class="fc bfc" id="L622" title="All 2 branches covered.">    if (langClass == null) {</span>
<span class="fc" id="L623">      return languageRegistry.getDefaultDriver();</span>
    }
<span class="fc" id="L625">    languageRegistry.register(langClass);</span>
<span class="fc" id="L626">    return languageRegistry.getDriver(langClass);</span>
  }

  /**
   * Gets the default scripting lanuage instance.
   *
   * @return the default scripting lanuage instance
   * @deprecated Use {@link #getDefaultScriptingLanguageInstance()}
   */
  @Deprecated
  public LanguageDriver getDefaultScriptingLanuageInstance() {
<span class="fc" id="L637">    return getDefaultScriptingLanguageInstance();</span>
  }

  public MetaObject newMetaObject(Object object) {
<span class="fc" id="L641">    return MetaObject.forObject(object, objectFactory, objectWrapperFactory, reflectorFactory);</span>
  }

  public ParameterHandler newParameterHandler(MappedStatement mappedStatement, Object parameterObject, BoundSql boundSql) {
<span class="fc" id="L645">    ParameterHandler parameterHandler = mappedStatement.getLang().createParameterHandler(mappedStatement, parameterObject, boundSql);</span>
<span class="fc" id="L646">    parameterHandler = (ParameterHandler) interceptorChain.pluginAll(parameterHandler);</span>
<span class="fc" id="L647">    return parameterHandler;</span>
  }

  public ResultSetHandler newResultSetHandler(Executor executor, MappedStatement mappedStatement, RowBounds rowBounds, ParameterHandler parameterHandler,
      ResultHandler resultHandler, BoundSql boundSql) {
<span class="fc" id="L652">    ResultSetHandler resultSetHandler = new DefaultResultSetHandler(executor, mappedStatement, parameterHandler, resultHandler, boundSql, rowBounds);</span>
<span class="fc" id="L653">    resultSetHandler = (ResultSetHandler) interceptorChain.pluginAll(resultSetHandler);</span>
<span class="fc" id="L654">    return resultSetHandler;</span>
  }

  public StatementHandler newStatementHandler(Executor executor, MappedStatement mappedStatement, Object parameterObject, RowBounds rowBounds, ResultHandler resultHandler, BoundSql boundSql) {
<span class="fc" id="L658">    StatementHandler statementHandler = new RoutingStatementHandler(executor, mappedStatement, parameterObject, rowBounds, resultHandler, boundSql);</span>
<span class="fc" id="L659">    statementHandler = (StatementHandler) interceptorChain.pluginAll(statementHandler);</span>
<span class="fc" id="L660">    return statementHandler;</span>
  }

  public Executor newExecutor(Transaction transaction) {
<span class="nc" id="L664">    return newExecutor(transaction, defaultExecutorType);</span>
  }

  public Executor newExecutor(Transaction transaction, ExecutorType executorType) {
<span class="pc bpc" id="L668" title="1 of 2 branches missed.">    executorType = executorType == null ? defaultExecutorType : executorType;</span>
<span class="pc bpc" id="L669" title="1 of 2 branches missed.">    executorType = executorType == null ? ExecutorType.SIMPLE : executorType;</span>
    Executor executor;
<span class="fc bfc" id="L671" title="All 2 branches covered.">    if (ExecutorType.BATCH == executorType) {</span>
<span class="fc" id="L672">      executor = new BatchExecutor(this, transaction);</span>
<span class="fc bfc" id="L673" title="All 2 branches covered.">    } else if (ExecutorType.REUSE == executorType) {</span>
<span class="fc" id="L674">      executor = new ReuseExecutor(this, transaction);</span>
    } else {
<span class="fc" id="L676">      executor = new SimpleExecutor(this, transaction);</span>
    }
<span class="pc bpc" id="L678" title="1 of 2 branches missed.">    if (cacheEnabled) {</span>
<span class="fc" id="L679">      executor = new CachingExecutor(executor);</span>
    }
<span class="fc" id="L681">    executor = (Executor) interceptorChain.pluginAll(executor);</span>
<span class="fc" id="L682">    return executor;</span>
  }

  public void addKeyGenerator(String id, KeyGenerator keyGenerator) {
<span class="fc" id="L686">    keyGenerators.put(id, keyGenerator);</span>
<span class="fc" id="L687">  }</span>

  public Collection&lt;String&gt; getKeyGeneratorNames() {
<span class="nc" id="L690">    return keyGenerators.keySet();</span>
  }

  public Collection&lt;KeyGenerator&gt; getKeyGenerators() {
<span class="nc" id="L694">    return keyGenerators.values();</span>
  }

  public KeyGenerator getKeyGenerator(String id) {
<span class="fc" id="L698">    return keyGenerators.get(id);</span>
  }

  public boolean hasKeyGenerator(String id) {
<span class="fc" id="L702">    return keyGenerators.containsKey(id);</span>
  }

  public void addCache(Cache cache) {
<span class="fc" id="L706">    caches.put(cache.getId(), cache);</span>
<span class="fc" id="L707">  }</span>

  public Collection&lt;String&gt; getCacheNames() {
<span class="nc" id="L710">    return caches.keySet();</span>
  }

  public Collection&lt;Cache&gt; getCaches() {
<span class="nc" id="L714">    return caches.values();</span>
  }

  public Cache getCache(String id) {
<span class="fc" id="L718">    return caches.get(id);</span>
  }

  public boolean hasCache(String id) {
<span class="nc" id="L722">    return caches.containsKey(id);</span>
  }

  public void addResultMap(ResultMap rm) {
<span class="fc" id="L726">    resultMaps.put(rm.getId(), rm);</span>
<span class="fc" id="L727">    checkLocallyForDiscriminatedNestedResultMaps(rm);</span>
<span class="fc" id="L728">    checkGloballyForDiscriminatedNestedResultMaps(rm);</span>
<span class="fc" id="L729">  }</span>

  public Collection&lt;String&gt; getResultMapNames() {
<span class="nc" id="L732">    return resultMaps.keySet();</span>
  }

  public Collection&lt;ResultMap&gt; getResultMaps() {
<span class="fc" id="L736">    return resultMaps.values();</span>
  }

  public ResultMap getResultMap(String id) {
<span class="fc" id="L740">    return resultMaps.get(id);</span>
  }

  public boolean hasResultMap(String id) {
<span class="fc" id="L744">    return resultMaps.containsKey(id);</span>
  }

  public void addParameterMap(ParameterMap pm) {
<span class="fc" id="L748">    parameterMaps.put(pm.getId(), pm);</span>
<span class="fc" id="L749">  }</span>

  public Collection&lt;String&gt; getParameterMapNames() {
<span class="nc" id="L752">    return parameterMaps.keySet();</span>
  }

  public Collection&lt;ParameterMap&gt; getParameterMaps() {
<span class="nc" id="L756">    return parameterMaps.values();</span>
  }

  public ParameterMap getParameterMap(String id) {
<span class="fc" id="L760">    return parameterMaps.get(id);</span>
  }

  public boolean hasParameterMap(String id) {
<span class="nc" id="L764">    return parameterMaps.containsKey(id);</span>
  }

  public void addMappedStatement(MappedStatement ms) {
<span class="fc" id="L768">    mappedStatements.put(ms.getId(), ms);</span>
<span class="fc" id="L769">  }</span>

  public Collection&lt;String&gt; getMappedStatementNames() {
<span class="fc" id="L772">    buildAllStatements();</span>
<span class="fc" id="L773">    return mappedStatements.keySet();</span>
  }

  public Collection&lt;MappedStatement&gt; getMappedStatements() {
<span class="nc" id="L777">    buildAllStatements();</span>
<span class="nc" id="L778">    return mappedStatements.values();</span>
  }

  public Collection&lt;XMLStatementBuilder&gt; getIncompleteStatements() {
<span class="fc" id="L782">    return incompleteStatements;</span>
  }

  public void addIncompleteStatement(XMLStatementBuilder incompleteStatement) {
<span class="fc" id="L786">    incompleteStatements.add(incompleteStatement);</span>
<span class="fc" id="L787">  }</span>

  public Collection&lt;CacheRefResolver&gt; getIncompleteCacheRefs() {
<span class="fc" id="L790">    return incompleteCacheRefs;</span>
  }

  public void addIncompleteCacheRef(CacheRefResolver incompleteCacheRef) {
<span class="fc" id="L794">    incompleteCacheRefs.add(incompleteCacheRef);</span>
<span class="fc" id="L795">  }</span>

  public Collection&lt;ResultMapResolver&gt; getIncompleteResultMaps() {
<span class="fc" id="L798">    return incompleteResultMaps;</span>
  }

  public void addIncompleteResultMap(ResultMapResolver resultMapResolver) {
<span class="fc" id="L802">    incompleteResultMaps.add(resultMapResolver);</span>
<span class="fc" id="L803">  }</span>

  public void addIncompleteMethod(MethodResolver builder) {
<span class="fc" id="L806">    incompleteMethods.add(builder);</span>
<span class="fc" id="L807">  }</span>

  public Collection&lt;MethodResolver&gt; getIncompleteMethods() {
<span class="fc" id="L810">    return incompleteMethods;</span>
  }

  public MappedStatement getMappedStatement(String id) {
<span class="fc" id="L814">    return this.getMappedStatement(id, true);</span>
  }

  public MappedStatement getMappedStatement(String id, boolean validateIncompleteStatements) {
<span class="fc bfc" id="L818" title="All 2 branches covered.">    if (validateIncompleteStatements) {</span>
<span class="fc" id="L819">      buildAllStatements();</span>
    }
<span class="fc" id="L821">    return mappedStatements.get(id);</span>
  }

  public Map&lt;String, XNode&gt; getSqlFragments() {
<span class="fc" id="L825">    return sqlFragments;</span>
  }

  public void addInterceptor(Interceptor interceptor) {
<span class="fc" id="L829">    interceptorChain.addInterceptor(interceptor);</span>
<span class="fc" id="L830">  }</span>

  public void addMappers(String packageName, Class&lt;?&gt; superType) {
<span class="nc" id="L833">    mapperRegistry.addMappers(packageName, superType);</span>
<span class="nc" id="L834">  }</span>

  public void addMappers(String packageName) {
<span class="fc" id="L837">    mapperRegistry.addMappers(packageName);</span>
<span class="fc" id="L838">  }</span>

  public &lt;T&gt; void addMapper(Class&lt;T&gt; type) {
<span class="fc" id="L841">    mapperRegistry.addMapper(type);</span>
<span class="fc" id="L842">  }</span>

  public &lt;T&gt; T getMapper(Class&lt;T&gt; type, SqlSession sqlSession) {
<span class="fc" id="L845">    return mapperRegistry.getMapper(type, sqlSession);</span>
  }

  public boolean hasMapper(Class&lt;?&gt; type) {
<span class="fc" id="L849">    return mapperRegistry.hasMapper(type);</span>
  }

  public boolean hasStatement(String statementName) {
<span class="fc" id="L853">    return hasStatement(statementName, true);</span>
  }

  public boolean hasStatement(String statementName, boolean validateIncompleteStatements) {
<span class="fc bfc" id="L857" title="All 2 branches covered.">    if (validateIncompleteStatements) {</span>
<span class="fc" id="L858">      buildAllStatements();</span>
    }
<span class="fc" id="L860">    return mappedStatements.containsKey(statementName);</span>
  }

  public void addCacheRef(String namespace, String referencedNamespace) {
<span class="fc" id="L864">    cacheRefMap.put(namespace, referencedNamespace);</span>
<span class="fc" id="L865">  }</span>

  /*
   * Parses all the unprocessed statement nodes in the cache. It is recommended
   * to call this method once all the mappers are added as it provides fail-fast
   * statement validation.
   */
  protected void buildAllStatements() {
<span class="fc" id="L873">    parsePendingResultMaps();</span>
<span class="fc bfc" id="L874" title="All 2 branches covered.">    if (!incompleteCacheRefs.isEmpty()) {</span>
<span class="fc" id="L875">      synchronized (incompleteCacheRefs) {</span>
<span class="pc bpc" id="L876" title="1 of 2 branches missed.">        incompleteCacheRefs.removeIf(x -&gt; x.resolveCacheRef() != null);</span>
<span class="fc" id="L877">      }</span>
    }
<span class="fc bfc" id="L879" title="All 2 branches covered.">    if (!incompleteStatements.isEmpty()) {</span>
<span class="fc" id="L880">      synchronized (incompleteStatements) {</span>
<span class="fc" id="L881">        incompleteStatements.removeIf(x -&gt; {</span>
<span class="fc" id="L882">          x.parseStatementNode();</span>
<span class="fc" id="L883">          return true;</span>
        });
<span class="fc" id="L885">      }</span>
    }
<span class="fc bfc" id="L887" title="All 2 branches covered.">    if (!incompleteMethods.isEmpty()) {</span>
<span class="fc" id="L888">      synchronized (incompleteMethods) {</span>
<span class="fc" id="L889">        incompleteMethods.removeIf(x -&gt; {</span>
<span class="fc" id="L890">          x.resolve();</span>
<span class="fc" id="L891">          return true;</span>
        });
<span class="fc" id="L893">      }</span>
    }
<span class="fc" id="L895">  }</span>

  private void parsePendingResultMaps() {
<span class="fc bfc" id="L898" title="All 2 branches covered.">    if (incompleteResultMaps.isEmpty()) {</span>
<span class="fc" id="L899">      return;</span>
    }
<span class="fc" id="L901">    synchronized (incompleteResultMaps) {</span>
      boolean resolved;
<span class="fc" id="L903">      IncompleteElementException ex = null;</span>
      do {
<span class="fc" id="L905">        resolved = false;</span>
<span class="fc" id="L906">        Iterator&lt;ResultMapResolver&gt; iterator = incompleteResultMaps.iterator();</span>
<span class="fc bfc" id="L907" title="All 2 branches covered.">        while (iterator.hasNext()) {</span>
          try {
<span class="fc" id="L909">            iterator.next().resolve();</span>
<span class="fc" id="L910">            iterator.remove();</span>
<span class="fc" id="L911">            resolved = true;</span>
<span class="fc" id="L912">          } catch (IncompleteElementException e) {</span>
<span class="fc" id="L913">            ex = e;</span>
<span class="fc" id="L914">          }</span>
        }
<span class="fc bfc" id="L916" title="All 2 branches covered.">      } while (resolved);</span>
<span class="pc bpc" id="L917" title="3 of 4 branches missed.">      if (!incompleteResultMaps.isEmpty() &amp;&amp; ex != null) {</span>
        // At least one result map is unresolvable.
<span class="nc" id="L919">        throw ex;</span>
      }
<span class="fc" id="L921">    }</span>
<span class="fc" id="L922">  }</span>

  /**
   * Extracts namespace from fully qualified statement id.
   *
   * @param statementId
   *          the statement id
   * @return namespace or null when id does not contain period.
   */
  protected String extractNamespace(String statementId) {
<span class="nc" id="L932">    int lastPeriod = statementId.lastIndexOf('.');</span>
<span class="nc bnc" id="L933" title="All 2 branches missed.">    return lastPeriod &gt; 0 ? statementId.substring(0, lastPeriod) : null;</span>
  }

  // Slow but a one time cost. A better solution is welcome.
  protected void checkGloballyForDiscriminatedNestedResultMaps(ResultMap rm) {
<span class="fc bfc" id="L938" title="All 2 branches covered.">    if (rm.hasNestedResultMaps()) {</span>
<span class="fc bfc" id="L939" title="All 2 branches covered.">      for (Map.Entry&lt;String, ResultMap&gt; entry : resultMaps.entrySet()) {</span>
<span class="fc" id="L940">        Object value = entry.getValue();</span>
<span class="fc bfc" id="L941" title="All 2 branches covered.">        if (value instanceof ResultMap) {</span>
<span class="fc" id="L942">          ResultMap entryResultMap = (ResultMap) value;</span>
<span class="fc bfc" id="L943" title="All 4 branches covered.">          if (!entryResultMap.hasNestedResultMaps() &amp;&amp; entryResultMap.getDiscriminator() != null) {</span>
<span class="fc" id="L944">            Collection&lt;String&gt; discriminatedResultMapNames = entryResultMap.getDiscriminator().getDiscriminatorMap().values();</span>
<span class="pc bpc" id="L945" title="1 of 2 branches missed.">            if (discriminatedResultMapNames.contains(rm.getId())) {</span>
<span class="nc" id="L946">              entryResultMap.forceNestedResultMaps();</span>
            }
          }
        }
<span class="fc" id="L950">      }</span>
    }
<span class="fc" id="L952">  }</span>

  // Slow but a one time cost. A better solution is welcome.
  protected void checkLocallyForDiscriminatedNestedResultMaps(ResultMap rm) {
<span class="fc bfc" id="L956" title="All 4 branches covered.">    if (!rm.hasNestedResultMaps() &amp;&amp; rm.getDiscriminator() != null) {</span>
<span class="fc bfc" id="L957" title="All 2 branches covered.">      for (Map.Entry&lt;String, String&gt; entry : rm.getDiscriminator().getDiscriminatorMap().entrySet()) {</span>
<span class="fc" id="L958">        String discriminatedResultMapName = entry.getValue();</span>
<span class="fc bfc" id="L959" title="All 2 branches covered.">        if (hasResultMap(discriminatedResultMapName)) {</span>
<span class="fc" id="L960">          ResultMap discriminatedResultMap = resultMaps.get(discriminatedResultMapName);</span>
<span class="fc bfc" id="L961" title="All 2 branches covered.">          if (discriminatedResultMap.hasNestedResultMaps()) {</span>
<span class="fc" id="L962">            rm.forceNestedResultMaps();</span>
<span class="fc" id="L963">            break;</span>
          }
        }
<span class="fc" id="L966">      }</span>
    }
<span class="fc" id="L968">  }</span>

  protected static class StrictMap&lt;V&gt; extends HashMap&lt;String, V&gt; {

    private static final long serialVersionUID = -4950446264854982944L;
    private final String name;
    private BiFunction&lt;V, V, String&gt; conflictMessageProducer;

    public StrictMap(String name, int initialCapacity, float loadFactor) {
<span class="nc" id="L977">      super(initialCapacity, loadFactor);</span>
<span class="nc" id="L978">      this.name = name;</span>
<span class="nc" id="L979">    }</span>

    public StrictMap(String name, int initialCapacity) {
<span class="nc" id="L982">      super(initialCapacity);</span>
<span class="nc" id="L983">      this.name = name;</span>
<span class="nc" id="L984">    }</span>

    public StrictMap(String name) {
<span class="fc" id="L987">      super();</span>
<span class="fc" id="L988">      this.name = name;</span>
<span class="fc" id="L989">    }</span>

    public StrictMap(String name, Map&lt;String, ? extends V&gt; m) {
<span class="nc" id="L992">      super(m);</span>
<span class="nc" id="L993">      this.name = name;</span>
<span class="nc" id="L994">    }</span>

    /**
     * Assign a function for producing a conflict error message when contains value with the same key.
     * &lt;p&gt;
     * function arguments are 1st is saved value and 2nd is target value.
     * @param conflictMessageProducer A function for producing a conflict error message
     * @return a conflict error message
     * @since 3.5.0
     */
    public StrictMap&lt;V&gt; conflictMessageProducer(BiFunction&lt;V, V, String&gt; conflictMessageProducer) {
<span class="fc" id="L1005">      this.conflictMessageProducer = conflictMessageProducer;</span>
<span class="fc" id="L1006">      return this;</span>
    }

    @Override
    @SuppressWarnings(&quot;unchecked&quot;)
    public V put(String key, V value) {
<span class="fc bfc" id="L1012" title="All 2 branches covered.">      if (containsKey(key)) {</span>
<span class="fc bfc" id="L1013" title="All 2 branches covered.">        throw new IllegalArgumentException(name + &quot; already contains value for &quot; + key</span>
<span class="fc" id="L1014">            + (conflictMessageProducer == null ? &quot;&quot; : conflictMessageProducer.apply(super.get(key), value)));</span>
      }
<span class="fc bfc" id="L1016" title="All 2 branches covered.">      if (key.contains(&quot;.&quot;)) {</span>
<span class="fc" id="L1017">        final String shortKey = getShortName(key);</span>
<span class="fc bfc" id="L1018" title="All 2 branches covered.">        if (super.get(shortKey) == null) {</span>
<span class="fc" id="L1019">          super.put(shortKey, value);</span>
        } else {
<span class="fc" id="L1021">          super.put(shortKey, (V) new Ambiguity(shortKey));</span>
        }
      }
<span class="fc" id="L1024">      return super.put(key, value);</span>
    }

    @Override
    public V get(Object key) {
<span class="fc" id="L1029">      V value = super.get(key);</span>
<span class="fc bfc" id="L1030" title="All 2 branches covered.">      if (value == null) {</span>
<span class="fc" id="L1031">        throw new IllegalArgumentException(name + &quot; does not contain value for &quot; + key);</span>
      }
<span class="fc bfc" id="L1033" title="All 2 branches covered.">      if (value instanceof Ambiguity) {</span>
<span class="fc" id="L1034">        throw new IllegalArgumentException(((Ambiguity) value).getSubject() + &quot; is ambiguous in &quot; + name</span>
            + &quot; (try using the full name including the namespace, or rename one of the entries)&quot;);
      }
<span class="fc" id="L1037">      return value;</span>
    }

    protected static class Ambiguity {
      private final String subject;

<span class="fc" id="L1043">      public Ambiguity(String subject) {</span>
<span class="fc" id="L1044">        this.subject = subject;</span>
<span class="fc" id="L1045">      }</span>

      public String getSubject() {
<span class="fc" id="L1048">        return subject;</span>
      }
    }

    private String getShortName(String key) {
<span class="fc" id="L1053">      final String[] keyParts = key.split(&quot;\\.&quot;);</span>
<span class="fc" id="L1054">      return keyParts[keyParts.length - 1];</span>
    }
  }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.7.202105040129</span></div></body></html>