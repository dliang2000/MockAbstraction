<!--

       Copyright ${license.git.copyrightYears} the original author or authors.

       Licensed under the Apache License, Version 2.0 (the "License");
       you may not use this file except in compliance with the License.
       You may obtain a copy of the License at

          http://www.apache.org/licenses/LICENSE-2.0

       Unless required by applicable law or agreed to in writing, software
       distributed under the License is distributed on an "AS IS" BASIS,
       WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       See the License for the specific language governing permissions and
       limitations under the License.

-->
<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>Reflector.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">mybatis</a> &gt; <a href="index.source.html" class="el_package">org.apache.ibatis.reflection</a> &gt; <span class="el_source">Reflector.java</span></div><h1>Reflector.java</h1><pre class="source lang-java linenums">/**
 *    Copyright 2009-2021 the original author or authors.
 *
 *    Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 *    you may not use this file except in compliance with the License.
 *    You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *    Unless required by applicable law or agreed to in writing, software
 *    distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *    See the License for the specific language governing permissions and
 *    limitations under the License.
 */
package org.apache.ibatis.reflection;

import java.lang.reflect.Array;
import java.lang.reflect.Constructor;
import java.lang.reflect.Field;
import java.lang.reflect.GenericArrayType;
import java.lang.reflect.Method;
import java.lang.reflect.Modifier;
import java.lang.reflect.ParameterizedType;
import java.lang.reflect.ReflectPermission;
import java.lang.reflect.Type;
import java.text.MessageFormat;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.HashMap;
import java.util.List;
import java.util.Locale;
import java.util.Map;
import java.util.Map.Entry;

import org.apache.ibatis.reflection.invoker.AmbiguousMethodInvoker;
import org.apache.ibatis.reflection.invoker.GetFieldInvoker;
import org.apache.ibatis.reflection.invoker.Invoker;
import org.apache.ibatis.reflection.invoker.MethodInvoker;
import org.apache.ibatis.reflection.invoker.SetFieldInvoker;
import org.apache.ibatis.reflection.property.PropertyNamer;

/**
 * This class represents a cached set of class definition information that
 * allows for easy mapping between property names and getter/setter methods.
 *
 * @author Clinton Begin
 */
public class Reflector {

  private final Class&lt;?&gt; type;
  private final String[] readablePropertyNames;
  private final String[] writablePropertyNames;
<span class="fc" id="L55">  private final Map&lt;String, Invoker&gt; setMethods = new HashMap&lt;&gt;();</span>
<span class="fc" id="L56">  private final Map&lt;String, Invoker&gt; getMethods = new HashMap&lt;&gt;();</span>
<span class="fc" id="L57">  private final Map&lt;String, Class&lt;?&gt;&gt; setTypes = new HashMap&lt;&gt;();</span>
<span class="fc" id="L58">  private final Map&lt;String, Class&lt;?&gt;&gt; getTypes = new HashMap&lt;&gt;();</span>
  private Constructor&lt;?&gt; defaultConstructor;

<span class="fc" id="L61">  private Map&lt;String, String&gt; caseInsensitivePropertyMap = new HashMap&lt;&gt;();</span>

<span class="fc" id="L63">  public Reflector(Class&lt;?&gt; clazz) {</span>
<span class="fc" id="L64">    type = clazz;</span>
<span class="fc" id="L65">    addDefaultConstructor(clazz);</span>
<span class="fc" id="L66">    addGetMethods(clazz);</span>
<span class="fc" id="L67">    addSetMethods(clazz);</span>
<span class="fc" id="L68">    addFields(clazz);</span>
<span class="fc" id="L69">    readablePropertyNames = getMethods.keySet().toArray(new String[0]);</span>
<span class="fc" id="L70">    writablePropertyNames = setMethods.keySet().toArray(new String[0]);</span>
<span class="fc bfc" id="L71" title="All 2 branches covered.">    for (String propName : readablePropertyNames) {</span>
<span class="fc" id="L72">      caseInsensitivePropertyMap.put(propName.toUpperCase(Locale.ENGLISH), propName);</span>
    }
<span class="fc bfc" id="L74" title="All 2 branches covered.">    for (String propName : writablePropertyNames) {</span>
<span class="fc" id="L75">      caseInsensitivePropertyMap.put(propName.toUpperCase(Locale.ENGLISH), propName);</span>
    }
<span class="fc" id="L77">  }</span>

  private void addDefaultConstructor(Class&lt;?&gt; clazz) {
<span class="fc" id="L80">    Constructor&lt;?&gt;[] constructors = clazz.getDeclaredConstructors();</span>
<span class="fc bfc" id="L81" title="All 2 branches covered.">    Arrays.stream(constructors).filter(constructor -&gt; constructor.getParameterTypes().length == 0)</span>
<span class="fc" id="L82">      .findAny().ifPresent(constructor -&gt; this.defaultConstructor = constructor);</span>
<span class="fc" id="L83">  }</span>

  private void addGetMethods(Class&lt;?&gt; clazz) {
<span class="fc" id="L86">    Map&lt;String, List&lt;Method&gt;&gt; conflictingGetters = new HashMap&lt;&gt;();</span>
<span class="fc" id="L87">    Method[] methods = getClassMethods(clazz);</span>
<span class="fc bfc" id="L88" title="All 4 branches covered.">    Arrays.stream(methods).filter(m -&gt; m.getParameterTypes().length == 0 &amp;&amp; PropertyNamer.isGetter(m.getName()))</span>
<span class="fc" id="L89">      .forEach(m -&gt; addMethodConflict(conflictingGetters, PropertyNamer.methodToProperty(m.getName()), m));</span>
<span class="fc" id="L90">    resolveGetterConflicts(conflictingGetters);</span>
<span class="fc" id="L91">  }</span>

  private void resolveGetterConflicts(Map&lt;String, List&lt;Method&gt;&gt; conflictingGetters) {
<span class="fc bfc" id="L94" title="All 2 branches covered.">    for (Entry&lt;String, List&lt;Method&gt;&gt; entry : conflictingGetters.entrySet()) {</span>
<span class="fc" id="L95">      Method winner = null;</span>
<span class="fc" id="L96">      String propName = entry.getKey();</span>
<span class="fc" id="L97">      boolean isAmbiguous = false;</span>
<span class="fc bfc" id="L98" title="All 2 branches covered.">      for (Method candidate : entry.getValue()) {</span>
<span class="fc bfc" id="L99" title="All 2 branches covered.">        if (winner == null) {</span>
<span class="fc" id="L100">          winner = candidate;</span>
<span class="fc" id="L101">          continue;</span>
        }
<span class="fc" id="L103">        Class&lt;?&gt; winnerType = winner.getReturnType();</span>
<span class="fc" id="L104">        Class&lt;?&gt; candidateType = candidate.getReturnType();</span>
<span class="fc bfc" id="L105" title="All 2 branches covered.">        if (candidateType.equals(winnerType)) {</span>
<span class="fc bfc" id="L106" title="All 2 branches covered.">          if (!boolean.class.equals(candidateType)) {</span>
<span class="fc" id="L107">            isAmbiguous = true;</span>
<span class="fc" id="L108">            break;</span>
<span class="pc bpc" id="L109" title="1 of 2 branches missed.">          } else if (candidate.getName().startsWith(&quot;is&quot;)) {</span>
<span class="fc" id="L110">            winner = candidate;</span>
          }
<span class="fc bfc" id="L112" title="All 2 branches covered.">        } else if (candidateType.isAssignableFrom(winnerType)) {</span>
          // OK getter type is descendant
<span class="fc bfc" id="L114" title="All 2 branches covered.">        } else if (winnerType.isAssignableFrom(candidateType)) {</span>
<span class="fc" id="L115">          winner = candidate;</span>
        } else {
<span class="fc" id="L117">          isAmbiguous = true;</span>
<span class="fc" id="L118">          break;</span>
        }
<span class="fc" id="L120">      }</span>
<span class="fc" id="L121">      addGetMethod(propName, winner, isAmbiguous);</span>
<span class="fc" id="L122">    }</span>
<span class="fc" id="L123">  }</span>

  private void addGetMethod(String name, Method method, boolean isAmbiguous) {
<span class="fc bfc" id="L126" title="All 2 branches covered.">    MethodInvoker invoker = isAmbiguous</span>
<span class="fc" id="L127">        ? new AmbiguousMethodInvoker(method, MessageFormat.format(</span>
            &quot;Illegal overloaded getter method with ambiguous type for property ''{0}'' in class ''{1}''. This breaks the JavaBeans specification and can cause unpredictable results.&quot;,
<span class="fc" id="L129">            name, method.getDeclaringClass().getName()))</span>
        : new MethodInvoker(method);
<span class="fc" id="L131">    getMethods.put(name, invoker);</span>
<span class="fc" id="L132">    Type returnType = TypeParameterResolver.resolveReturnType(method, type);</span>
<span class="fc" id="L133">    getTypes.put(name, typeToClass(returnType));</span>
<span class="fc" id="L134">  }</span>

  private void addSetMethods(Class&lt;?&gt; clazz) {
<span class="fc" id="L137">    Map&lt;String, List&lt;Method&gt;&gt; conflictingSetters = new HashMap&lt;&gt;();</span>
<span class="fc" id="L138">    Method[] methods = getClassMethods(clazz);</span>
<span class="fc bfc" id="L139" title="All 4 branches covered.">    Arrays.stream(methods).filter(m -&gt; m.getParameterTypes().length == 1 &amp;&amp; PropertyNamer.isSetter(m.getName()))</span>
<span class="fc" id="L140">      .forEach(m -&gt; addMethodConflict(conflictingSetters, PropertyNamer.methodToProperty(m.getName()), m));</span>
<span class="fc" id="L141">    resolveSetterConflicts(conflictingSetters);</span>
<span class="fc" id="L142">  }</span>

  private void addMethodConflict(Map&lt;String, List&lt;Method&gt;&gt; conflictingMethods, String name, Method method) {
<span class="pc bpc" id="L145" title="1 of 2 branches missed.">    if (isValidPropertyName(name)) {</span>
<span class="fc" id="L146">      List&lt;Method&gt; list = conflictingMethods.computeIfAbsent(name, k -&gt; new ArrayList&lt;&gt;());</span>
<span class="fc" id="L147">      list.add(method);</span>
    }
<span class="fc" id="L149">  }</span>

  private void resolveSetterConflicts(Map&lt;String, List&lt;Method&gt;&gt; conflictingSetters) {
<span class="fc bfc" id="L152" title="All 2 branches covered.">    for (Entry&lt;String, List&lt;Method&gt;&gt; entry : conflictingSetters.entrySet()) {</span>
<span class="fc" id="L153">      String propName = entry.getKey();</span>
<span class="fc" id="L154">      List&lt;Method&gt; setters = entry.getValue();</span>
<span class="fc" id="L155">      Class&lt;?&gt; getterType = getTypes.get(propName);</span>
<span class="fc" id="L156">      boolean isGetterAmbiguous = getMethods.get(propName) instanceof AmbiguousMethodInvoker;</span>
<span class="fc" id="L157">      boolean isSetterAmbiguous = false;</span>
<span class="fc" id="L158">      Method match = null;</span>
<span class="fc bfc" id="L159" title="All 2 branches covered.">      for (Method setter : setters) {</span>
<span class="fc bfc" id="L160" title="All 4 branches covered.">        if (!isGetterAmbiguous &amp;&amp; setter.getParameterTypes()[0].equals(getterType)) {</span>
          // should be the best match
<span class="fc" id="L162">          match = setter;</span>
<span class="fc" id="L163">          break;</span>
        }
<span class="fc bfc" id="L165" title="All 2 branches covered.">        if (!isSetterAmbiguous) {</span>
<span class="fc" id="L166">          match = pickBetterSetter(match, setter, propName);</span>
<span class="fc bfc" id="L167" title="All 2 branches covered.">          isSetterAmbiguous = match == null;</span>
        }
<span class="fc" id="L169">      }</span>
<span class="fc bfc" id="L170" title="All 2 branches covered.">      if (match != null) {</span>
<span class="fc" id="L171">        addSetMethod(propName, match);</span>
      }
<span class="fc" id="L173">    }</span>
<span class="fc" id="L174">  }</span>

  private Method pickBetterSetter(Method setter1, Method setter2, String property) {
<span class="fc bfc" id="L177" title="All 2 branches covered.">    if (setter1 == null) {</span>
<span class="fc" id="L178">      return setter2;</span>
    }
<span class="fc" id="L180">    Class&lt;?&gt; paramType1 = setter1.getParameterTypes()[0];</span>
<span class="fc" id="L181">    Class&lt;?&gt; paramType2 = setter2.getParameterTypes()[0];</span>
<span class="pc bpc" id="L182" title="1 of 2 branches missed.">    if (paramType1.isAssignableFrom(paramType2)) {</span>
<span class="nc" id="L183">      return setter2;</span>
<span class="fc bfc" id="L184" title="All 2 branches covered.">    } else if (paramType2.isAssignableFrom(paramType1)) {</span>
<span class="fc" id="L185">      return setter1;</span>
    }
<span class="fc" id="L187">    MethodInvoker invoker = new AmbiguousMethodInvoker(setter1,</span>
<span class="fc" id="L188">        MessageFormat.format(</span>
            &quot;Ambiguous setters defined for property ''{0}'' in class ''{1}'' with types ''{2}'' and ''{3}''.&quot;,
<span class="fc" id="L190">            property, setter2.getDeclaringClass().getName(), paramType1.getName(), paramType2.getName()));</span>
<span class="fc" id="L191">    setMethods.put(property, invoker);</span>
<span class="fc" id="L192">    Type[] paramTypes = TypeParameterResolver.resolveParamTypes(setter1, type);</span>
<span class="fc" id="L193">    setTypes.put(property, typeToClass(paramTypes[0]));</span>
<span class="fc" id="L194">    return null;</span>
  }

  private void addSetMethod(String name, Method method) {
<span class="fc" id="L198">    MethodInvoker invoker = new MethodInvoker(method);</span>
<span class="fc" id="L199">    setMethods.put(name, invoker);</span>
<span class="fc" id="L200">    Type[] paramTypes = TypeParameterResolver.resolveParamTypes(method, type);</span>
<span class="fc" id="L201">    setTypes.put(name, typeToClass(paramTypes[0]));</span>
<span class="fc" id="L202">  }</span>

  private Class&lt;?&gt; typeToClass(Type src) {
<span class="fc" id="L205">    Class&lt;?&gt; result = null;</span>
<span class="fc bfc" id="L206" title="All 2 branches covered.">    if (src instanceof Class) {</span>
<span class="fc" id="L207">      result = (Class&lt;?&gt;) src;</span>
<span class="fc bfc" id="L208" title="All 2 branches covered.">    } else if (src instanceof ParameterizedType) {</span>
<span class="fc" id="L209">      result = (Class&lt;?&gt;) ((ParameterizedType) src).getRawType();</span>
<span class="pc bpc" id="L210" title="1 of 2 branches missed.">    } else if (src instanceof GenericArrayType) {</span>
<span class="fc" id="L211">      Type componentType = ((GenericArrayType) src).getGenericComponentType();</span>
<span class="pc bpc" id="L212" title="1 of 2 branches missed.">      if (componentType instanceof Class) {</span>
<span class="nc" id="L213">        result = Array.newInstance((Class&lt;?&gt;) componentType, 0).getClass();</span>
      } else {
<span class="fc" id="L215">        Class&lt;?&gt; componentClass = typeToClass(componentType);</span>
<span class="fc" id="L216">        result = Array.newInstance(componentClass, 0).getClass();</span>
      }
    }
<span class="pc bpc" id="L219" title="1 of 2 branches missed.">    if (result == null) {</span>
<span class="nc" id="L220">      result = Object.class;</span>
    }
<span class="fc" id="L222">    return result;</span>
  }

  private void addFields(Class&lt;?&gt; clazz) {
<span class="fc" id="L226">    Field[] fields = clazz.getDeclaredFields();</span>
<span class="fc bfc" id="L227" title="All 2 branches covered.">    for (Field field : fields) {</span>
<span class="fc bfc" id="L228" title="All 2 branches covered.">      if (!setMethods.containsKey(field.getName())) {</span>
        // issue #379 - removed the check for final because JDK 1.5 allows
        // modification of final fields through reflection (JSR-133). (JGB)
        // pr #16 - final static can only be set by the classloader
<span class="fc" id="L232">        int modifiers = field.getModifiers();</span>
<span class="fc bfc" id="L233" title="All 4 branches covered.">        if (!(Modifier.isFinal(modifiers) &amp;&amp; Modifier.isStatic(modifiers))) {</span>
<span class="fc" id="L234">          addSetField(field);</span>
        }
      }
<span class="fc bfc" id="L237" title="All 2 branches covered.">      if (!getMethods.containsKey(field.getName())) {</span>
<span class="fc" id="L238">        addGetField(field);</span>
      }
    }
<span class="fc bfc" id="L241" title="All 2 branches covered.">    if (clazz.getSuperclass() != null) {</span>
<span class="fc" id="L242">      addFields(clazz.getSuperclass());</span>
    }
<span class="fc" id="L244">  }</span>

  private void addSetField(Field field) {
<span class="fc bfc" id="L247" title="All 2 branches covered.">    if (isValidPropertyName(field.getName())) {</span>
<span class="fc" id="L248">      setMethods.put(field.getName(), new SetFieldInvoker(field));</span>
<span class="fc" id="L249">      Type fieldType = TypeParameterResolver.resolveFieldType(field, type);</span>
<span class="fc" id="L250">      setTypes.put(field.getName(), typeToClass(fieldType));</span>
    }
<span class="fc" id="L252">  }</span>

  private void addGetField(Field field) {
<span class="fc bfc" id="L255" title="All 2 branches covered.">    if (isValidPropertyName(field.getName())) {</span>
<span class="fc" id="L256">      getMethods.put(field.getName(), new GetFieldInvoker(field));</span>
<span class="fc" id="L257">      Type fieldType = TypeParameterResolver.resolveFieldType(field, type);</span>
<span class="fc" id="L258">      getTypes.put(field.getName(), typeToClass(fieldType));</span>
    }
<span class="fc" id="L260">  }</span>

  private boolean isValidPropertyName(String name) {
<span class="pc bpc" id="L263" title="1 of 6 branches missed.">    return !(name.startsWith(&quot;$&quot;) || &quot;serialVersionUID&quot;.equals(name) || &quot;class&quot;.equals(name));</span>
  }

  /**
   * This method returns an array containing all methods
   * declared in this class and any superclass.
   * We use this method, instead of the simpler &lt;code&gt;Class.getMethods()&lt;/code&gt;,
   * because we want to look for private methods as well.
   *
   * @param clazz The class
   * @return An array containing all methods in this class
   */
  private Method[] getClassMethods(Class&lt;?&gt; clazz) {
<span class="fc" id="L276">    Map&lt;String, Method&gt; uniqueMethods = new HashMap&lt;&gt;();</span>
<span class="fc" id="L277">    Class&lt;?&gt; currentClass = clazz;</span>
<span class="fc bfc" id="L278" title="All 4 branches covered.">    while (currentClass != null &amp;&amp; currentClass != Object.class) {</span>
<span class="fc" id="L279">      addUniqueMethods(uniqueMethods, currentClass.getDeclaredMethods());</span>

      // we also need to look for interface methods -
      // because the class may be abstract
<span class="fc" id="L283">      Class&lt;?&gt;[] interfaces = currentClass.getInterfaces();</span>
<span class="fc bfc" id="L284" title="All 2 branches covered.">      for (Class&lt;?&gt; anInterface : interfaces) {</span>
<span class="fc" id="L285">        addUniqueMethods(uniqueMethods, anInterface.getMethods());</span>
      }

<span class="fc" id="L288">      currentClass = currentClass.getSuperclass();</span>
<span class="fc" id="L289">    }</span>

<span class="fc" id="L291">    Collection&lt;Method&gt; methods = uniqueMethods.values();</span>

<span class="fc" id="L293">    return methods.toArray(new Method[0]);</span>
  }

  private void addUniqueMethods(Map&lt;String, Method&gt; uniqueMethods, Method[] methods) {
<span class="fc bfc" id="L297" title="All 2 branches covered.">    for (Method currentMethod : methods) {</span>
<span class="fc bfc" id="L298" title="All 2 branches covered.">      if (!currentMethod.isBridge()) {</span>
<span class="fc" id="L299">        String signature = getSignature(currentMethod);</span>
        // check to see if the method is already known
        // if it is known, then an extended class must have
        // overridden a method
<span class="fc bfc" id="L303" title="All 2 branches covered.">        if (!uniqueMethods.containsKey(signature)) {</span>
<span class="fc" id="L304">          uniqueMethods.put(signature, currentMethod);</span>
        }
      }
    }
<span class="fc" id="L308">  }</span>

  private String getSignature(Method method) {
<span class="fc" id="L311">    StringBuilder sb = new StringBuilder();</span>
<span class="fc" id="L312">    Class&lt;?&gt; returnType = method.getReturnType();</span>
<span class="pc bpc" id="L313" title="1 of 2 branches missed.">    if (returnType != null) {</span>
<span class="fc" id="L314">      sb.append(returnType.getName()).append('#');</span>
    }
<span class="fc" id="L316">    sb.append(method.getName());</span>
<span class="fc" id="L317">    Class&lt;?&gt;[] parameters = method.getParameterTypes();</span>
<span class="fc bfc" id="L318" title="All 2 branches covered.">    for (int i = 0; i &lt; parameters.length; i++) {</span>
<span class="fc bfc" id="L319" title="All 2 branches covered.">      sb.append(i == 0 ? ':' : ',').append(parameters[i].getName());</span>
    }
<span class="fc" id="L321">    return sb.toString();</span>
  }

  /**
   * Checks whether can control member accessible.
   *
   * @return If can control member accessible, it return {@literal true}
   * @since 3.5.0
   */
  public static boolean canControlMemberAccessible() {
    try {
<span class="fc" id="L332">      SecurityManager securityManager = System.getSecurityManager();</span>
<span class="pc bpc" id="L333" title="1 of 2 branches missed.">      if (null != securityManager) {</span>
<span class="nc" id="L334">        securityManager.checkPermission(new ReflectPermission(&quot;suppressAccessChecks&quot;));</span>
      }
<span class="nc" id="L336">    } catch (SecurityException e) {</span>
<span class="nc" id="L337">      return false;</span>
<span class="fc" id="L338">    }</span>
<span class="fc" id="L339">    return true;</span>
  }

  /**
   * Gets the name of the class the instance provides information for.
   *
   * @return The class name
   */
  public Class&lt;?&gt; getType() {
<span class="fc" id="L348">    return type;</span>
  }

  public Constructor&lt;?&gt; getDefaultConstructor() {
<span class="nc bnc" id="L352" title="All 2 branches missed.">    if (defaultConstructor != null) {</span>
<span class="nc" id="L353">      return defaultConstructor;</span>
    } else {
<span class="nc" id="L355">      throw new ReflectionException(&quot;There is no default constructor for &quot; + type);</span>
    }
  }

  public boolean hasDefaultConstructor() {
<span class="fc bfc" id="L360" title="All 2 branches covered.">    return defaultConstructor != null;</span>
  }

  public Invoker getSetInvoker(String propertyName) {
<span class="fc" id="L364">    Invoker method = setMethods.get(propertyName);</span>
<span class="pc bpc" id="L365" title="1 of 2 branches missed.">    if (method == null) {</span>
<span class="nc" id="L366">      throw new ReflectionException(&quot;There is no setter for property named '&quot; + propertyName + &quot;' in '&quot; + type + &quot;'&quot;);</span>
    }
<span class="fc" id="L368">    return method;</span>
  }

  public Invoker getGetInvoker(String propertyName) {
<span class="fc" id="L372">    Invoker method = getMethods.get(propertyName);</span>
<span class="fc bfc" id="L373" title="All 2 branches covered.">    if (method == null) {</span>
<span class="fc" id="L374">      throw new ReflectionException(&quot;There is no getter for property named '&quot; + propertyName + &quot;' in '&quot; + type + &quot;'&quot;);</span>
    }
<span class="fc" id="L376">    return method;</span>
  }

  /**
   * Gets the type for a property setter.
   *
   * @param propertyName - the name of the property
   * @return The Class of the property setter
   */
  public Class&lt;?&gt; getSetterType(String propertyName) {
<span class="fc" id="L386">    Class&lt;?&gt; clazz = setTypes.get(propertyName);</span>
<span class="fc bfc" id="L387" title="All 2 branches covered.">    if (clazz == null) {</span>
<span class="fc" id="L388">      throw new ReflectionException(&quot;There is no setter for property named '&quot; + propertyName + &quot;' in '&quot; + type + &quot;'&quot;);</span>
    }
<span class="fc" id="L390">    return clazz;</span>
  }

  /**
   * Gets the type for a property getter.
   *
   * @param propertyName - the name of the property
   * @return The Class of the property getter
   */
  public Class&lt;?&gt; getGetterType(String propertyName) {
<span class="fc" id="L400">    Class&lt;?&gt; clazz = getTypes.get(propertyName);</span>
<span class="fc bfc" id="L401" title="All 2 branches covered.">    if (clazz == null) {</span>
<span class="fc" id="L402">      throw new ReflectionException(&quot;There is no getter for property named '&quot; + propertyName + &quot;' in '&quot; + type + &quot;'&quot;);</span>
    }
<span class="fc" id="L404">    return clazz;</span>
  }

  /**
   * Gets an array of the readable properties for an object.
   *
   * @return The array
   */
  public String[] getGetablePropertyNames() {
<span class="fc" id="L413">    return readablePropertyNames;</span>
  }

  /**
   * Gets an array of the writable properties for an object.
   *
   * @return The array
   */
  public String[] getSetablePropertyNames() {
<span class="fc" id="L422">    return writablePropertyNames;</span>
  }

  /**
   * Check to see if a class has a writable property by name.
   *
   * @param propertyName - the name of the property to check
   * @return True if the object has a writable property by the name
   */
  public boolean hasSetter(String propertyName) {
<span class="fc" id="L432">    return setMethods.containsKey(propertyName);</span>
  }

  /**
   * Check to see if a class has a readable property by name.
   *
   * @param propertyName - the name of the property to check
   * @return True if the object has a readable property by the name
   */
  public boolean hasGetter(String propertyName) {
<span class="fc" id="L442">    return getMethods.containsKey(propertyName);</span>
  }

  public String findPropertyName(String name) {
<span class="fc" id="L446">    return caseInsensitivePropertyMap.get(name.toUpperCase(Locale.ENGLISH));</span>
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.7.202105040129</span></div></body></html>