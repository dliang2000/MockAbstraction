<!--

       Copyright ${license.git.copyrightYears} the original author or authors.

       Licensed under the Apache License, Version 2.0 (the "License");
       you may not use this file except in compliance with the License.
       You may obtain a copy of the License at

          http://www.apache.org/licenses/LICENSE-2.0

       Unless required by applicable law or agreed to in writing, software
       distributed under the License is distributed on an "AS IS" BASIS,
       WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       See the License for the specific language governing permissions and
       limitations under the License.

-->
<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>MapperAnnotationBuilder.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">mybatis</a> &gt; <a href="index.source.html" class="el_package">org.apache.ibatis.builder.annotation</a> &gt; <span class="el_source">MapperAnnotationBuilder.java</span></div><h1>MapperAnnotationBuilder.java</h1><pre class="source lang-java linenums">/**
 *    Copyright 2009-2021 the original author or authors.
 *
 *    Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 *    you may not use this file except in compliance with the License.
 *    You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *    Unless required by applicable law or agreed to in writing, software
 *    distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *    See the License for the specific language governing permissions and
 *    limitations under the License.
 */
package org.apache.ibatis.builder.annotation;

import java.io.IOException;
import java.io.InputStream;
import java.lang.annotation.Annotation;
import java.lang.reflect.Array;
import java.lang.reflect.GenericArrayType;
import java.lang.reflect.Method;
import java.lang.reflect.ParameterizedType;
import java.lang.reflect.Type;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Optional;
import java.util.Properties;
import java.util.Set;
import java.util.stream.Collectors;
import java.util.stream.Stream;

import org.apache.ibatis.annotations.Arg;
import org.apache.ibatis.annotations.CacheNamespace;
import org.apache.ibatis.annotations.CacheNamespaceRef;
import org.apache.ibatis.annotations.Case;
import org.apache.ibatis.annotations.Delete;
import org.apache.ibatis.annotations.DeleteProvider;
import org.apache.ibatis.annotations.Insert;
import org.apache.ibatis.annotations.InsertProvider;
import org.apache.ibatis.annotations.Lang;
import org.apache.ibatis.annotations.MapKey;
import org.apache.ibatis.annotations.Options;
import org.apache.ibatis.annotations.Options.FlushCachePolicy;
import org.apache.ibatis.annotations.Property;
import org.apache.ibatis.annotations.Result;
import org.apache.ibatis.annotations.ResultMap;
import org.apache.ibatis.annotations.ResultType;
import org.apache.ibatis.annotations.Results;
import org.apache.ibatis.annotations.Select;
import org.apache.ibatis.annotations.SelectKey;
import org.apache.ibatis.annotations.SelectProvider;
import org.apache.ibatis.annotations.TypeDiscriminator;
import org.apache.ibatis.annotations.Update;
import org.apache.ibatis.annotations.UpdateProvider;
import org.apache.ibatis.binding.MapperMethod.ParamMap;
import org.apache.ibatis.builder.BuilderException;
import org.apache.ibatis.builder.CacheRefResolver;
import org.apache.ibatis.builder.IncompleteElementException;
import org.apache.ibatis.builder.MapperBuilderAssistant;
import org.apache.ibatis.builder.xml.XMLMapperBuilder;
import org.apache.ibatis.cursor.Cursor;
import org.apache.ibatis.executor.keygen.Jdbc3KeyGenerator;
import org.apache.ibatis.executor.keygen.KeyGenerator;
import org.apache.ibatis.executor.keygen.NoKeyGenerator;
import org.apache.ibatis.executor.keygen.SelectKeyGenerator;
import org.apache.ibatis.io.Resources;
import org.apache.ibatis.mapping.Discriminator;
import org.apache.ibatis.mapping.FetchType;
import org.apache.ibatis.mapping.MappedStatement;
import org.apache.ibatis.mapping.ResultFlag;
import org.apache.ibatis.mapping.ResultMapping;
import org.apache.ibatis.mapping.ResultSetType;
import org.apache.ibatis.mapping.SqlCommandType;
import org.apache.ibatis.mapping.SqlSource;
import org.apache.ibatis.mapping.StatementType;
import org.apache.ibatis.parsing.PropertyParser;
import org.apache.ibatis.reflection.TypeParameterResolver;
import org.apache.ibatis.scripting.LanguageDriver;
import org.apache.ibatis.session.Configuration;
import org.apache.ibatis.session.ResultHandler;
import org.apache.ibatis.session.RowBounds;
import org.apache.ibatis.type.JdbcType;
import org.apache.ibatis.type.TypeHandler;
import org.apache.ibatis.type.UnknownTypeHandler;

/**
 * @author Clinton Begin
 * @author Kazuki Shimizu
 */
public class MapperAnnotationBuilder {

<span class="fc" id="L99">  private static final Set&lt;Class&lt;? extends Annotation&gt;&gt; statementAnnotationTypes = Stream</span>
<span class="fc" id="L100">      .of(Select.class, Update.class, Insert.class, Delete.class, SelectProvider.class, UpdateProvider.class,</span>
          InsertProvider.class, DeleteProvider.class)
<span class="fc" id="L102">      .collect(Collectors.toSet());</span>

  private final Configuration configuration;
  private final MapperBuilderAssistant assistant;
  private final Class&lt;?&gt; type;

<span class="fc" id="L108">  public MapperAnnotationBuilder(Configuration configuration, Class&lt;?&gt; type) {</span>
<span class="fc" id="L109">    String resource = type.getName().replace('.', '/') + &quot;.java (best guess)&quot;;</span>
<span class="fc" id="L110">    this.assistant = new MapperBuilderAssistant(configuration, resource);</span>
<span class="fc" id="L111">    this.configuration = configuration;</span>
<span class="fc" id="L112">    this.type = type;</span>
<span class="fc" id="L113">  }</span>

  public void parse() {
<span class="fc" id="L116">    String resource = type.toString();</span>
<span class="pc bpc" id="L117" title="1 of 2 branches missed.">    if (!configuration.isResourceLoaded(resource)) {</span>
<span class="fc" id="L118">      loadXmlResource();</span>
<span class="fc" id="L119">      configuration.addLoadedResource(resource);</span>
<span class="fc" id="L120">      assistant.setCurrentNamespace(type.getName());</span>
<span class="fc" id="L121">      parseCache();</span>
<span class="fc" id="L122">      parseCacheRef();</span>
<span class="fc bfc" id="L123" title="All 2 branches covered.">      for (Method method : type.getMethods()) {</span>
<span class="fc bfc" id="L124" title="All 2 branches covered.">        if (!canHaveStatement(method)) {</span>
<span class="fc" id="L125">          continue;</span>
        }
<span class="fc bfc" id="L127" title="All 2 branches covered.">        if (getAnnotationWrapper(method, false, Select.class, SelectProvider.class).isPresent()</span>
<span class="fc bfc" id="L128" title="All 2 branches covered.">            &amp;&amp; method.getAnnotation(ResultMap.class) == null) {</span>
<span class="fc" id="L129">          parseResultMap(method);</span>
        }
        try {
<span class="fc" id="L132">          parseStatement(method);</span>
<span class="fc" id="L133">        } catch (IncompleteElementException e) {</span>
<span class="fc" id="L134">          configuration.addIncompleteMethod(new MethodResolver(this, method));</span>
<span class="fc" id="L135">        }</span>
      }
    }
<span class="fc" id="L138">    parsePendingMethods();</span>
<span class="fc" id="L139">  }</span>

  private boolean canHaveStatement(Method method) {
    // issue #237
<span class="fc bfc" id="L143" title="All 4 branches covered.">    return !method.isBridge() &amp;&amp; !method.isDefault();</span>
  }

  private void parsePendingMethods() {
<span class="fc" id="L147">    Collection&lt;MethodResolver&gt; incompleteMethods = configuration.getIncompleteMethods();</span>
<span class="fc" id="L148">    synchronized (incompleteMethods) {</span>
<span class="fc" id="L149">      Iterator&lt;MethodResolver&gt; iter = incompleteMethods.iterator();</span>
<span class="fc bfc" id="L150" title="All 2 branches covered.">      while (iter.hasNext()) {</span>
        try {
<span class="fc" id="L152">          iter.next().resolve();</span>
<span class="fc" id="L153">          iter.remove();</span>
<span class="fc" id="L154">        } catch (IncompleteElementException e) {</span>
          // This method is still missing a resource
<span class="fc" id="L156">        }</span>
      }
<span class="fc" id="L158">    }</span>
<span class="fc" id="L159">  }</span>

  private void loadXmlResource() {
    // Spring may not know the real resource name so we check a flag
    // to prevent loading again a resource twice
    // this flag is set at XMLMapperBuilder#bindMapperForNamespace
<span class="fc bfc" id="L165" title="All 2 branches covered.">    if (!configuration.isResourceLoaded(&quot;namespace:&quot; + type.getName())) {</span>
<span class="fc" id="L166">      String xmlResource = type.getName().replace('.', '/') + &quot;.xml&quot;;</span>
      // #1347
<span class="fc" id="L168">      InputStream inputStream = type.getResourceAsStream(&quot;/&quot; + xmlResource);</span>
<span class="fc bfc" id="L169" title="All 2 branches covered.">      if (inputStream == null) {</span>
        // Search XML mapper that is not in the module but in the classpath.
        try {
<span class="nc" id="L172">          inputStream = Resources.getResourceAsStream(type.getClassLoader(), xmlResource);</span>
<span class="fc" id="L173">        } catch (IOException e2) {</span>
          // ignore, resource is not required
<span class="nc" id="L175">        }</span>
      }
<span class="fc bfc" id="L177" title="All 2 branches covered.">      if (inputStream != null) {</span>
<span class="fc" id="L178">        XMLMapperBuilder xmlParser = new XMLMapperBuilder(inputStream, assistant.getConfiguration(), xmlResource, configuration.getSqlFragments(), type.getName());</span>
<span class="fc" id="L179">        xmlParser.parse();</span>
      }
    }
<span class="fc" id="L182">  }</span>

  private void parseCache() {
<span class="fc" id="L185">    CacheNamespace cacheDomain = type.getAnnotation(CacheNamespace.class);</span>
<span class="fc bfc" id="L186" title="All 2 branches covered.">    if (cacheDomain != null) {</span>
<span class="pc bpc" id="L187" title="1 of 2 branches missed.">      Integer size = cacheDomain.size() == 0 ? null : cacheDomain.size();</span>
<span class="pc bpc" id="L188" title="1 of 2 branches missed.">      Long flushInterval = cacheDomain.flushInterval() == 0 ? null : cacheDomain.flushInterval();</span>
<span class="fc" id="L189">      Properties props = convertToProperties(cacheDomain.properties());</span>
<span class="fc" id="L190">      assistant.useNewCache(cacheDomain.implementation(), cacheDomain.eviction(), flushInterval, size, cacheDomain.readWrite(), cacheDomain.blocking(), props);</span>
    }
<span class="fc" id="L192">  }</span>

  private Properties convertToProperties(Property[] properties) {
<span class="fc bfc" id="L195" title="All 2 branches covered.">    if (properties.length == 0) {</span>
<span class="fc" id="L196">      return null;</span>
    }
<span class="fc" id="L198">    Properties props = new Properties();</span>
<span class="fc bfc" id="L199" title="All 2 branches covered.">    for (Property property : properties) {</span>
<span class="fc" id="L200">      props.setProperty(property.name(),</span>
<span class="fc" id="L201">          PropertyParser.parse(property.value(), configuration.getVariables()));</span>
    }
<span class="fc" id="L203">    return props;</span>
  }

  private void parseCacheRef() {
<span class="fc" id="L207">    CacheNamespaceRef cacheDomainRef = type.getAnnotation(CacheNamespaceRef.class);</span>
<span class="fc bfc" id="L208" title="All 2 branches covered.">    if (cacheDomainRef != null) {</span>
<span class="fc" id="L209">      Class&lt;?&gt; refType = cacheDomainRef.value();</span>
<span class="fc" id="L210">      String refName = cacheDomainRef.name();</span>
<span class="fc bfc" id="L211" title="All 4 branches covered.">      if (refType == void.class &amp;&amp; refName.isEmpty()) {</span>
<span class="fc" id="L212">        throw new BuilderException(&quot;Should be specified either value() or name() attribute in the @CacheNamespaceRef&quot;);</span>
      }
<span class="fc bfc" id="L214" title="All 4 branches covered.">      if (refType != void.class &amp;&amp; !refName.isEmpty()) {</span>
<span class="fc" id="L215">        throw new BuilderException(&quot;Cannot use both value() and name() attribute in the @CacheNamespaceRef&quot;);</span>
      }
<span class="fc bfc" id="L217" title="All 2 branches covered.">      String namespace = (refType != void.class) ? refType.getName() : refName;</span>
      try {
<span class="fc" id="L219">        assistant.useCacheRef(namespace);</span>
<span class="fc" id="L220">      } catch (IncompleteElementException e) {</span>
<span class="fc" id="L221">        configuration.addIncompleteCacheRef(new CacheRefResolver(assistant, namespace));</span>
<span class="fc" id="L222">      }</span>
    }
<span class="fc" id="L224">  }</span>

  private String parseResultMap(Method method) {
<span class="fc" id="L227">    Class&lt;?&gt; returnType = getReturnType(method);</span>
<span class="fc" id="L228">    Arg[] args = method.getAnnotationsByType(Arg.class);</span>
<span class="fc" id="L229">    Result[] results = method.getAnnotationsByType(Result.class);</span>
<span class="fc" id="L230">    TypeDiscriminator typeDiscriminator = method.getAnnotation(TypeDiscriminator.class);</span>
<span class="fc" id="L231">    String resultMapId = generateResultMapName(method);</span>
<span class="fc" id="L232">    applyResultMap(resultMapId, returnType, args, results, typeDiscriminator);</span>
<span class="fc" id="L233">    return resultMapId;</span>
  }

  private String generateResultMapName(Method method) {
<span class="fc" id="L237">    Results results = method.getAnnotation(Results.class);</span>
<span class="fc bfc" id="L238" title="All 4 branches covered.">    if (results != null &amp;&amp; !results.id().isEmpty()) {</span>
<span class="fc" id="L239">      return type.getName() + &quot;.&quot; + results.id();</span>
    }
<span class="fc" id="L241">    StringBuilder suffix = new StringBuilder();</span>
<span class="fc bfc" id="L242" title="All 2 branches covered.">    for (Class&lt;?&gt; c : method.getParameterTypes()) {</span>
<span class="fc" id="L243">      suffix.append(&quot;-&quot;);</span>
<span class="fc" id="L244">      suffix.append(c.getSimpleName());</span>
    }
<span class="fc bfc" id="L246" title="All 2 branches covered.">    if (suffix.length() &lt; 1) {</span>
<span class="fc" id="L247">      suffix.append(&quot;-void&quot;);</span>
    }
<span class="fc" id="L249">    return type.getName() + &quot;.&quot; + method.getName() + suffix;</span>
  }

  private void applyResultMap(String resultMapId, Class&lt;?&gt; returnType, Arg[] args, Result[] results, TypeDiscriminator discriminator) {
<span class="fc" id="L253">    List&lt;ResultMapping&gt; resultMappings = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L254">    applyConstructorArgs(args, returnType, resultMappings);</span>
<span class="fc" id="L255">    applyResults(results, returnType, resultMappings);</span>
<span class="fc" id="L256">    Discriminator disc = applyDiscriminator(resultMapId, returnType, discriminator);</span>
    // TODO add AutoMappingBehaviour
<span class="fc" id="L258">    assistant.addResultMap(resultMapId, returnType, null, disc, resultMappings, null);</span>
<span class="fc" id="L259">    createDiscriminatorResultMaps(resultMapId, returnType, discriminator);</span>
<span class="fc" id="L260">  }</span>

  private void createDiscriminatorResultMaps(String resultMapId, Class&lt;?&gt; resultType, TypeDiscriminator discriminator) {
<span class="fc bfc" id="L263" title="All 2 branches covered.">    if (discriminator != null) {</span>
<span class="fc bfc" id="L264" title="All 2 branches covered.">      for (Case c : discriminator.cases()) {</span>
<span class="fc" id="L265">        String caseResultMapId = resultMapId + &quot;-&quot; + c.value();</span>
<span class="fc" id="L266">        List&lt;ResultMapping&gt; resultMappings = new ArrayList&lt;&gt;();</span>
        // issue #136
<span class="fc" id="L268">        applyConstructorArgs(c.constructArgs(), resultType, resultMappings);</span>
<span class="fc" id="L269">        applyResults(c.results(), resultType, resultMappings);</span>
        // TODO add AutoMappingBehaviour
<span class="fc" id="L271">        assistant.addResultMap(caseResultMapId, c.type(), resultMapId, null, resultMappings, null);</span>
      }
    }
<span class="fc" id="L274">  }</span>

  private Discriminator applyDiscriminator(String resultMapId, Class&lt;?&gt; resultType, TypeDiscriminator discriminator) {
<span class="fc bfc" id="L277" title="All 2 branches covered.">    if (discriminator != null) {</span>
<span class="fc" id="L278">      String column = discriminator.column();</span>
<span class="pc bpc" id="L279" title="1 of 2 branches missed.">      Class&lt;?&gt; javaType = discriminator.javaType() == void.class ? String.class : discriminator.javaType();</span>
<span class="pc bpc" id="L280" title="1 of 2 branches missed.">      JdbcType jdbcType = discriminator.jdbcType() == JdbcType.UNDEFINED ? null : discriminator.jdbcType();</span>
      @SuppressWarnings(&quot;unchecked&quot;)
<span class="fc" id="L282">      Class&lt;? extends TypeHandler&lt;?&gt;&gt; typeHandler = (Class&lt;? extends TypeHandler&lt;?&gt;&gt;)</span>
<span class="fc bfc" id="L283" title="All 2 branches covered.">              (discriminator.typeHandler() == UnknownTypeHandler.class ? null : discriminator.typeHandler());</span>
<span class="fc" id="L284">      Case[] cases = discriminator.cases();</span>
<span class="fc" id="L285">      Map&lt;String, String&gt; discriminatorMap = new HashMap&lt;&gt;();</span>
<span class="fc bfc" id="L286" title="All 2 branches covered.">      for (Case c : cases) {</span>
<span class="fc" id="L287">        String value = c.value();</span>
<span class="fc" id="L288">        String caseResultMapId = resultMapId + &quot;-&quot; + value;</span>
<span class="fc" id="L289">        discriminatorMap.put(value, caseResultMapId);</span>
      }
<span class="fc" id="L291">      return assistant.buildDiscriminator(resultType, column, javaType, jdbcType, typeHandler, discriminatorMap);</span>
    }
<span class="fc" id="L293">    return null;</span>
  }

  void parseStatement(Method method) {
<span class="fc" id="L297">    final Class&lt;?&gt; parameterTypeClass = getParameterType(method);</span>
<span class="fc" id="L298">    final LanguageDriver languageDriver = getLanguageDriver(method);</span>

<span class="fc" id="L300">    getAnnotationWrapper(method, true, statementAnnotationTypes).ifPresent(statementAnnotation -&gt; {</span>
<span class="fc" id="L301">      final SqlSource sqlSource = buildSqlSource(statementAnnotation.getAnnotation(), parameterTypeClass, languageDriver, method);</span>
<span class="fc" id="L302">      final SqlCommandType sqlCommandType = statementAnnotation.getSqlCommandType();</span>
<span class="fc" id="L303">      final Options options = getAnnotationWrapper(method, false, Options.class).map(x -&gt; (Options)x.getAnnotation()).orElse(null);</span>
<span class="fc" id="L304">      final String mappedStatementId = type.getName() + &quot;.&quot; + method.getName();</span>

      final KeyGenerator keyGenerator;
<span class="fc" id="L307">      String keyProperty = null;</span>
<span class="fc" id="L308">      String keyColumn = null;</span>
<span class="fc bfc" id="L309" title="All 4 branches covered.">      if (SqlCommandType.INSERT.equals(sqlCommandType) || SqlCommandType.UPDATE.equals(sqlCommandType)) {</span>
        // first check for SelectKey annotation - that overrides everything else
<span class="fc" id="L311">        SelectKey selectKey = getAnnotationWrapper(method, false, SelectKey.class).map(x -&gt; (SelectKey)x.getAnnotation()).orElse(null);</span>
<span class="fc bfc" id="L312" title="All 2 branches covered.">        if (selectKey != null) {</span>
<span class="fc" id="L313">          keyGenerator = handleSelectKeyAnnotation(selectKey, mappedStatementId, getParameterType(method), languageDriver);</span>
<span class="fc" id="L314">          keyProperty = selectKey.keyProperty();</span>
<span class="fc bfc" id="L315" title="All 2 branches covered.">        } else if (options == null) {</span>
<span class="fc bfc" id="L316" title="All 2 branches covered.">          keyGenerator = configuration.isUseGeneratedKeys() ? Jdbc3KeyGenerator.INSTANCE : NoKeyGenerator.INSTANCE;</span>
        } else {
<span class="fc bfc" id="L318" title="All 2 branches covered.">          keyGenerator = options.useGeneratedKeys() ? Jdbc3KeyGenerator.INSTANCE : NoKeyGenerator.INSTANCE;</span>
<span class="fc" id="L319">          keyProperty = options.keyProperty();</span>
<span class="fc" id="L320">          keyColumn = options.keyColumn();</span>
        }
<span class="fc" id="L322">      } else {</span>
<span class="fc" id="L323">        keyGenerator = NoKeyGenerator.INSTANCE;</span>
      }

<span class="fc" id="L326">      Integer fetchSize = null;</span>
<span class="fc" id="L327">      Integer timeout = null;</span>
<span class="fc" id="L328">      StatementType statementType = StatementType.PREPARED;</span>
<span class="fc" id="L329">      ResultSetType resultSetType = configuration.getDefaultResultSetType();</span>
<span class="fc bfc" id="L330" title="All 2 branches covered.">      boolean isSelect = sqlCommandType == SqlCommandType.SELECT;</span>
<span class="fc bfc" id="L331" title="All 2 branches covered.">      boolean flushCache = !isSelect;</span>
<span class="fc" id="L332">      boolean useCache = isSelect;</span>
<span class="fc bfc" id="L333" title="All 2 branches covered.">      if (options != null) {</span>
<span class="fc bfc" id="L334" title="All 2 branches covered.">        if (FlushCachePolicy.TRUE.equals(options.flushCache())) {</span>
<span class="fc" id="L335">          flushCache = true;</span>
<span class="fc bfc" id="L336" title="All 2 branches covered.">        } else if (FlushCachePolicy.FALSE.equals(options.flushCache())) {</span>
<span class="fc" id="L337">          flushCache = false;</span>
        }
<span class="fc" id="L339">        useCache = options.useCache();</span>
<span class="fc bfc" id="L340" title="All 4 branches covered.">        fetchSize = options.fetchSize() &gt; -1 || options.fetchSize() == Integer.MIN_VALUE ? options.fetchSize() : null; //issue #348</span>
<span class="fc bfc" id="L341" title="All 2 branches covered.">        timeout = options.timeout() &gt; -1 ? options.timeout() : null;</span>
<span class="fc" id="L342">        statementType = options.statementType();</span>
<span class="fc bfc" id="L343" title="All 2 branches covered.">        if (options.resultSetType() != ResultSetType.DEFAULT) {</span>
<span class="fc" id="L344">          resultSetType = options.resultSetType();</span>
        }
      }

<span class="fc" id="L348">      String resultMapId = null;</span>
<span class="fc bfc" id="L349" title="All 2 branches covered.">      if (isSelect) {</span>
<span class="fc" id="L350">        ResultMap resultMapAnnotation = method.getAnnotation(ResultMap.class);</span>
<span class="fc bfc" id="L351" title="All 2 branches covered.">        if (resultMapAnnotation != null) {</span>
<span class="fc" id="L352">          resultMapId = String.join(&quot;,&quot;, resultMapAnnotation.value());</span>
        } else {
<span class="fc" id="L354">          resultMapId = generateResultMapName(method);</span>
        }
      }

<span class="fc" id="L358">      assistant.addMappedStatement(</span>
          mappedStatementId,
          sqlSource,
          statementType,
          sqlCommandType,
          fetchSize,
          timeout,
          // ParameterMapID
          null,
          parameterTypeClass,
          resultMapId,
<span class="fc" id="L369">          getReturnType(method),</span>
          resultSetType,
          flushCache,
          useCache,
          // TODO gcode issue #577
          false,
          keyGenerator,
          keyProperty,
          keyColumn,
<span class="fc bfc" id="L378" title="All 2 branches covered.">          statementAnnotation.getDatabaseId(),</span>
          languageDriver,
          // ResultSets
<span class="fc" id="L381">          options != null ? nullOrEmpty(options.resultSets()) : null);</span>
<span class="fc" id="L382">    });</span>
<span class="fc" id="L383">  }</span>

  private LanguageDriver getLanguageDriver(Method method) {
<span class="fc" id="L386">    Lang lang = method.getAnnotation(Lang.class);</span>
<span class="fc" id="L387">    Class&lt;? extends LanguageDriver&gt; langClass = null;</span>
<span class="fc bfc" id="L388" title="All 2 branches covered.">    if (lang != null) {</span>
<span class="fc" id="L389">      langClass = lang.value();</span>
    }
<span class="fc" id="L391">    return configuration.getLanguageDriver(langClass);</span>
  }

  private Class&lt;?&gt; getParameterType(Method method) {
<span class="fc" id="L395">    Class&lt;?&gt; parameterType = null;</span>
<span class="fc" id="L396">    Class&lt;?&gt;[] parameterTypes = method.getParameterTypes();</span>
<span class="fc bfc" id="L397" title="All 2 branches covered.">    for (Class&lt;?&gt; currentParameterType : parameterTypes) {</span>
<span class="fc bfc" id="L398" title="All 4 branches covered.">      if (!RowBounds.class.isAssignableFrom(currentParameterType) &amp;&amp; !ResultHandler.class.isAssignableFrom(currentParameterType)) {</span>
<span class="fc bfc" id="L399" title="All 2 branches covered.">        if (parameterType == null) {</span>
<span class="fc" id="L400">          parameterType = currentParameterType;</span>
        } else {
          // issue #135
<span class="fc" id="L403">          parameterType = ParamMap.class;</span>
        }
      }
    }
<span class="fc" id="L407">    return parameterType;</span>
  }

  private Class&lt;?&gt; getReturnType(Method method) {
<span class="fc" id="L411">    Class&lt;?&gt; returnType = method.getReturnType();</span>
<span class="fc" id="L412">    Type resolvedReturnType = TypeParameterResolver.resolveReturnType(method, type);</span>
<span class="fc bfc" id="L413" title="All 2 branches covered.">    if (resolvedReturnType instanceof Class) {</span>
<span class="fc" id="L414">      returnType = (Class&lt;?&gt;) resolvedReturnType;</span>
<span class="fc bfc" id="L415" title="All 2 branches covered.">      if (returnType.isArray()) {</span>
<span class="fc" id="L416">        returnType = returnType.getComponentType();</span>
      }
      // gcode issue #508
<span class="fc bfc" id="L419" title="All 2 branches covered.">      if (void.class.equals(returnType)) {</span>
<span class="fc" id="L420">        ResultType rt = method.getAnnotation(ResultType.class);</span>
<span class="fc bfc" id="L421" title="All 2 branches covered.">        if (rt != null) {</span>
<span class="fc" id="L422">          returnType = rt.value();</span>
        }
<span class="fc" id="L424">      }</span>
<span class="pc bpc" id="L425" title="1 of 2 branches missed.">    } else if (resolvedReturnType instanceof ParameterizedType) {</span>
<span class="fc" id="L426">      ParameterizedType parameterizedType = (ParameterizedType) resolvedReturnType;</span>
<span class="fc" id="L427">      Class&lt;?&gt; rawType = (Class&lt;?&gt;) parameterizedType.getRawType();</span>
<span class="fc bfc" id="L428" title="All 4 branches covered.">      if (Collection.class.isAssignableFrom(rawType) || Cursor.class.isAssignableFrom(rawType)) {</span>
<span class="fc" id="L429">        Type[] actualTypeArguments = parameterizedType.getActualTypeArguments();</span>
<span class="pc bpc" id="L430" title="2 of 4 branches missed.">        if (actualTypeArguments != null &amp;&amp; actualTypeArguments.length == 1) {</span>
<span class="fc" id="L431">          Type returnTypeParameter = actualTypeArguments[0];</span>
<span class="fc bfc" id="L432" title="All 2 branches covered.">          if (returnTypeParameter instanceof Class&lt;?&gt;) {</span>
<span class="fc" id="L433">            returnType = (Class&lt;?&gt;) returnTypeParameter;</span>
<span class="pc bpc" id="L434" title="1 of 2 branches missed.">          } else if (returnTypeParameter instanceof ParameterizedType) {</span>
            // (gcode issue #443) actual type can be a also a parameterized type
<span class="fc" id="L436">            returnType = (Class&lt;?&gt;) ((ParameterizedType) returnTypeParameter).getRawType();</span>
<span class="nc bnc" id="L437" title="All 2 branches missed.">          } else if (returnTypeParameter instanceof GenericArrayType) {</span>
<span class="nc" id="L438">            Class&lt;?&gt; componentType = (Class&lt;?&gt;) ((GenericArrayType) returnTypeParameter).getGenericComponentType();</span>
            // (gcode issue #525) support List&lt;byte[]&gt;
<span class="nc" id="L440">            returnType = Array.newInstance(componentType, 0).getClass();</span>
          }
        }
<span class="pc bpc" id="L443" title="1 of 4 branches missed.">      } else if (method.isAnnotationPresent(MapKey.class) &amp;&amp; Map.class.isAssignableFrom(rawType)) {</span>
        // (gcode issue 504) Do not look into Maps if there is not MapKey annotation
<span class="fc" id="L445">        Type[] actualTypeArguments = parameterizedType.getActualTypeArguments();</span>
<span class="pc bpc" id="L446" title="2 of 4 branches missed.">        if (actualTypeArguments != null &amp;&amp; actualTypeArguments.length == 2) {</span>
<span class="fc" id="L447">          Type returnTypeParameter = actualTypeArguments[1];</span>
<span class="fc bfc" id="L448" title="All 2 branches covered.">          if (returnTypeParameter instanceof Class&lt;?&gt;) {</span>
<span class="fc" id="L449">            returnType = (Class&lt;?&gt;) returnTypeParameter;</span>
<span class="pc bpc" id="L450" title="1 of 2 branches missed.">          } else if (returnTypeParameter instanceof ParameterizedType) {</span>
            // (gcode issue 443) actual type can be a also a parameterized type
<span class="fc" id="L452">            returnType = (Class&lt;?&gt;) ((ParameterizedType) returnTypeParameter).getRawType();</span>
          }
        }
<span class="fc bfc" id="L455" title="All 2 branches covered.">      } else if (Optional.class.equals(rawType)) {</span>
<span class="fc" id="L456">        Type[] actualTypeArguments = parameterizedType.getActualTypeArguments();</span>
<span class="fc" id="L457">        Type returnTypeParameter = actualTypeArguments[0];</span>
<span class="pc bpc" id="L458" title="1 of 2 branches missed.">        if (returnTypeParameter instanceof Class&lt;?&gt;) {</span>
<span class="fc" id="L459">          returnType = (Class&lt;?&gt;) returnTypeParameter;</span>
        }
      }
    }

<span class="fc" id="L464">    return returnType;</span>
  }

  private void applyResults(Result[] results, Class&lt;?&gt; resultType, List&lt;ResultMapping&gt; resultMappings) {
<span class="fc bfc" id="L468" title="All 2 branches covered.">    for (Result result : results) {</span>
<span class="fc" id="L469">      List&lt;ResultFlag&gt; flags = new ArrayList&lt;&gt;();</span>
<span class="fc bfc" id="L470" title="All 2 branches covered.">      if (result.id()) {</span>
<span class="fc" id="L471">        flags.add(ResultFlag.ID);</span>
      }
      @SuppressWarnings(&quot;unchecked&quot;)
<span class="fc" id="L474">      Class&lt;? extends TypeHandler&lt;?&gt;&gt; typeHandler = (Class&lt;? extends TypeHandler&lt;?&gt;&gt;)</span>
<span class="fc bfc" id="L475" title="All 2 branches covered.">              ((result.typeHandler() == UnknownTypeHandler.class) ? null : result.typeHandler());</span>
<span class="fc" id="L476">      boolean hasNestedResultMap = hasNestedResultMap(result);</span>
<span class="fc" id="L477">      ResultMapping resultMapping = assistant.buildResultMapping(</span>
          resultType,
<span class="fc" id="L479">          nullOrEmpty(result.property()),</span>
<span class="fc" id="L480">          nullOrEmpty(result.column()),</span>
<span class="fc bfc" id="L481" title="All 2 branches covered.">          result.javaType() == void.class ? null : result.javaType(),</span>
<span class="fc bfc" id="L482" title="All 2 branches covered.">          result.jdbcType() == JdbcType.UNDEFINED ? null : result.jdbcType(),</span>
<span class="fc bfc" id="L483" title="All 4 branches covered.">          hasNestedSelect(result) ? nestedSelectId(result) : null,</span>
<span class="fc bfc" id="L484" title="All 2 branches covered.">          hasNestedResultMap ? nestedResultMapId(result) : null,</span>
          null,
<span class="fc" id="L486">          hasNestedResultMap ? findColumnPrefix(result) : null,</span>
          typeHandler,
          flags,
          null,
          null,
<span class="fc" id="L491">          isLazy(result));</span>
<span class="fc" id="L492">      resultMappings.add(resultMapping);</span>
    }
<span class="fc" id="L494">  }</span>

  private String findColumnPrefix(Result result) {
<span class="fc" id="L497">    String columnPrefix = result.one().columnPrefix();</span>
<span class="fc bfc" id="L498" title="All 2 branches covered.">    if (columnPrefix.length() &lt; 1) {</span>
<span class="fc" id="L499">      columnPrefix = result.many().columnPrefix();</span>
    }
<span class="fc" id="L501">    return columnPrefix;</span>
  }

  private String nestedResultMapId(Result result) {
<span class="fc" id="L505">    String resultMapId = result.one().resultMap();</span>
<span class="fc bfc" id="L506" title="All 2 branches covered.">    if (resultMapId.length() &lt; 1) {</span>
<span class="fc" id="L507">      resultMapId = result.many().resultMap();</span>
    }
<span class="fc bfc" id="L509" title="All 2 branches covered.">    if (!resultMapId.contains(&quot;.&quot;)) {</span>
<span class="fc" id="L510">      resultMapId = type.getName() + &quot;.&quot; + resultMapId;</span>
    }
<span class="fc" id="L512">    return resultMapId;</span>
  }

  private boolean hasNestedResultMap(Result result) {
<span class="pc bpc" id="L516" title="1 of 4 branches missed.">    if (result.one().resultMap().length() &gt; 0 &amp;&amp; result.many().resultMap().length() &gt; 0) {</span>
<span class="nc" id="L517">      throw new BuilderException(&quot;Cannot use both @One and @Many annotations in the same @Result&quot;);</span>
    }
<span class="fc bfc" id="L519" title="All 4 branches covered.">    return result.one().resultMap().length() &gt; 0 || result.many().resultMap().length() &gt; 0;</span>
  }

  private String nestedSelectId(Result result) {
<span class="fc" id="L523">    String nestedSelect = result.one().select();</span>
<span class="fc bfc" id="L524" title="All 2 branches covered.">    if (nestedSelect.length() &lt; 1) {</span>
<span class="fc" id="L525">      nestedSelect = result.many().select();</span>
    }
<span class="fc bfc" id="L527" title="All 2 branches covered.">    if (!nestedSelect.contains(&quot;.&quot;)) {</span>
<span class="fc" id="L528">      nestedSelect = type.getName() + &quot;.&quot; + nestedSelect;</span>
    }
<span class="fc" id="L530">    return nestedSelect;</span>
  }

  private boolean isLazy(Result result) {
<span class="fc" id="L534">    boolean isLazy = configuration.isLazyLoadingEnabled();</span>
<span class="fc bfc" id="L535" title="All 4 branches covered.">    if (result.one().select().length() &gt; 0 &amp;&amp; FetchType.DEFAULT != result.one().fetchType()) {</span>
<span class="pc bpc" id="L536" title="1 of 2 branches missed.">      isLazy = result.one().fetchType() == FetchType.LAZY;</span>
<span class="fc bfc" id="L537" title="All 4 branches covered.">    } else if (result.many().select().length() &gt; 0 &amp;&amp; FetchType.DEFAULT != result.many().fetchType()) {</span>
<span class="pc bpc" id="L538" title="1 of 2 branches missed.">      isLazy = result.many().fetchType() == FetchType.LAZY;</span>
    }
<span class="fc" id="L540">    return isLazy;</span>
  }

  private boolean hasNestedSelect(Result result) {
<span class="fc bfc" id="L544" title="All 4 branches covered.">    if (result.one().select().length() &gt; 0 &amp;&amp; result.many().select().length() &gt; 0) {</span>
<span class="fc" id="L545">      throw new BuilderException(&quot;Cannot use both @One and @Many annotations in the same @Result&quot;);</span>
    }
<span class="fc bfc" id="L547" title="All 4 branches covered.">    return result.one().select().length() &gt; 0 || result.many().select().length() &gt; 0;</span>
  }

  private void applyConstructorArgs(Arg[] args, Class&lt;?&gt; resultType, List&lt;ResultMapping&gt; resultMappings) {
<span class="fc bfc" id="L551" title="All 2 branches covered.">    for (Arg arg : args) {</span>
<span class="fc" id="L552">      List&lt;ResultFlag&gt; flags = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L553">      flags.add(ResultFlag.CONSTRUCTOR);</span>
<span class="fc bfc" id="L554" title="All 2 branches covered.">      if (arg.id()) {</span>
<span class="fc" id="L555">        flags.add(ResultFlag.ID);</span>
      }
      @SuppressWarnings(&quot;unchecked&quot;)
<span class="fc" id="L558">      Class&lt;? extends TypeHandler&lt;?&gt;&gt; typeHandler = (Class&lt;? extends TypeHandler&lt;?&gt;&gt;)</span>
<span class="fc bfc" id="L559" title="All 2 branches covered.">              (arg.typeHandler() == UnknownTypeHandler.class ? null : arg.typeHandler());</span>
<span class="fc" id="L560">      ResultMapping resultMapping = assistant.buildResultMapping(</span>
          resultType,
<span class="fc" id="L562">          nullOrEmpty(arg.name()),</span>
<span class="fc" id="L563">          nullOrEmpty(arg.column()),</span>
<span class="fc bfc" id="L564" title="All 2 branches covered.">          arg.javaType() == void.class ? null : arg.javaType(),</span>
<span class="fc bfc" id="L565" title="All 2 branches covered.">          arg.jdbcType() == JdbcType.UNDEFINED ? null : arg.jdbcType(),</span>
<span class="fc" id="L566">          nullOrEmpty(arg.select()),</span>
<span class="fc" id="L567">          nullOrEmpty(arg.resultMap()),</span>
          null,
<span class="fc" id="L569">          nullOrEmpty(arg.columnPrefix()),</span>
          typeHandler,
          flags,
          null,
          null,
          false);
<span class="fc" id="L575">      resultMappings.add(resultMapping);</span>
    }
<span class="fc" id="L577">  }</span>

  private String nullOrEmpty(String value) {
<span class="pc bpc" id="L580" title="1 of 4 branches missed.">    return value == null || value.trim().length() == 0 ? null : value;</span>
  }

  private KeyGenerator handleSelectKeyAnnotation(SelectKey selectKeyAnnotation, String baseStatementId, Class&lt;?&gt; parameterTypeClass, LanguageDriver languageDriver) {
<span class="fc" id="L584">    String id = baseStatementId + SelectKeyGenerator.SELECT_KEY_SUFFIX;</span>
<span class="fc" id="L585">    Class&lt;?&gt; resultTypeClass = selectKeyAnnotation.resultType();</span>
<span class="fc" id="L586">    StatementType statementType = selectKeyAnnotation.statementType();</span>
<span class="fc" id="L587">    String keyProperty = selectKeyAnnotation.keyProperty();</span>
<span class="fc" id="L588">    String keyColumn = selectKeyAnnotation.keyColumn();</span>
<span class="fc" id="L589">    boolean executeBefore = selectKeyAnnotation.before();</span>

    // defaults
<span class="fc" id="L592">    boolean useCache = false;</span>
<span class="fc" id="L593">    KeyGenerator keyGenerator = NoKeyGenerator.INSTANCE;</span>
<span class="fc" id="L594">    Integer fetchSize = null;</span>
<span class="fc" id="L595">    Integer timeout = null;</span>
<span class="fc" id="L596">    boolean flushCache = false;</span>
<span class="fc" id="L597">    String parameterMap = null;</span>
<span class="fc" id="L598">    String resultMap = null;</span>
<span class="fc" id="L599">    ResultSetType resultSetTypeEnum = null;</span>
<span class="fc bfc" id="L600" title="All 2 branches covered.">    String databaseId = selectKeyAnnotation.databaseId().isEmpty() ? null : selectKeyAnnotation.databaseId();</span>

<span class="fc" id="L602">    SqlSource sqlSource = buildSqlSource(selectKeyAnnotation, parameterTypeClass, languageDriver, null);</span>
<span class="fc" id="L603">    SqlCommandType sqlCommandType = SqlCommandType.SELECT;</span>

<span class="fc" id="L605">    assistant.addMappedStatement(id, sqlSource, statementType, sqlCommandType, fetchSize, timeout, parameterMap, parameterTypeClass, resultMap, resultTypeClass, resultSetTypeEnum,</span>
        flushCache, useCache, false,
        keyGenerator, keyProperty, keyColumn, databaseId, languageDriver, null);

<span class="fc" id="L609">    id = assistant.applyCurrentNamespace(id, false);</span>

<span class="fc" id="L611">    MappedStatement keyStatement = configuration.getMappedStatement(id, false);</span>
<span class="fc" id="L612">    SelectKeyGenerator answer = new SelectKeyGenerator(keyStatement, executeBefore);</span>
<span class="fc" id="L613">    configuration.addKeyGenerator(id, answer);</span>
<span class="fc" id="L614">    return answer;</span>
  }

  private SqlSource buildSqlSource(Annotation annotation, Class&lt;?&gt; parameterType, LanguageDriver languageDriver,
      Method method) {
<span class="fc bfc" id="L619" title="All 2 branches covered.">    if (annotation instanceof Select) {</span>
<span class="fc" id="L620">      return buildSqlSourceFromStrings(((Select) annotation).value(), parameterType, languageDriver);</span>
<span class="fc bfc" id="L621" title="All 2 branches covered.">    } else if (annotation instanceof Update) {</span>
<span class="fc" id="L622">      return buildSqlSourceFromStrings(((Update) annotation).value(), parameterType, languageDriver);</span>
<span class="fc bfc" id="L623" title="All 2 branches covered.">    } else if (annotation instanceof Insert) {</span>
<span class="fc" id="L624">      return buildSqlSourceFromStrings(((Insert) annotation).value(), parameterType, languageDriver);</span>
<span class="fc bfc" id="L625" title="All 2 branches covered.">    } else if (annotation instanceof Delete) {</span>
<span class="fc" id="L626">      return buildSqlSourceFromStrings(((Delete) annotation).value(), parameterType, languageDriver);</span>
<span class="fc bfc" id="L627" title="All 2 branches covered.">    } else if (annotation instanceof SelectKey) {</span>
<span class="fc" id="L628">      return buildSqlSourceFromStrings(((SelectKey) annotation).statement(), parameterType, languageDriver);</span>
    }
<span class="fc" id="L630">    return new ProviderSqlSource(assistant.getConfiguration(), annotation, type, method);</span>
  }

  private SqlSource buildSqlSourceFromStrings(String[] strings, Class&lt;?&gt; parameterTypeClass,
      LanguageDriver languageDriver) {
<span class="fc" id="L635">    return languageDriver.createSqlSource(configuration, String.join(&quot; &quot;, strings).trim(), parameterTypeClass);</span>
  }

  @SafeVarargs
  private final Optional&lt;AnnotationWrapper&gt; getAnnotationWrapper(Method method, boolean errorIfNoMatch,
      Class&lt;? extends Annotation&gt;... targetTypes) {
<span class="fc" id="L641">    return getAnnotationWrapper(method, errorIfNoMatch, Arrays.asList(targetTypes));</span>
  }

  private Optional&lt;AnnotationWrapper&gt; getAnnotationWrapper(Method method, boolean errorIfNoMatch,
      Collection&lt;Class&lt;? extends Annotation&gt;&gt; targetTypes) {
<span class="fc" id="L646">    String databaseId = configuration.getDatabaseId();</span>
<span class="fc" id="L647">    Map&lt;String, AnnotationWrapper&gt; statementAnnotations = targetTypes.stream()</span>
<span class="fc" id="L648">        .flatMap(x -&gt; Arrays.stream(method.getAnnotationsByType(x))).map(AnnotationWrapper::new)</span>
<span class="fc" id="L649">        .collect(Collectors.toMap(AnnotationWrapper::getDatabaseId, x -&gt; x, (existing, duplicate) -&gt; {</span>
<span class="fc" id="L650">          throw new BuilderException(String.format(&quot;Detected conflicting annotations '%s' and '%s' on '%s'.&quot;,</span>
<span class="fc" id="L651">              existing.getAnnotation(), duplicate.getAnnotation(),</span>
<span class="fc" id="L652">              method.getDeclaringClass().getName() + &quot;.&quot; + method.getName()));</span>
        }));
<span class="fc" id="L654">    AnnotationWrapper annotationWrapper = null;</span>
<span class="fc bfc" id="L655" title="All 2 branches covered.">    if (databaseId != null) {</span>
<span class="fc" id="L656">      annotationWrapper = statementAnnotations.get(databaseId);</span>
    }
<span class="fc bfc" id="L658" title="All 2 branches covered.">    if (annotationWrapper == null) {</span>
<span class="fc" id="L659">      annotationWrapper = statementAnnotations.get(&quot;&quot;);</span>
    }
<span class="fc bfc" id="L661" title="All 6 branches covered.">    if (errorIfNoMatch &amp;&amp; annotationWrapper == null &amp;&amp; !statementAnnotations.isEmpty()) {</span>
      // Annotations exist, but there is no matching one for the specified databaseId
<span class="fc" id="L663">      throw new BuilderException(</span>
<span class="fc" id="L664">          String.format(</span>
              &quot;Could not find a statement annotation that correspond a current database or default statement on method '%s.%s'. Current database id is [%s].&quot;,
<span class="fc" id="L666">              method.getDeclaringClass().getName(), method.getName(), databaseId));</span>
    }
<span class="fc" id="L668">    return Optional.ofNullable(annotationWrapper);</span>
  }

  private class AnnotationWrapper {
    private final Annotation annotation;
    private final String databaseId;
    private final SqlCommandType sqlCommandType;

<span class="fc" id="L676">    AnnotationWrapper(Annotation annotation) {</span>
<span class="fc" id="L677">      super();</span>
<span class="fc" id="L678">      this.annotation = annotation;</span>
<span class="fc bfc" id="L679" title="All 2 branches covered.">      if (annotation instanceof Select) {</span>
<span class="fc" id="L680">        databaseId = ((Select) annotation).databaseId();</span>
<span class="fc" id="L681">        sqlCommandType = SqlCommandType.SELECT;</span>
<span class="fc bfc" id="L682" title="All 2 branches covered.">      } else if (annotation instanceof Update) {</span>
<span class="fc" id="L683">        databaseId = ((Update) annotation).databaseId();</span>
<span class="fc" id="L684">        sqlCommandType = SqlCommandType.UPDATE;</span>
<span class="fc bfc" id="L685" title="All 2 branches covered.">      } else if (annotation instanceof Insert) {</span>
<span class="fc" id="L686">        databaseId = ((Insert) annotation).databaseId();</span>
<span class="fc" id="L687">        sqlCommandType = SqlCommandType.INSERT;</span>
<span class="fc bfc" id="L688" title="All 2 branches covered.">      } else if (annotation instanceof Delete) {</span>
<span class="fc" id="L689">        databaseId = ((Delete) annotation).databaseId();</span>
<span class="fc" id="L690">        sqlCommandType = SqlCommandType.DELETE;</span>
<span class="fc bfc" id="L691" title="All 2 branches covered.">      } else if (annotation instanceof SelectProvider) {</span>
<span class="fc" id="L692">        databaseId = ((SelectProvider) annotation).databaseId();</span>
<span class="fc" id="L693">        sqlCommandType = SqlCommandType.SELECT;</span>
<span class="fc bfc" id="L694" title="All 2 branches covered.">      } else if (annotation instanceof UpdateProvider) {</span>
<span class="fc" id="L695">        databaseId = ((UpdateProvider) annotation).databaseId();</span>
<span class="fc" id="L696">        sqlCommandType = SqlCommandType.UPDATE;</span>
<span class="fc bfc" id="L697" title="All 2 branches covered.">      } else if (annotation instanceof InsertProvider) {</span>
<span class="fc" id="L698">        databaseId = ((InsertProvider) annotation).databaseId();</span>
<span class="fc" id="L699">        sqlCommandType = SqlCommandType.INSERT;</span>
<span class="fc bfc" id="L700" title="All 2 branches covered.">      } else if (annotation instanceof DeleteProvider) {</span>
<span class="fc" id="L701">        databaseId = ((DeleteProvider) annotation).databaseId();</span>
<span class="fc" id="L702">        sqlCommandType = SqlCommandType.DELETE;</span>
      } else {
<span class="fc" id="L704">        sqlCommandType = SqlCommandType.UNKNOWN;</span>
<span class="fc bfc" id="L705" title="All 2 branches covered.">        if (annotation instanceof Options) {</span>
<span class="fc" id="L706">          databaseId = ((Options) annotation).databaseId();</span>
<span class="pc bpc" id="L707" title="1 of 2 branches missed.">        } else if (annotation instanceof SelectKey) {</span>
<span class="fc" id="L708">          databaseId = ((SelectKey) annotation).databaseId();</span>
        } else {
<span class="nc" id="L710">          databaseId = &quot;&quot;;</span>
        }
      }
<span class="fc" id="L713">    }</span>

    Annotation getAnnotation() {
<span class="fc" id="L716">      return annotation;</span>
    }

    SqlCommandType getSqlCommandType() {
<span class="fc" id="L720">      return sqlCommandType;</span>
    }

    String getDatabaseId() {
<span class="fc" id="L724">      return databaseId;</span>
    }
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.7.202105040129</span></div></body></html>