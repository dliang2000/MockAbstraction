<!--

       Copyright ${license.git.copyrightYears} the original author or authors.

       Licensed under the Apache License, Version 2.0 (the "License");
       you may not use this file except in compliance with the License.
       You may obtain a copy of the License at

          http://www.apache.org/licenses/LICENSE-2.0

       Unless required by applicable law or agreed to in writing, software
       distributed under the License is distributed on an "AS IS" BASIS,
       WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       See the License for the specific language governing permissions and
       limitations under the License.

-->
<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>DefaultResultSetHandler.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">mybatis</a> &gt; <a href="index.source.html" class="el_package">org.apache.ibatis.executor.resultset</a> &gt; <span class="el_source">DefaultResultSetHandler.java</span></div><h1>DefaultResultSetHandler.java</h1><pre class="source lang-java linenums">/**
 *    Copyright 2009-2021 the original author or authors.
 *
 *    Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 *    you may not use this file except in compliance with the License.
 *    You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *    Unless required by applicable law or agreed to in writing, software
 *    distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *    See the License for the specific language governing permissions and
 *    limitations under the License.
 */
package org.apache.ibatis.executor.resultset;

import java.lang.reflect.Constructor;
import java.sql.CallableStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Locale;
import java.util.Map;
import java.util.Set;

import org.apache.ibatis.annotations.AutomapConstructor;
import org.apache.ibatis.binding.MapperMethod.ParamMap;
import org.apache.ibatis.cache.CacheKey;
import org.apache.ibatis.cursor.Cursor;
import org.apache.ibatis.cursor.defaults.DefaultCursor;
import org.apache.ibatis.executor.ErrorContext;
import org.apache.ibatis.executor.Executor;
import org.apache.ibatis.executor.ExecutorException;
import org.apache.ibatis.executor.loader.ResultLoader;
import org.apache.ibatis.executor.loader.ResultLoaderMap;
import org.apache.ibatis.executor.parameter.ParameterHandler;
import org.apache.ibatis.executor.result.DefaultResultContext;
import org.apache.ibatis.executor.result.DefaultResultHandler;
import org.apache.ibatis.executor.result.ResultMapException;
import org.apache.ibatis.mapping.BoundSql;
import org.apache.ibatis.mapping.Discriminator;
import org.apache.ibatis.mapping.MappedStatement;
import org.apache.ibatis.mapping.ParameterMapping;
import org.apache.ibatis.mapping.ParameterMode;
import org.apache.ibatis.mapping.ResultMap;
import org.apache.ibatis.mapping.ResultMapping;
import org.apache.ibatis.reflection.MetaClass;
import org.apache.ibatis.reflection.MetaObject;
import org.apache.ibatis.reflection.ReflectorFactory;
import org.apache.ibatis.reflection.factory.ObjectFactory;
import org.apache.ibatis.session.AutoMappingBehavior;
import org.apache.ibatis.session.Configuration;
import org.apache.ibatis.session.ResultContext;
import org.apache.ibatis.session.ResultHandler;
import org.apache.ibatis.session.RowBounds;
import org.apache.ibatis.type.JdbcType;
import org.apache.ibatis.type.TypeHandler;
import org.apache.ibatis.type.TypeHandlerRegistry;

/**
 * @author Clinton Begin
 * @author Eduardo Macarron
 * @author Iwao AVE!
 * @author Kazuki Shimizu
 */
public class DefaultResultSetHandler implements ResultSetHandler {

<span class="fc" id="L73">  private static final Object DEFERRED = new Object();</span>

  private final Executor executor;
  private final Configuration configuration;
  private final MappedStatement mappedStatement;
  private final RowBounds rowBounds;
  private final ParameterHandler parameterHandler;
  private final ResultHandler&lt;?&gt; resultHandler;
  private final BoundSql boundSql;
  private final TypeHandlerRegistry typeHandlerRegistry;
  private final ObjectFactory objectFactory;
  private final ReflectorFactory reflectorFactory;

  // nested resultmaps
<span class="fc" id="L87">  private final Map&lt;CacheKey, Object&gt; nestedResultObjects = new HashMap&lt;&gt;();</span>
<span class="fc" id="L88">  private final Map&lt;String, Object&gt; ancestorObjects = new HashMap&lt;&gt;();</span>
  private Object previousRowValue;

  // multiple resultsets
<span class="fc" id="L92">  private final Map&lt;String, ResultMapping&gt; nextResultMaps = new HashMap&lt;&gt;();</span>
<span class="fc" id="L93">  private final Map&lt;CacheKey, List&lt;PendingRelation&gt;&gt; pendingRelations = new HashMap&lt;&gt;();</span>

  // Cached Automappings
<span class="fc" id="L96">  private final Map&lt;String, List&lt;UnMappedColumnAutoMapping&gt;&gt; autoMappingsCache = new HashMap&lt;&gt;();</span>

  // temporary marking flag that indicate using constructor mapping (use field to reduce memory usage)
  private boolean useConstructorMappings;

  private static class PendingRelation {
    public MetaObject metaObject;
    public ResultMapping propertyMapping;
  }

  private static class UnMappedColumnAutoMapping {
    private final String column;
    private final String property;
    private final TypeHandler&lt;?&gt; typeHandler;
    private final boolean primitive;

<span class="fc" id="L112">    public UnMappedColumnAutoMapping(String column, String property, TypeHandler&lt;?&gt; typeHandler, boolean primitive) {</span>
<span class="fc" id="L113">      this.column = column;</span>
<span class="fc" id="L114">      this.property = property;</span>
<span class="fc" id="L115">      this.typeHandler = typeHandler;</span>
<span class="fc" id="L116">      this.primitive = primitive;</span>
<span class="fc" id="L117">    }</span>
  }

  public DefaultResultSetHandler(Executor executor, MappedStatement mappedStatement, ParameterHandler parameterHandler, ResultHandler&lt;?&gt; resultHandler, BoundSql boundSql,
<span class="fc" id="L121">                                 RowBounds rowBounds) {</span>
<span class="fc" id="L122">    this.executor = executor;</span>
<span class="fc" id="L123">    this.configuration = mappedStatement.getConfiguration();</span>
<span class="fc" id="L124">    this.mappedStatement = mappedStatement;</span>
<span class="fc" id="L125">    this.rowBounds = rowBounds;</span>
<span class="fc" id="L126">    this.parameterHandler = parameterHandler;</span>
<span class="fc" id="L127">    this.boundSql = boundSql;</span>
<span class="fc" id="L128">    this.typeHandlerRegistry = configuration.getTypeHandlerRegistry();</span>
<span class="fc" id="L129">    this.objectFactory = configuration.getObjectFactory();</span>
<span class="fc" id="L130">    this.reflectorFactory = configuration.getReflectorFactory();</span>
<span class="fc" id="L131">    this.resultHandler = resultHandler;</span>
<span class="fc" id="L132">  }</span>

  //
  // HANDLE OUTPUT PARAMETER
  //

  @Override
  public void handleOutputParameters(CallableStatement cs) throws SQLException {
<span class="fc" id="L140">    final Object parameterObject = parameterHandler.getParameterObject();</span>
<span class="fc" id="L141">    final MetaObject metaParam = configuration.newMetaObject(parameterObject);</span>
<span class="fc" id="L142">    final List&lt;ParameterMapping&gt; parameterMappings = boundSql.getParameterMappings();</span>
<span class="fc bfc" id="L143" title="All 2 branches covered.">    for (int i = 0; i &lt; parameterMappings.size(); i++) {</span>
<span class="fc" id="L144">      final ParameterMapping parameterMapping = parameterMappings.get(i);</span>
<span class="pc bpc" id="L145" title="1 of 4 branches missed.">      if (parameterMapping.getMode() == ParameterMode.OUT || parameterMapping.getMode() == ParameterMode.INOUT) {</span>
<span class="pc bpc" id="L146" title="1 of 2 branches missed.">        if (ResultSet.class.equals(parameterMapping.getJavaType())) {</span>
<span class="nc" id="L147">          handleRefCursorOutputParameter((ResultSet) cs.getObject(i + 1), parameterMapping, metaParam);</span>
        } else {
<span class="fc" id="L149">          final TypeHandler&lt;?&gt; typeHandler = parameterMapping.getTypeHandler();</span>
<span class="fc" id="L150">          metaParam.setValue(parameterMapping.getProperty(), typeHandler.getResult(cs, i + 1));</span>
        }
      }
    }
<span class="fc" id="L154">  }</span>

  private void handleRefCursorOutputParameter(ResultSet rs, ParameterMapping parameterMapping, MetaObject metaParam) throws SQLException {
<span class="nc bnc" id="L157" title="All 2 branches missed.">    if (rs == null) {</span>
<span class="nc" id="L158">      return;</span>
    }
    try {
<span class="nc" id="L161">      final String resultMapId = parameterMapping.getResultMapId();</span>
<span class="nc" id="L162">      final ResultMap resultMap = configuration.getResultMap(resultMapId);</span>
<span class="nc" id="L163">      final ResultSetWrapper rsw = new ResultSetWrapper(rs, configuration);</span>
<span class="nc bnc" id="L164" title="All 2 branches missed.">      if (this.resultHandler == null) {</span>
<span class="nc" id="L165">        final DefaultResultHandler resultHandler = new DefaultResultHandler(objectFactory);</span>
<span class="nc" id="L166">        handleRowValues(rsw, resultMap, resultHandler, new RowBounds(), null);</span>
<span class="nc" id="L167">        metaParam.setValue(parameterMapping.getProperty(), resultHandler.getResultList());</span>
<span class="nc" id="L168">      } else {</span>
<span class="nc" id="L169">        handleRowValues(rsw, resultMap, resultHandler, new RowBounds(), null);</span>
      }
    } finally {
      // issue #228 (close resultsets)
<span class="nc" id="L173">      closeResultSet(rs);</span>
    }
<span class="nc" id="L175">  }</span>

  //
  // HANDLE RESULT SETS
  //
  @Override
  public List&lt;Object&gt; handleResultSets(Statement stmt) throws SQLException {
<span class="fc" id="L182">    ErrorContext.instance().activity(&quot;handling results&quot;).object(mappedStatement.getId());</span>

<span class="fc" id="L184">    final List&lt;Object&gt; multipleResults = new ArrayList&lt;&gt;();</span>

<span class="fc" id="L186">    int resultSetCount = 0;</span>
<span class="fc" id="L187">    ResultSetWrapper rsw = getFirstResultSet(stmt);</span>

<span class="fc" id="L189">    List&lt;ResultMap&gt; resultMaps = mappedStatement.getResultMaps();</span>
<span class="fc" id="L190">    int resultMapCount = resultMaps.size();</span>
<span class="fc" id="L191">    validateResultMapsCount(rsw, resultMapCount);</span>
<span class="fc bfc" id="L192" title="All 4 branches covered.">    while (rsw != null &amp;&amp; resultMapCount &gt; resultSetCount) {</span>
<span class="fc" id="L193">      ResultMap resultMap = resultMaps.get(resultSetCount);</span>
<span class="fc" id="L194">      handleResultSet(rsw, resultMap, multipleResults, null);</span>
<span class="fc" id="L195">      rsw = getNextResultSet(stmt);</span>
<span class="fc" id="L196">      cleanUpAfterHandlingResultSet();</span>
<span class="fc" id="L197">      resultSetCount++;</span>
<span class="fc" id="L198">    }</span>

<span class="fc" id="L200">    String[] resultSets = mappedStatement.getResultSets();</span>
<span class="fc bfc" id="L201" title="All 2 branches covered.">    if (resultSets != null) {</span>
<span class="pc bpc" id="L202" title="1 of 4 branches missed.">      while (rsw != null &amp;&amp; resultSetCount &lt; resultSets.length) {</span>
<span class="fc" id="L203">        ResultMapping parentMapping = nextResultMaps.get(resultSets[resultSetCount]);</span>
<span class="pc bpc" id="L204" title="1 of 2 branches missed.">        if (parentMapping != null) {</span>
<span class="fc" id="L205">          String nestedResultMapId = parentMapping.getNestedResultMapId();</span>
<span class="fc" id="L206">          ResultMap resultMap = configuration.getResultMap(nestedResultMapId);</span>
<span class="fc" id="L207">          handleResultSet(rsw, resultMap, null, parentMapping);</span>
        }
<span class="fc" id="L209">        rsw = getNextResultSet(stmt);</span>
<span class="fc" id="L210">        cleanUpAfterHandlingResultSet();</span>
<span class="fc" id="L211">        resultSetCount++;</span>
<span class="fc" id="L212">      }</span>
    }

<span class="fc" id="L215">    return collapseSingleResultList(multipleResults);</span>
  }

  @Override
  public &lt;E&gt; Cursor&lt;E&gt; handleCursorResultSets(Statement stmt) throws SQLException {
<span class="fc" id="L220">    ErrorContext.instance().activity(&quot;handling cursor results&quot;).object(mappedStatement.getId());</span>

<span class="fc" id="L222">    ResultSetWrapper rsw = getFirstResultSet(stmt);</span>

<span class="fc" id="L224">    List&lt;ResultMap&gt; resultMaps = mappedStatement.getResultMaps();</span>

<span class="fc" id="L226">    int resultMapCount = resultMaps.size();</span>
<span class="fc" id="L227">    validateResultMapsCount(rsw, resultMapCount);</span>
<span class="pc bpc" id="L228" title="1 of 2 branches missed.">    if (resultMapCount != 1) {</span>
<span class="nc" id="L229">      throw new ExecutorException(&quot;Cursor results cannot be mapped to multiple resultMaps&quot;);</span>
    }

<span class="fc" id="L232">    ResultMap resultMap = resultMaps.get(0);</span>
<span class="fc" id="L233">    return new DefaultCursor&lt;&gt;(this, resultMap, rsw, rowBounds);</span>
  }

  private ResultSetWrapper getFirstResultSet(Statement stmt) throws SQLException {
<span class="fc" id="L237">    ResultSet rs = stmt.getResultSet();</span>
<span class="fc bfc" id="L238" title="All 2 branches covered.">    while (rs == null) {</span>
      // move forward to get the first resultset in case the driver
      // doesn't return the resultset as the first result (HSQLDB 2.1)
<span class="pc bpc" id="L241" title="1 of 2 branches missed.">      if (stmt.getMoreResults()) {</span>
<span class="nc" id="L242">        rs = stmt.getResultSet();</span>
      } else {
<span class="pc bpc" id="L244" title="1 of 2 branches missed.">        if (stmt.getUpdateCount() == -1) {</span>
          // no more results. Must be no resultset
<span class="fc" id="L246">          break;</span>
        }
      }
    }
<span class="fc bfc" id="L250" title="All 2 branches covered.">    return rs != null ? new ResultSetWrapper(rs, configuration) : null;</span>
  }

  private ResultSetWrapper getNextResultSet(Statement stmt) {
    // Making this method tolerant of bad JDBC drivers
    try {
<span class="fc bfc" id="L256" title="All 2 branches covered.">      if (stmt.getConnection().getMetaData().supportsMultipleResultSets()) {</span>
        // Crazy Standard JDBC way of determining if there are more results
<span class="pc bpc" id="L258" title="1 of 4 branches missed.">        if (!(!stmt.getMoreResults() &amp;&amp; stmt.getUpdateCount() == -1)) {</span>
<span class="fc" id="L259">          ResultSet rs = stmt.getResultSet();</span>
<span class="pc bpc" id="L260" title="1 of 2 branches missed.">          if (rs == null) {</span>
<span class="nc" id="L261">            return getNextResultSet(stmt);</span>
          } else {
<span class="fc" id="L263">            return new ResultSetWrapper(rs, configuration);</span>
          }
        }
      }
<span class="nc" id="L267">    } catch (Exception e) {</span>
      // Intentionally ignored.
<span class="fc" id="L269">    }</span>
<span class="fc" id="L270">    return null;</span>
  }

  private void closeResultSet(ResultSet rs) {
    try {
<span class="pc bpc" id="L275" title="1 of 2 branches missed.">      if (rs != null) {</span>
<span class="fc" id="L276">        rs.close();</span>
      }
<span class="nc" id="L278">    } catch (SQLException e) {</span>
      // ignore
<span class="fc" id="L280">    }</span>
<span class="fc" id="L281">  }</span>

  private void cleanUpAfterHandlingResultSet() {
<span class="fc" id="L284">    nestedResultObjects.clear();</span>
<span class="fc" id="L285">  }</span>

  private void validateResultMapsCount(ResultSetWrapper rsw, int resultMapCount) {
<span class="pc bpc" id="L288" title="1 of 4 branches missed.">    if (rsw != null &amp;&amp; resultMapCount &lt; 1) {</span>
<span class="nc" id="L289">      throw new ExecutorException(&quot;A query was run and no Result Maps were found for the Mapped Statement '&quot; + mappedStatement.getId()</span>
          + &quot;'.  It's likely that neither a Result Type nor a Result Map was specified.&quot;);
    }
<span class="fc" id="L292">  }</span>

  private void handleResultSet(ResultSetWrapper rsw, ResultMap resultMap, List&lt;Object&gt; multipleResults, ResultMapping parentMapping) throws SQLException {
    try {
<span class="fc bfc" id="L296" title="All 2 branches covered.">      if (parentMapping != null) {</span>
<span class="fc" id="L297">        handleRowValues(rsw, resultMap, null, RowBounds.DEFAULT, parentMapping);</span>
      } else {
<span class="fc bfc" id="L299" title="All 2 branches covered.">        if (resultHandler == null) {</span>
<span class="fc" id="L300">          DefaultResultHandler defaultResultHandler = new DefaultResultHandler(objectFactory);</span>
<span class="fc" id="L301">          handleRowValues(rsw, resultMap, defaultResultHandler, rowBounds, null);</span>
<span class="fc" id="L302">          multipleResults.add(defaultResultHandler.getResultList());</span>
<span class="fc" id="L303">        } else {</span>
<span class="fc" id="L304">          handleRowValues(rsw, resultMap, resultHandler, rowBounds, null);</span>
        }
      }
    } finally {
      // issue #228 (close resultsets)
<span class="fc" id="L309">      closeResultSet(rsw.getResultSet());</span>
    }
<span class="fc" id="L311">  }</span>

  @SuppressWarnings(&quot;unchecked&quot;)
  private List&lt;Object&gt; collapseSingleResultList(List&lt;Object&gt; multipleResults) {
<span class="fc bfc" id="L315" title="All 2 branches covered.">    return multipleResults.size() == 1 ? (List&lt;Object&gt;) multipleResults.get(0) : multipleResults;</span>
  }

  //
  // HANDLE ROWS FOR SIMPLE RESULTMAP
  //

  public void handleRowValues(ResultSetWrapper rsw, ResultMap resultMap, ResultHandler&lt;?&gt; resultHandler, RowBounds rowBounds, ResultMapping parentMapping) throws SQLException {
<span class="fc bfc" id="L323" title="All 2 branches covered.">    if (resultMap.hasNestedResultMaps()) {</span>
<span class="fc" id="L324">      ensureNoRowBounds();</span>
<span class="fc" id="L325">      checkResultHandler();</span>
<span class="fc" id="L326">      handleRowValuesForNestedResultMap(rsw, resultMap, resultHandler, rowBounds, parentMapping);</span>
    } else {
<span class="fc" id="L328">      handleRowValuesForSimpleResultMap(rsw, resultMap, resultHandler, rowBounds, parentMapping);</span>
    }
<span class="fc" id="L330">  }</span>

  private void ensureNoRowBounds() {
<span class="pc bpc" id="L333" title="7 of 8 branches missed.">    if (configuration.isSafeRowBoundsEnabled() &amp;&amp; rowBounds != null &amp;&amp; (rowBounds.getLimit() &lt; RowBounds.NO_ROW_LIMIT || rowBounds.getOffset() &gt; RowBounds.NO_ROW_OFFSET)) {</span>
<span class="nc" id="L334">      throw new ExecutorException(&quot;Mapped Statements with nested result mappings cannot be safely constrained by RowBounds. &quot;</span>
          + &quot;Use safeRowBoundsEnabled=false setting to bypass this check.&quot;);
    }
<span class="fc" id="L337">  }</span>

  protected void checkResultHandler() {
<span class="pc bpc" id="L340" title="1 of 6 branches missed.">    if (resultHandler != null &amp;&amp; configuration.isSafeResultHandlerEnabled() &amp;&amp; !mappedStatement.isResultOrdered()) {</span>
<span class="fc" id="L341">      throw new ExecutorException(&quot;Mapped Statements with nested result mappings cannot be safely used with a custom ResultHandler. &quot;</span>
          + &quot;Use safeResultHandlerEnabled=false setting to bypass this check &quot;
          + &quot;or ensure your statement returns ordered data and set resultOrdered=true on it.&quot;);
    }
<span class="fc" id="L345">  }</span>

  private void handleRowValuesForSimpleResultMap(ResultSetWrapper rsw, ResultMap resultMap, ResultHandler&lt;?&gt; resultHandler, RowBounds rowBounds, ResultMapping parentMapping)
      throws SQLException {
<span class="fc" id="L349">    DefaultResultContext&lt;Object&gt; resultContext = new DefaultResultContext&lt;&gt;();</span>
<span class="fc" id="L350">    ResultSet resultSet = rsw.getResultSet();</span>
<span class="fc" id="L351">    skipRows(resultSet, rowBounds);</span>
<span class="pc bpc" id="L352" title="1 of 6 branches missed.">    while (shouldProcessMoreRows(resultContext, rowBounds) &amp;&amp; !resultSet.isClosed() &amp;&amp; resultSet.next()) {</span>
<span class="fc" id="L353">      ResultMap discriminatedResultMap = resolveDiscriminatedResultMap(resultSet, resultMap, null);</span>
<span class="fc" id="L354">      Object rowValue = getRowValue(rsw, discriminatedResultMap, null);</span>
<span class="fc" id="L355">      storeObject(resultHandler, resultContext, rowValue, parentMapping, resultSet);</span>
<span class="fc" id="L356">    }</span>
<span class="fc" id="L357">  }</span>

  private void storeObject(ResultHandler&lt;?&gt; resultHandler, DefaultResultContext&lt;Object&gt; resultContext, Object rowValue, ResultMapping parentMapping, ResultSet rs) throws SQLException {
<span class="fc bfc" id="L360" title="All 2 branches covered.">    if (parentMapping != null) {</span>
<span class="fc" id="L361">      linkToParents(rs, parentMapping, rowValue);</span>
    } else {
<span class="fc" id="L363">      callResultHandler(resultHandler, resultContext, rowValue);</span>
    }
<span class="fc" id="L365">  }</span>

  @SuppressWarnings(&quot;unchecked&quot; /* because ResultHandler&lt;?&gt; is always ResultHandler&lt;Object&gt;*/)
  private void callResultHandler(ResultHandler&lt;?&gt; resultHandler, DefaultResultContext&lt;Object&gt; resultContext, Object rowValue) {
<span class="fc" id="L369">    resultContext.nextResultObject(rowValue);</span>
<span class="fc" id="L370">    ((ResultHandler&lt;Object&gt;) resultHandler).handleResult(resultContext);</span>
<span class="fc" id="L371">  }</span>

  private boolean shouldProcessMoreRows(ResultContext&lt;?&gt; context, RowBounds rowBounds) {
<span class="fc bfc" id="L374" title="All 4 branches covered.">    return !context.isStopped() &amp;&amp; context.getResultCount() &lt; rowBounds.getLimit();</span>
  }

  private void skipRows(ResultSet rs, RowBounds rowBounds) throws SQLException {
<span class="fc bfc" id="L378" title="All 2 branches covered.">    if (rs.getType() != ResultSet.TYPE_FORWARD_ONLY) {</span>
<span class="pc bpc" id="L379" title="1 of 2 branches missed.">      if (rowBounds.getOffset() != RowBounds.NO_ROW_OFFSET) {</span>
<span class="fc" id="L380">        rs.absolute(rowBounds.getOffset());</span>
      }
    } else {
<span class="fc bfc" id="L383" title="All 2 branches covered.">      for (int i = 0; i &lt; rowBounds.getOffset(); i++) {</span>
<span class="pc bpc" id="L384" title="1 of 2 branches missed.">        if (!rs.next()) {</span>
<span class="nc" id="L385">          break;</span>
        }
      }
    }
<span class="fc" id="L389">  }</span>

  //
  // GET VALUE FROM ROW FOR SIMPLE RESULT MAP
  //

  private Object getRowValue(ResultSetWrapper rsw, ResultMap resultMap, String columnPrefix) throws SQLException {
<span class="fc" id="L396">    final ResultLoaderMap lazyLoader = new ResultLoaderMap();</span>
<span class="fc" id="L397">    Object rowValue = createResultObject(rsw, resultMap, lazyLoader, columnPrefix);</span>
<span class="fc bfc" id="L398" title="All 4 branches covered.">    if (rowValue != null &amp;&amp; !hasTypeHandlerForResultObject(rsw, resultMap.getType())) {</span>
<span class="fc" id="L399">      final MetaObject metaObject = configuration.newMetaObject(rowValue);</span>
<span class="fc" id="L400">      boolean foundValues = this.useConstructorMappings;</span>
<span class="fc bfc" id="L401" title="All 2 branches covered.">      if (shouldApplyAutomaticMappings(resultMap, false)) {</span>
<span class="fc bfc" id="L402" title="All 4 branches covered.">        foundValues = applyAutomaticMappings(rsw, resultMap, metaObject, columnPrefix) || foundValues;</span>
      }
<span class="fc bfc" id="L404" title="All 4 branches covered.">      foundValues = applyPropertyMappings(rsw, resultMap, metaObject, lazyLoader, columnPrefix) || foundValues;</span>
<span class="fc bfc" id="L405" title="All 4 branches covered.">      foundValues = lazyLoader.size() &gt; 0 || foundValues;</span>
<span class="fc bfc" id="L406" title="All 4 branches covered.">      rowValue = foundValues || configuration.isReturnInstanceForEmptyRow() ? rowValue : null;</span>
    }
<span class="fc" id="L408">    return rowValue;</span>
  }

  //
  // GET VALUE FROM ROW FOR NESTED RESULT MAP
  //

  private Object getRowValue(ResultSetWrapper rsw, ResultMap resultMap, CacheKey combinedKey, String columnPrefix, Object partialObject) throws SQLException {
<span class="fc" id="L416">    final String resultMapId = resultMap.getId();</span>
<span class="fc" id="L417">    Object rowValue = partialObject;</span>
<span class="fc bfc" id="L418" title="All 2 branches covered.">    if (rowValue != null) {</span>
<span class="fc" id="L419">      final MetaObject metaObject = configuration.newMetaObject(rowValue);</span>
<span class="fc" id="L420">      putAncestor(rowValue, resultMapId);</span>
<span class="fc" id="L421">      applyNestedResultMappings(rsw, resultMap, metaObject, columnPrefix, combinedKey, false);</span>
<span class="fc" id="L422">      ancestorObjects.remove(resultMapId);</span>
<span class="fc" id="L423">    } else {</span>
<span class="fc" id="L424">      final ResultLoaderMap lazyLoader = new ResultLoaderMap();</span>
<span class="fc" id="L425">      rowValue = createResultObject(rsw, resultMap, lazyLoader, columnPrefix);</span>
<span class="fc bfc" id="L426" title="All 4 branches covered.">      if (rowValue != null &amp;&amp; !hasTypeHandlerForResultObject(rsw, resultMap.getType())) {</span>
<span class="fc" id="L427">        final MetaObject metaObject = configuration.newMetaObject(rowValue);</span>
<span class="fc" id="L428">        boolean foundValues = this.useConstructorMappings;</span>
<span class="fc bfc" id="L429" title="All 2 branches covered.">        if (shouldApplyAutomaticMappings(resultMap, true)) {</span>
<span class="pc bpc" id="L430" title="1 of 4 branches missed.">          foundValues = applyAutomaticMappings(rsw, resultMap, metaObject, columnPrefix) || foundValues;</span>
        }
<span class="fc bfc" id="L432" title="All 4 branches covered.">        foundValues = applyPropertyMappings(rsw, resultMap, metaObject, lazyLoader, columnPrefix) || foundValues;</span>
<span class="fc" id="L433">        putAncestor(rowValue, resultMapId);</span>
<span class="fc bfc" id="L434" title="All 4 branches covered.">        foundValues = applyNestedResultMappings(rsw, resultMap, metaObject, columnPrefix, combinedKey, true) || foundValues;</span>
<span class="fc" id="L435">        ancestorObjects.remove(resultMapId);</span>
<span class="fc bfc" id="L436" title="All 4 branches covered.">        foundValues = lazyLoader.size() &gt; 0 || foundValues;</span>
<span class="fc bfc" id="L437" title="All 4 branches covered.">        rowValue = foundValues || configuration.isReturnInstanceForEmptyRow() ? rowValue : null;</span>
      }
<span class="fc bfc" id="L439" title="All 2 branches covered.">      if (combinedKey != CacheKey.NULL_CACHE_KEY) {</span>
<span class="fc" id="L440">        nestedResultObjects.put(combinedKey, rowValue);</span>
      }
    }
<span class="fc" id="L443">    return rowValue;</span>
  }

  private void putAncestor(Object resultObject, String resultMapId) {
<span class="fc" id="L447">    ancestorObjects.put(resultMapId, resultObject);</span>
<span class="fc" id="L448">  }</span>

  private boolean shouldApplyAutomaticMappings(ResultMap resultMap, boolean isNested) {
<span class="fc bfc" id="L451" title="All 2 branches covered.">    if (resultMap.getAutoMapping() != null) {</span>
<span class="fc" id="L452">      return resultMap.getAutoMapping();</span>
    } else {
<span class="fc bfc" id="L454" title="All 2 branches covered.">      if (isNested) {</span>
<span class="fc bfc" id="L455" title="All 2 branches covered.">        return AutoMappingBehavior.FULL == configuration.getAutoMappingBehavior();</span>
      } else {
<span class="fc bfc" id="L457" title="All 2 branches covered.">        return AutoMappingBehavior.NONE != configuration.getAutoMappingBehavior();</span>
      }
    }
  }

  //
  // PROPERTY MAPPINGS
  //

  private boolean applyPropertyMappings(ResultSetWrapper rsw, ResultMap resultMap, MetaObject metaObject, ResultLoaderMap lazyLoader, String columnPrefix)
      throws SQLException {
<span class="fc" id="L468">    final List&lt;String&gt; mappedColumnNames = rsw.getMappedColumnNames(resultMap, columnPrefix);</span>
<span class="fc" id="L469">    boolean foundValues = false;</span>
<span class="fc" id="L470">    final List&lt;ResultMapping&gt; propertyMappings = resultMap.getPropertyResultMappings();</span>
<span class="fc bfc" id="L471" title="All 2 branches covered.">    for (ResultMapping propertyMapping : propertyMappings) {</span>
<span class="fc" id="L472">      String column = prependPrefix(propertyMapping.getColumn(), columnPrefix);</span>
<span class="fc bfc" id="L473" title="All 2 branches covered.">      if (propertyMapping.getNestedResultMapId() != null) {</span>
        // the user added a column attribute to a nested result map, ignore it
<span class="fc" id="L475">        column = null;</span>
      }
<span class="fc bfc" id="L477" title="All 4 branches covered.">      if (propertyMapping.isCompositeResult()</span>
<span class="fc bfc" id="L478" title="All 2 branches covered.">          || (column != null &amp;&amp; mappedColumnNames.contains(column.toUpperCase(Locale.ENGLISH)))</span>
<span class="fc bfc" id="L479" title="All 2 branches covered.">          || propertyMapping.getResultSet() != null) {</span>
<span class="fc" id="L480">        Object value = getPropertyMappingValue(rsw.getResultSet(), metaObject, propertyMapping, lazyLoader, columnPrefix);</span>
        // issue #541 make property optional
<span class="fc" id="L482">        final String property = propertyMapping.getProperty();</span>
<span class="fc bfc" id="L483" title="All 2 branches covered.">        if (property == null) {</span>
<span class="fc" id="L484">          continue;</span>
<span class="fc bfc" id="L485" title="All 2 branches covered.">        } else if (value == DEFERRED) {</span>
<span class="fc" id="L486">          foundValues = true;</span>
<span class="fc" id="L487">          continue;</span>
        }
<span class="fc bfc" id="L489" title="All 2 branches covered.">        if (value != null) {</span>
<span class="fc" id="L490">          foundValues = true;</span>
        }
<span class="pc bpc" id="L492" title="1 of 6 branches missed.">        if (value != null || (configuration.isCallSettersOnNulls() &amp;&amp; !metaObject.getSetterType(property).isPrimitive())) {</span>
          // gcode issue #377, call setter on nulls (value is not 'found')
<span class="fc" id="L494">          metaObject.setValue(property, value);</span>
        }
      }
<span class="fc" id="L497">    }</span>
<span class="fc" id="L498">    return foundValues;</span>
  }

  private Object getPropertyMappingValue(ResultSet rs, MetaObject metaResultObject, ResultMapping propertyMapping, ResultLoaderMap lazyLoader, String columnPrefix)
      throws SQLException {
<span class="fc bfc" id="L503" title="All 2 branches covered.">    if (propertyMapping.getNestedQueryId() != null) {</span>
<span class="fc" id="L504">      return getNestedQueryMappingValue(rs, metaResultObject, propertyMapping, lazyLoader, columnPrefix);</span>
<span class="fc bfc" id="L505" title="All 2 branches covered.">    } else if (propertyMapping.getResultSet() != null) {</span>
<span class="fc" id="L506">      addPendingChildRelation(rs, metaResultObject, propertyMapping);   // TODO is that OK?</span>
<span class="fc" id="L507">      return DEFERRED;</span>
    } else {
<span class="fc" id="L509">      final TypeHandler&lt;?&gt; typeHandler = propertyMapping.getTypeHandler();</span>
<span class="fc" id="L510">      final String column = prependPrefix(propertyMapping.getColumn(), columnPrefix);</span>
<span class="fc" id="L511">      return typeHandler.getResult(rs, column);</span>
    }
  }

  private List&lt;UnMappedColumnAutoMapping&gt; createAutomaticMappings(ResultSetWrapper rsw, ResultMap resultMap, MetaObject metaObject, String columnPrefix) throws SQLException {
<span class="fc" id="L516">    final String mapKey = resultMap.getId() + &quot;:&quot; + columnPrefix;</span>
<span class="fc" id="L517">    List&lt;UnMappedColumnAutoMapping&gt; autoMapping = autoMappingsCache.get(mapKey);</span>
<span class="fc bfc" id="L518" title="All 2 branches covered.">    if (autoMapping == null) {</span>
<span class="fc" id="L519">      autoMapping = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L520">      final List&lt;String&gt; unmappedColumnNames = rsw.getUnmappedColumnNames(resultMap, columnPrefix);</span>
<span class="fc bfc" id="L521" title="All 2 branches covered.">      for (String columnName : unmappedColumnNames) {</span>
<span class="fc" id="L522">        String propertyName = columnName;</span>
<span class="pc bpc" id="L523" title="1 of 4 branches missed.">        if (columnPrefix != null &amp;&amp; !columnPrefix.isEmpty()) {</span>
          // When columnPrefix is specified,
          // ignore columns without the prefix.
<span class="fc bfc" id="L526" title="All 2 branches covered.">          if (columnName.toUpperCase(Locale.ENGLISH).startsWith(columnPrefix)) {</span>
<span class="fc" id="L527">            propertyName = columnName.substring(columnPrefix.length());</span>
          } else {
            continue;
          }
        }
<span class="fc" id="L532">        final String property = metaObject.findProperty(propertyName, configuration.isMapUnderscoreToCamelCase());</span>
<span class="fc bfc" id="L533" title="All 4 branches covered.">        if (property != null &amp;&amp; metaObject.hasSetter(property)) {</span>
<span class="fc bfc" id="L534" title="All 2 branches covered.">          if (resultMap.getMappedProperties().contains(property)) {</span>
<span class="fc" id="L535">            continue;</span>
          }
<span class="fc" id="L537">          final Class&lt;?&gt; propertyType = metaObject.getSetterType(property);</span>
<span class="fc bfc" id="L538" title="All 2 branches covered.">          if (typeHandlerRegistry.hasTypeHandler(propertyType, rsw.getJdbcType(columnName))) {</span>
<span class="fc" id="L539">            final TypeHandler&lt;?&gt; typeHandler = rsw.getTypeHandler(propertyType, columnName);</span>
<span class="fc" id="L540">            autoMapping.add(new UnMappedColumnAutoMapping(columnName, property, typeHandler, propertyType.isPrimitive()));</span>
<span class="fc" id="L541">          } else {</span>
<span class="fc" id="L542">            configuration.getAutoMappingUnknownColumnBehavior()</span>
<span class="fc" id="L543">                .doAction(mappedStatement, columnName, property, propertyType);</span>
          }
<span class="fc" id="L545">        } else {</span>
<span class="fc bfc" id="L546" title="All 2 branches covered.">          configuration.getAutoMappingUnknownColumnBehavior()</span>
<span class="fc" id="L547">              .doAction(mappedStatement, columnName, (property != null) ? property : propertyName, null);</span>
        }
<span class="fc" id="L549">      }</span>
<span class="fc" id="L550">      autoMappingsCache.put(mapKey, autoMapping);</span>
    }
<span class="fc" id="L552">    return autoMapping;</span>
  }

  private boolean applyAutomaticMappings(ResultSetWrapper rsw, ResultMap resultMap, MetaObject metaObject, String columnPrefix) throws SQLException {
<span class="fc" id="L556">    List&lt;UnMappedColumnAutoMapping&gt; autoMapping = createAutomaticMappings(rsw, resultMap, metaObject, columnPrefix);</span>
<span class="fc" id="L557">    boolean foundValues = false;</span>
<span class="fc bfc" id="L558" title="All 2 branches covered.">    if (!autoMapping.isEmpty()) {</span>
<span class="fc bfc" id="L559" title="All 2 branches covered.">      for (UnMappedColumnAutoMapping mapping : autoMapping) {</span>
<span class="fc" id="L560">        final Object value = mapping.typeHandler.getResult(rsw.getResultSet(), mapping.column);</span>
<span class="fc bfc" id="L561" title="All 2 branches covered.">        if (value != null) {</span>
<span class="fc" id="L562">          foundValues = true;</span>
        }
<span class="pc bpc" id="L564" title="1 of 6 branches missed.">        if (value != null || (configuration.isCallSettersOnNulls() &amp;&amp; !mapping.primitive)) {</span>
          // gcode issue #377, call setter on nulls (value is not 'found')
<span class="fc" id="L566">          metaObject.setValue(mapping.property, value);</span>
        }
<span class="fc" id="L568">      }</span>
    }
<span class="fc" id="L570">    return foundValues;</span>
  }

  // MULTIPLE RESULT SETS

  private void linkToParents(ResultSet rs, ResultMapping parentMapping, Object rowValue) throws SQLException {
<span class="fc" id="L576">    CacheKey parentKey = createKeyForMultipleResults(rs, parentMapping, parentMapping.getColumn(), parentMapping.getForeignColumn());</span>
<span class="fc" id="L577">    List&lt;PendingRelation&gt; parents = pendingRelations.get(parentKey);</span>
<span class="fc bfc" id="L578" title="All 2 branches covered.">    if (parents != null) {</span>
<span class="fc bfc" id="L579" title="All 2 branches covered.">      for (PendingRelation parent : parents) {</span>
<span class="pc bpc" id="L580" title="2 of 4 branches missed.">        if (parent != null &amp;&amp; rowValue != null) {</span>
<span class="fc" id="L581">          linkObjects(parent.metaObject, parent.propertyMapping, rowValue);</span>
        }
<span class="fc" id="L583">      }</span>
    }
<span class="fc" id="L585">  }</span>

  private void addPendingChildRelation(ResultSet rs, MetaObject metaResultObject, ResultMapping parentMapping) throws SQLException {
<span class="fc" id="L588">    CacheKey cacheKey = createKeyForMultipleResults(rs, parentMapping, parentMapping.getColumn(), parentMapping.getColumn());</span>
<span class="fc" id="L589">    PendingRelation deferLoad = new PendingRelation();</span>
<span class="fc" id="L590">    deferLoad.metaObject = metaResultObject;</span>
<span class="fc" id="L591">    deferLoad.propertyMapping = parentMapping;</span>
<span class="fc" id="L592">    List&lt;PendingRelation&gt; relations = pendingRelations.computeIfAbsent(cacheKey, k -&gt; new ArrayList&lt;&gt;());</span>
    // issue #255
<span class="fc" id="L594">    relations.add(deferLoad);</span>
<span class="fc" id="L595">    ResultMapping previous = nextResultMaps.get(parentMapping.getResultSet());</span>
<span class="fc bfc" id="L596" title="All 2 branches covered.">    if (previous == null) {</span>
<span class="fc" id="L597">      nextResultMaps.put(parentMapping.getResultSet(), parentMapping);</span>
    } else {
<span class="pc bpc" id="L599" title="1 of 2 branches missed.">      if (!previous.equals(parentMapping)) {</span>
<span class="nc" id="L600">        throw new ExecutorException(&quot;Two different properties are mapped to the same resultSet&quot;);</span>
      }
    }
<span class="fc" id="L603">  }</span>

  private CacheKey createKeyForMultipleResults(ResultSet rs, ResultMapping resultMapping, String names, String columns) throws SQLException {
<span class="fc" id="L606">    CacheKey cacheKey = new CacheKey();</span>
<span class="fc" id="L607">    cacheKey.update(resultMapping);</span>
<span class="pc bpc" id="L608" title="1 of 4 branches missed.">    if (columns != null &amp;&amp; names != null) {</span>
<span class="fc" id="L609">      String[] columnsArray = columns.split(&quot;,&quot;);</span>
<span class="fc" id="L610">      String[] namesArray = names.split(&quot;,&quot;);</span>
<span class="fc bfc" id="L611" title="All 2 branches covered.">      for (int i = 0; i &lt; columnsArray.length; i++) {</span>
<span class="fc" id="L612">        Object value = rs.getString(columnsArray[i]);</span>
<span class="pc bpc" id="L613" title="1 of 2 branches missed.">        if (value != null) {</span>
<span class="fc" id="L614">          cacheKey.update(namesArray[i]);</span>
<span class="fc" id="L615">          cacheKey.update(value);</span>
        }
      }
    }
<span class="fc" id="L619">    return cacheKey;</span>
  }

  //
  // INSTANTIATION &amp; CONSTRUCTOR MAPPING
  //

  private Object createResultObject(ResultSetWrapper rsw, ResultMap resultMap, ResultLoaderMap lazyLoader, String columnPrefix) throws SQLException {
<span class="fc" id="L627">    this.useConstructorMappings = false; // reset previous mapping result</span>
<span class="fc" id="L628">    final List&lt;Class&lt;?&gt;&gt; constructorArgTypes = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L629">    final List&lt;Object&gt; constructorArgs = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L630">    Object resultObject = createResultObject(rsw, resultMap, constructorArgTypes, constructorArgs, columnPrefix);</span>
<span class="fc bfc" id="L631" title="All 4 branches covered.">    if (resultObject != null &amp;&amp; !hasTypeHandlerForResultObject(rsw, resultMap.getType())) {</span>
<span class="fc" id="L632">      final List&lt;ResultMapping&gt; propertyMappings = resultMap.getPropertyResultMappings();</span>
<span class="fc bfc" id="L633" title="All 2 branches covered.">      for (ResultMapping propertyMapping : propertyMappings) {</span>
        // issue gcode #109 &amp;&amp; issue #149
<span class="fc bfc" id="L635" title="All 4 branches covered.">        if (propertyMapping.getNestedQueryId() != null &amp;&amp; propertyMapping.isLazy()) {</span>
<span class="fc" id="L636">          resultObject = configuration.getProxyFactory().createProxy(resultObject, lazyLoader, configuration, objectFactory, constructorArgTypes, constructorArgs);</span>
<span class="fc" id="L637">          break;</span>
        }
<span class="fc" id="L639">      }</span>
    }
<span class="fc bfc" id="L641" title="All 4 branches covered.">    this.useConstructorMappings = resultObject != null &amp;&amp; !constructorArgTypes.isEmpty(); // set current mapping result</span>
<span class="fc" id="L642">    return resultObject;</span>
  }

  private Object createResultObject(ResultSetWrapper rsw, ResultMap resultMap, List&lt;Class&lt;?&gt;&gt; constructorArgTypes, List&lt;Object&gt; constructorArgs, String columnPrefix)
      throws SQLException {
<span class="fc" id="L647">    final Class&lt;?&gt; resultType = resultMap.getType();</span>
<span class="fc" id="L648">    final MetaClass metaType = MetaClass.forClass(resultType, reflectorFactory);</span>
<span class="fc" id="L649">    final List&lt;ResultMapping&gt; constructorMappings = resultMap.getConstructorResultMappings();</span>
<span class="fc bfc" id="L650" title="All 2 branches covered.">    if (hasTypeHandlerForResultObject(rsw, resultType)) {</span>
<span class="fc" id="L651">      return createPrimitiveResultObject(rsw, resultMap, columnPrefix);</span>
<span class="fc bfc" id="L652" title="All 2 branches covered.">    } else if (!constructorMappings.isEmpty()) {</span>
<span class="fc" id="L653">      return createParameterizedResultObject(rsw, resultType, constructorMappings, constructorArgTypes, constructorArgs, columnPrefix);</span>
<span class="fc bfc" id="L654" title="All 4 branches covered.">    } else if (resultType.isInterface() || metaType.hasDefaultConstructor()) {</span>
<span class="fc" id="L655">      return objectFactory.create(resultType);</span>
<span class="pc bpc" id="L656" title="1 of 2 branches missed.">    } else if (shouldApplyAutomaticMappings(resultMap, false)) {</span>
<span class="fc" id="L657">      return createByConstructorSignature(rsw, resultType, constructorArgTypes, constructorArgs);</span>
    }
<span class="nc" id="L659">    throw new ExecutorException(&quot;Do not know how to create an instance of &quot; + resultType);</span>
  }

  Object createParameterizedResultObject(ResultSetWrapper rsw, Class&lt;?&gt; resultType, List&lt;ResultMapping&gt; constructorMappings,
                                         List&lt;Class&lt;?&gt;&gt; constructorArgTypes, List&lt;Object&gt; constructorArgs, String columnPrefix) {
<span class="fc" id="L664">    boolean foundValues = false;</span>
<span class="fc bfc" id="L665" title="All 2 branches covered.">    for (ResultMapping constructorMapping : constructorMappings) {</span>
<span class="fc" id="L666">      final Class&lt;?&gt; parameterType = constructorMapping.getJavaType();</span>
<span class="fc" id="L667">      final String column = constructorMapping.getColumn();</span>
      final Object value;
      try {
<span class="fc bfc" id="L670" title="All 2 branches covered.">        if (constructorMapping.getNestedQueryId() != null) {</span>
<span class="fc" id="L671">          value = getNestedQueryConstructorValue(rsw.getResultSet(), constructorMapping, columnPrefix);</span>
<span class="fc bfc" id="L672" title="All 2 branches covered.">        } else if (constructorMapping.getNestedResultMapId() != null) {</span>
<span class="fc" id="L673">          final ResultMap resultMap = configuration.getResultMap(constructorMapping.getNestedResultMapId());</span>
<span class="fc" id="L674">          value = getRowValue(rsw, resultMap, getColumnPrefix(columnPrefix, constructorMapping));</span>
<span class="fc" id="L675">        } else {</span>
<span class="fc" id="L676">          final TypeHandler&lt;?&gt; typeHandler = constructorMapping.getTypeHandler();</span>
<span class="fc" id="L677">          value = typeHandler.getResult(rsw.getResultSet(), prependPrefix(column, columnPrefix));</span>
        }
<span class="nc" id="L679">      } catch (ResultMapException | SQLException e) {</span>
<span class="nc" id="L680">        throw new ExecutorException(&quot;Could not process result for mapping: &quot; + constructorMapping, e);</span>
<span class="fc" id="L681">      }</span>
<span class="fc" id="L682">      constructorArgTypes.add(parameterType);</span>
<span class="fc" id="L683">      constructorArgs.add(value);</span>
<span class="pc bpc" id="L684" title="1 of 4 branches missed.">      foundValues = value != null || foundValues;</span>
<span class="fc" id="L685">    }</span>
<span class="fc bfc" id="L686" title="All 2 branches covered.">    return foundValues ? objectFactory.create(resultType, constructorArgTypes, constructorArgs) : null;</span>
  }

  private Object createByConstructorSignature(ResultSetWrapper rsw, Class&lt;?&gt; resultType, List&lt;Class&lt;?&gt;&gt; constructorArgTypes, List&lt;Object&gt; constructorArgs) throws SQLException {
<span class="fc" id="L690">    final Constructor&lt;?&gt;[] constructors = resultType.getDeclaredConstructors();</span>
<span class="fc" id="L691">    final Constructor&lt;?&gt; defaultConstructor = findDefaultConstructor(constructors);</span>
<span class="fc bfc" id="L692" title="All 2 branches covered.">    if (defaultConstructor != null) {</span>
<span class="fc" id="L693">      return createUsingConstructor(rsw, resultType, constructorArgTypes, constructorArgs, defaultConstructor);</span>
    } else {
<span class="pc bpc" id="L695" title="1 of 2 branches missed.">      for (Constructor&lt;?&gt; constructor : constructors) {</span>
<span class="fc bfc" id="L696" title="All 2 branches covered.">        if (allowedConstructorUsingTypeHandlers(constructor, rsw.getJdbcTypes())) {</span>
<span class="fc" id="L697">          return createUsingConstructor(rsw, resultType, constructorArgTypes, constructorArgs, constructor);</span>
        }
      }
    }
<span class="nc" id="L701">    throw new ExecutorException(&quot;No constructor found in &quot; + resultType.getName() + &quot; matching &quot; + rsw.getClassNames());</span>
  }

  private Object createUsingConstructor(ResultSetWrapper rsw, Class&lt;?&gt; resultType, List&lt;Class&lt;?&gt;&gt; constructorArgTypes, List&lt;Object&gt; constructorArgs, Constructor&lt;?&gt; constructor) throws SQLException {
<span class="fc" id="L705">    boolean foundValues = false;</span>
<span class="fc bfc" id="L706" title="All 2 branches covered.">    for (int i = 0; i &lt; constructor.getParameterTypes().length; i++) {</span>
<span class="fc" id="L707">      Class&lt;?&gt; parameterType = constructor.getParameterTypes()[i];</span>
<span class="fc" id="L708">      String columnName = rsw.getColumnNames().get(i);</span>
<span class="fc" id="L709">      TypeHandler&lt;?&gt; typeHandler = rsw.getTypeHandler(parameterType, columnName);</span>
<span class="fc" id="L710">      Object value = typeHandler.getResult(rsw.getResultSet(), columnName);</span>
<span class="fc" id="L711">      constructorArgTypes.add(parameterType);</span>
<span class="fc" id="L712">      constructorArgs.add(value);</span>
<span class="pc bpc" id="L713" title="1 of 4 branches missed.">      foundValues = value != null || foundValues;</span>
    }
<span class="pc bpc" id="L715" title="1 of 2 branches missed.">    return foundValues ? objectFactory.create(resultType, constructorArgTypes, constructorArgs) : null;</span>
  }

  private Constructor&lt;?&gt; findDefaultConstructor(final Constructor&lt;?&gt;[] constructors) {
<span class="fc bfc" id="L719" title="All 2 branches covered.">    if (constructors.length == 1) {</span>
<span class="fc" id="L720">      return constructors[0];</span>
    }

<span class="fc bfc" id="L723" title="All 2 branches covered.">    for (final Constructor&lt;?&gt; constructor : constructors) {</span>
<span class="fc bfc" id="L724" title="All 2 branches covered.">      if (constructor.isAnnotationPresent(AutomapConstructor.class)) {</span>
<span class="fc" id="L725">        return constructor;</span>
      }
    }
<span class="fc" id="L728">    return null;</span>
  }

  private boolean allowedConstructorUsingTypeHandlers(final Constructor&lt;?&gt; constructor, final List&lt;JdbcType&gt; jdbcTypes) {
<span class="fc" id="L732">    final Class&lt;?&gt;[] parameterTypes = constructor.getParameterTypes();</span>
<span class="fc bfc" id="L733" title="All 2 branches covered.">    if (parameterTypes.length != jdbcTypes.size()) {</span>
<span class="fc" id="L734">      return false;</span>
    }
<span class="fc bfc" id="L736" title="All 2 branches covered.">    for (int i = 0; i &lt; parameterTypes.length; i++) {</span>
<span class="pc bpc" id="L737" title="1 of 2 branches missed.">      if (!typeHandlerRegistry.hasTypeHandler(parameterTypes[i], jdbcTypes.get(i))) {</span>
<span class="nc" id="L738">        return false;</span>
      }
    }
<span class="fc" id="L741">    return true;</span>
  }

  private Object createPrimitiveResultObject(ResultSetWrapper rsw, ResultMap resultMap, String columnPrefix) throws SQLException {
<span class="fc" id="L745">    final Class&lt;?&gt; resultType = resultMap.getType();</span>
    final String columnName;
<span class="fc bfc" id="L747" title="All 2 branches covered.">    if (!resultMap.getResultMappings().isEmpty()) {</span>
<span class="fc" id="L748">      final List&lt;ResultMapping&gt; resultMappingList = resultMap.getResultMappings();</span>
<span class="fc" id="L749">      final ResultMapping mapping = resultMappingList.get(0);</span>
<span class="fc" id="L750">      columnName = prependPrefix(mapping.getColumn(), columnPrefix);</span>
<span class="fc" id="L751">    } else {</span>
<span class="fc" id="L752">      columnName = rsw.getColumnNames().get(0);</span>
    }
<span class="fc" id="L754">    final TypeHandler&lt;?&gt; typeHandler = rsw.getTypeHandler(resultType, columnName);</span>
<span class="fc" id="L755">    return typeHandler.getResult(rsw.getResultSet(), columnName);</span>
  }

  //
  // NESTED QUERY
  //

  private Object getNestedQueryConstructorValue(ResultSet rs, ResultMapping constructorMapping, String columnPrefix) throws SQLException {
<span class="fc" id="L763">    final String nestedQueryId = constructorMapping.getNestedQueryId();</span>
<span class="fc" id="L764">    final MappedStatement nestedQuery = configuration.getMappedStatement(nestedQueryId);</span>
<span class="fc" id="L765">    final Class&lt;?&gt; nestedQueryParameterType = nestedQuery.getParameterMap().getType();</span>
<span class="fc" id="L766">    final Object nestedQueryParameterObject = prepareParameterForNestedQuery(rs, constructorMapping, nestedQueryParameterType, columnPrefix);</span>
<span class="fc" id="L767">    Object value = null;</span>
<span class="pc bpc" id="L768" title="1 of 2 branches missed.">    if (nestedQueryParameterObject != null) {</span>
<span class="fc" id="L769">      final BoundSql nestedBoundSql = nestedQuery.getBoundSql(nestedQueryParameterObject);</span>
<span class="fc" id="L770">      final CacheKey key = executor.createCacheKey(nestedQuery, nestedQueryParameterObject, RowBounds.DEFAULT, nestedBoundSql);</span>
<span class="fc" id="L771">      final Class&lt;?&gt; targetType = constructorMapping.getJavaType();</span>
<span class="fc" id="L772">      final ResultLoader resultLoader = new ResultLoader(configuration, executor, nestedQuery, nestedQueryParameterObject, targetType, key, nestedBoundSql);</span>
<span class="fc" id="L773">      value = resultLoader.loadResult();</span>
    }
<span class="fc" id="L775">    return value;</span>
  }

  private Object getNestedQueryMappingValue(ResultSet rs, MetaObject metaResultObject, ResultMapping propertyMapping, ResultLoaderMap lazyLoader, String columnPrefix)
      throws SQLException {
<span class="fc" id="L780">    final String nestedQueryId = propertyMapping.getNestedQueryId();</span>
<span class="fc" id="L781">    final String property = propertyMapping.getProperty();</span>
<span class="fc" id="L782">    final MappedStatement nestedQuery = configuration.getMappedStatement(nestedQueryId);</span>
<span class="fc" id="L783">    final Class&lt;?&gt; nestedQueryParameterType = nestedQuery.getParameterMap().getType();</span>
<span class="fc" id="L784">    final Object nestedQueryParameterObject = prepareParameterForNestedQuery(rs, propertyMapping, nestedQueryParameterType, columnPrefix);</span>
<span class="fc" id="L785">    Object value = null;</span>
<span class="fc bfc" id="L786" title="All 2 branches covered.">    if (nestedQueryParameterObject != null) {</span>
<span class="fc" id="L787">      final BoundSql nestedBoundSql = nestedQuery.getBoundSql(nestedQueryParameterObject);</span>
<span class="fc" id="L788">      final CacheKey key = executor.createCacheKey(nestedQuery, nestedQueryParameterObject, RowBounds.DEFAULT, nestedBoundSql);</span>
<span class="fc" id="L789">      final Class&lt;?&gt; targetType = propertyMapping.getJavaType();</span>
<span class="fc bfc" id="L790" title="All 2 branches covered.">      if (executor.isCached(nestedQuery, key)) {</span>
<span class="fc" id="L791">        executor.deferLoad(nestedQuery, metaResultObject, property, key, targetType);</span>
<span class="fc" id="L792">        value = DEFERRED;</span>
      } else {
<span class="fc" id="L794">        final ResultLoader resultLoader = new ResultLoader(configuration, executor, nestedQuery, nestedQueryParameterObject, targetType, key, nestedBoundSql);</span>
<span class="fc bfc" id="L795" title="All 2 branches covered.">        if (propertyMapping.isLazy()) {</span>
<span class="fc" id="L796">          lazyLoader.addLoader(property, metaResultObject, resultLoader);</span>
<span class="fc" id="L797">          value = DEFERRED;</span>
        } else {
<span class="fc" id="L799">          value = resultLoader.loadResult();</span>
        }
      }
    }
<span class="fc" id="L803">    return value;</span>
  }

  private Object prepareParameterForNestedQuery(ResultSet rs, ResultMapping resultMapping, Class&lt;?&gt; parameterType, String columnPrefix) throws SQLException {
<span class="fc bfc" id="L807" title="All 2 branches covered.">    if (resultMapping.isCompositeResult()) {</span>
<span class="fc" id="L808">      return prepareCompositeKeyParameter(rs, resultMapping, parameterType, columnPrefix);</span>
    } else {
<span class="fc" id="L810">      return prepareSimpleKeyParameter(rs, resultMapping, parameterType, columnPrefix);</span>
    }
  }

  private Object prepareSimpleKeyParameter(ResultSet rs, ResultMapping resultMapping, Class&lt;?&gt; parameterType, String columnPrefix) throws SQLException {
    final TypeHandler&lt;?&gt; typeHandler;
<span class="fc bfc" id="L816" title="All 2 branches covered.">    if (typeHandlerRegistry.hasTypeHandler(parameterType)) {</span>
<span class="fc" id="L817">      typeHandler = typeHandlerRegistry.getTypeHandler(parameterType);</span>
    } else {
<span class="fc" id="L819">      typeHandler = typeHandlerRegistry.getUnknownTypeHandler();</span>
    }
<span class="fc" id="L821">    return typeHandler.getResult(rs, prependPrefix(resultMapping.getColumn(), columnPrefix));</span>
  }

  private Object prepareCompositeKeyParameter(ResultSet rs, ResultMapping resultMapping, Class&lt;?&gt; parameterType, String columnPrefix) throws SQLException {
<span class="fc" id="L825">    final Object parameterObject = instantiateParameterObject(parameterType);</span>
<span class="fc" id="L826">    final MetaObject metaObject = configuration.newMetaObject(parameterObject);</span>
<span class="fc" id="L827">    boolean foundValues = false;</span>
<span class="fc bfc" id="L828" title="All 2 branches covered.">    for (ResultMapping innerResultMapping : resultMapping.getComposites()) {</span>
<span class="fc" id="L829">      final Class&lt;?&gt; propType = metaObject.getSetterType(innerResultMapping.getProperty());</span>
<span class="fc" id="L830">      final TypeHandler&lt;?&gt; typeHandler = typeHandlerRegistry.getTypeHandler(propType);</span>
<span class="fc" id="L831">      final Object propValue = typeHandler.getResult(rs, prependPrefix(innerResultMapping.getColumn(), columnPrefix));</span>
      // issue #353 &amp; #560 do not execute nested query if key is null
<span class="fc bfc" id="L833" title="All 2 branches covered.">      if (propValue != null) {</span>
<span class="fc" id="L834">        metaObject.setValue(innerResultMapping.getProperty(), propValue);</span>
<span class="fc" id="L835">        foundValues = true;</span>
      }
<span class="fc" id="L837">    }</span>
<span class="fc bfc" id="L838" title="All 2 branches covered.">    return foundValues ? parameterObject : null;</span>
  }

  private Object instantiateParameterObject(Class&lt;?&gt; parameterType) {
<span class="fc bfc" id="L842" title="All 2 branches covered.">    if (parameterType == null) {</span>
<span class="fc" id="L843">      return new HashMap&lt;&gt;();</span>
<span class="fc bfc" id="L844" title="All 2 branches covered.">    } else if (ParamMap.class.equals(parameterType)) {</span>
<span class="fc" id="L845">      return new HashMap&lt;&gt;(); // issue #649</span>
    } else {
<span class="fc" id="L847">      return objectFactory.create(parameterType);</span>
    }
  }

  //
  // DISCRIMINATOR
  //

  public ResultMap resolveDiscriminatedResultMap(ResultSet rs, ResultMap resultMap, String columnPrefix) throws SQLException {
<span class="fc" id="L856">    Set&lt;String&gt; pastDiscriminators = new HashSet&lt;&gt;();</span>
<span class="fc" id="L857">    Discriminator discriminator = resultMap.getDiscriminator();</span>
<span class="fc bfc" id="L858" title="All 2 branches covered.">    while (discriminator != null) {</span>
<span class="fc" id="L859">      final Object value = getDiscriminatorValue(rs, discriminator, columnPrefix);</span>
<span class="fc" id="L860">      final String discriminatedMapId = discriminator.getMapIdFor(String.valueOf(value));</span>
<span class="fc bfc" id="L861" title="All 2 branches covered.">      if (configuration.hasResultMap(discriminatedMapId)) {</span>
<span class="fc" id="L862">        resultMap = configuration.getResultMap(discriminatedMapId);</span>
<span class="fc" id="L863">        Discriminator lastDiscriminator = discriminator;</span>
<span class="fc" id="L864">        discriminator = resultMap.getDiscriminator();</span>
<span class="pc bpc" id="L865" title="1 of 4 branches missed.">        if (discriminator == lastDiscriminator || !pastDiscriminators.add(discriminatedMapId)) {</span>
<span class="fc" id="L866">          break;</span>
        }
      } else {
        break;
      }
<span class="fc" id="L871">    }</span>
<span class="fc" id="L872">    return resultMap;</span>
  }

  private Object getDiscriminatorValue(ResultSet rs, Discriminator discriminator, String columnPrefix) throws SQLException {
<span class="fc" id="L876">    final ResultMapping resultMapping = discriminator.getResultMapping();</span>
<span class="fc" id="L877">    final TypeHandler&lt;?&gt; typeHandler = resultMapping.getTypeHandler();</span>
<span class="fc" id="L878">    return typeHandler.getResult(rs, prependPrefix(resultMapping.getColumn(), columnPrefix));</span>
  }

  private String prependPrefix(String columnName, String prefix) {
<span class="pc bpc" id="L882" title="2 of 8 branches missed.">    if (columnName == null || columnName.length() == 0 || prefix == null || prefix.length() == 0) {</span>
<span class="fc" id="L883">      return columnName;</span>
    }
<span class="fc" id="L885">    return prefix + columnName;</span>
  }

  //
  // HANDLE NESTED RESULT MAPS
  //

  private void handleRowValuesForNestedResultMap(ResultSetWrapper rsw, ResultMap resultMap, ResultHandler&lt;?&gt; resultHandler, RowBounds rowBounds, ResultMapping parentMapping) throws SQLException {
<span class="fc" id="L893">    final DefaultResultContext&lt;Object&gt; resultContext = new DefaultResultContext&lt;&gt;();</span>
<span class="fc" id="L894">    ResultSet resultSet = rsw.getResultSet();</span>
<span class="fc" id="L895">    skipRows(resultSet, rowBounds);</span>
<span class="fc" id="L896">    Object rowValue = previousRowValue;</span>
<span class="pc bpc" id="L897" title="1 of 6 branches missed.">    while (shouldProcessMoreRows(resultContext, rowBounds) &amp;&amp; !resultSet.isClosed() &amp;&amp; resultSet.next()) {</span>
<span class="fc" id="L898">      final ResultMap discriminatedResultMap = resolveDiscriminatedResultMap(resultSet, resultMap, null);</span>
<span class="fc" id="L899">      final CacheKey rowKey = createRowKey(discriminatedResultMap, rsw, null);</span>
<span class="fc" id="L900">      Object partialObject = nestedResultObjects.get(rowKey);</span>
      // issue #577 &amp;&amp; #542
<span class="fc bfc" id="L902" title="All 2 branches covered.">      if (mappedStatement.isResultOrdered()) {</span>
<span class="fc bfc" id="L903" title="All 4 branches covered.">        if (partialObject == null &amp;&amp; rowValue != null) {</span>
<span class="fc" id="L904">          nestedResultObjects.clear();</span>
<span class="fc" id="L905">          storeObject(resultHandler, resultContext, rowValue, parentMapping, resultSet);</span>
        }
<span class="fc" id="L907">        rowValue = getRowValue(rsw, discriminatedResultMap, rowKey, null, partialObject);</span>
      } else {
<span class="fc" id="L909">        rowValue = getRowValue(rsw, discriminatedResultMap, rowKey, null, partialObject);</span>
<span class="fc bfc" id="L910" title="All 2 branches covered.">        if (partialObject == null) {</span>
<span class="fc" id="L911">          storeObject(resultHandler, resultContext, rowValue, parentMapping, resultSet);</span>
        }
      }
<span class="fc" id="L914">    }</span>
<span class="fc bfc" id="L915" title="All 6 branches covered.">    if (rowValue != null &amp;&amp; mappedStatement.isResultOrdered() &amp;&amp; shouldProcessMoreRows(resultContext, rowBounds)) {</span>
<span class="fc" id="L916">      storeObject(resultHandler, resultContext, rowValue, parentMapping, resultSet);</span>
<span class="fc" id="L917">      previousRowValue = null;</span>
<span class="fc bfc" id="L918" title="All 2 branches covered.">    } else if (rowValue != null) {</span>
<span class="fc" id="L919">      previousRowValue = rowValue;</span>
    }
<span class="fc" id="L921">  }</span>

  //
  // NESTED RESULT MAP (JOIN MAPPING)
  //

  private boolean applyNestedResultMappings(ResultSetWrapper rsw, ResultMap resultMap, MetaObject metaObject, String parentPrefix, CacheKey parentRowKey, boolean newObject) {
<span class="fc" id="L928">    boolean foundValues = false;</span>
<span class="fc bfc" id="L929" title="All 2 branches covered.">    for (ResultMapping resultMapping : resultMap.getPropertyResultMappings()) {</span>
<span class="fc" id="L930">      final String nestedResultMapId = resultMapping.getNestedResultMapId();</span>
<span class="pc bpc" id="L931" title="1 of 4 branches missed.">      if (nestedResultMapId != null &amp;&amp; resultMapping.getResultSet() == null) {</span>
        try {
<span class="fc" id="L933">          final String columnPrefix = getColumnPrefix(parentPrefix, resultMapping);</span>
<span class="fc" id="L934">          final ResultMap nestedResultMap = getNestedResultMap(rsw.getResultSet(), nestedResultMapId, columnPrefix);</span>
<span class="fc bfc" id="L935" title="All 2 branches covered.">          if (resultMapping.getColumnPrefix() == null) {</span>
            // try to fill circular reference only when columnPrefix
            // is not specified for the nested result map (issue #215)
<span class="fc" id="L938">            Object ancestorObject = ancestorObjects.get(nestedResultMapId);</span>
<span class="fc bfc" id="L939" title="All 2 branches covered.">            if (ancestorObject != null) {</span>
<span class="fc bfc" id="L940" title="All 2 branches covered.">              if (newObject) {</span>
<span class="fc" id="L941">                linkObjects(metaObject, resultMapping, ancestorObject); // issue #385</span>
              }
<span class="fc" id="L943">              continue;</span>
            }
          }
<span class="fc" id="L946">          final CacheKey rowKey = createRowKey(nestedResultMap, rsw, columnPrefix);</span>
<span class="fc" id="L947">          final CacheKey combinedKey = combineKeys(rowKey, parentRowKey);</span>
<span class="fc" id="L948">          Object rowValue = nestedResultObjects.get(combinedKey);</span>
<span class="fc bfc" id="L949" title="All 2 branches covered.">          boolean knownValue = rowValue != null;</span>
<span class="fc" id="L950">          instantiateCollectionPropertyIfAppropriate(resultMapping, metaObject); // mandatory</span>
<span class="fc bfc" id="L951" title="All 2 branches covered.">          if (anyNotNullColumnHasValue(resultMapping, columnPrefix, rsw)) {</span>
<span class="fc" id="L952">            rowValue = getRowValue(rsw, nestedResultMap, combinedKey, columnPrefix, rowValue);</span>
<span class="fc bfc" id="L953" title="All 4 branches covered.">            if (rowValue != null &amp;&amp; !knownValue) {</span>
<span class="fc" id="L954">              linkObjects(metaObject, resultMapping, rowValue);</span>
<span class="fc" id="L955">              foundValues = true;</span>
            }
          }
<span class="nc" id="L958">        } catch (SQLException e) {</span>
<span class="nc" id="L959">          throw new ExecutorException(&quot;Error getting nested result map values for '&quot; + resultMapping.getProperty() + &quot;'.  Cause: &quot; + e, e);</span>
<span class="fc" id="L960">        }</span>
      }
<span class="fc" id="L962">    }</span>
<span class="fc" id="L963">    return foundValues;</span>
  }

  private String getColumnPrefix(String parentPrefix, ResultMapping resultMapping) {
<span class="fc" id="L967">    final StringBuilder columnPrefixBuilder = new StringBuilder();</span>
<span class="fc bfc" id="L968" title="All 2 branches covered.">    if (parentPrefix != null) {</span>
<span class="fc" id="L969">      columnPrefixBuilder.append(parentPrefix);</span>
    }
<span class="fc bfc" id="L971" title="All 2 branches covered.">    if (resultMapping.getColumnPrefix() != null) {</span>
<span class="fc" id="L972">      columnPrefixBuilder.append(resultMapping.getColumnPrefix());</span>
    }
<span class="fc bfc" id="L974" title="All 2 branches covered.">    return columnPrefixBuilder.length() == 0 ? null : columnPrefixBuilder.toString().toUpperCase(Locale.ENGLISH);</span>
  }

  private boolean anyNotNullColumnHasValue(ResultMapping resultMapping, String columnPrefix, ResultSetWrapper rsw) throws SQLException {
<span class="fc" id="L978">    Set&lt;String&gt; notNullColumns = resultMapping.getNotNullColumns();</span>
<span class="fc bfc" id="L979" title="All 4 branches covered.">    if (notNullColumns != null &amp;&amp; !notNullColumns.isEmpty()) {</span>
<span class="fc" id="L980">      ResultSet rs = rsw.getResultSet();</span>
<span class="fc bfc" id="L981" title="All 2 branches covered.">      for (String column : notNullColumns) {</span>
<span class="fc" id="L982">        rs.getObject(prependPrefix(column, columnPrefix));</span>
<span class="fc bfc" id="L983" title="All 2 branches covered.">        if (!rs.wasNull()) {</span>
<span class="fc" id="L984">          return true;</span>
        }
<span class="fc" id="L986">      }</span>
<span class="fc" id="L987">      return false;</span>
<span class="fc bfc" id="L988" title="All 2 branches covered.">    } else if (columnPrefix != null) {</span>
<span class="fc bfc" id="L989" title="All 2 branches covered.">      for (String columnName : rsw.getColumnNames()) {</span>
<span class="fc bfc" id="L990" title="All 2 branches covered.">        if (columnName.toUpperCase().startsWith(columnPrefix.toUpperCase())) {</span>
<span class="fc" id="L991">          return true;</span>
        }
<span class="fc" id="L993">      }</span>
<span class="fc" id="L994">      return false;</span>
    }
<span class="fc" id="L996">    return true;</span>
  }

  private ResultMap getNestedResultMap(ResultSet rs, String nestedResultMapId, String columnPrefix) throws SQLException {
<span class="fc" id="L1000">    ResultMap nestedResultMap = configuration.getResultMap(nestedResultMapId);</span>
<span class="fc" id="L1001">    return resolveDiscriminatedResultMap(rs, nestedResultMap, columnPrefix);</span>
  }

  //
  // UNIQUE RESULT KEY
  //

  private CacheKey createRowKey(ResultMap resultMap, ResultSetWrapper rsw, String columnPrefix) throws SQLException {
<span class="fc" id="L1009">    final CacheKey cacheKey = new CacheKey();</span>
<span class="fc" id="L1010">    cacheKey.update(resultMap.getId());</span>
<span class="fc" id="L1011">    List&lt;ResultMapping&gt; resultMappings = getResultMappingsForRowKey(resultMap);</span>
<span class="fc bfc" id="L1012" title="All 2 branches covered.">    if (resultMappings.isEmpty()) {</span>
<span class="pc bpc" id="L1013" title="1 of 2 branches missed.">      if (Map.class.isAssignableFrom(resultMap.getType())) {</span>
<span class="nc" id="L1014">        createRowKeyForMap(rsw, cacheKey);</span>
      } else {
<span class="fc" id="L1016">        createRowKeyForUnmappedProperties(resultMap, rsw, cacheKey, columnPrefix);</span>
      }
    } else {
<span class="fc" id="L1019">      createRowKeyForMappedProperties(resultMap, rsw, cacheKey, resultMappings, columnPrefix);</span>
    }
<span class="fc bfc" id="L1021" title="All 2 branches covered.">    if (cacheKey.getUpdateCount() &lt; 2) {</span>
<span class="fc" id="L1022">      return CacheKey.NULL_CACHE_KEY;</span>
    }
<span class="fc" id="L1024">    return cacheKey;</span>
  }

  private CacheKey combineKeys(CacheKey rowKey, CacheKey parentRowKey) {
<span class="fc bfc" id="L1028" title="All 4 branches covered.">    if (rowKey.getUpdateCount() &gt; 1 &amp;&amp; parentRowKey.getUpdateCount() &gt; 1) {</span>
      CacheKey combinedKey;
      try {
<span class="fc" id="L1031">        combinedKey = rowKey.clone();</span>
<span class="nc" id="L1032">      } catch (CloneNotSupportedException e) {</span>
<span class="nc" id="L1033">        throw new ExecutorException(&quot;Error cloning cache key.  Cause: &quot; + e, e);</span>
<span class="fc" id="L1034">      }</span>
<span class="fc" id="L1035">      combinedKey.update(parentRowKey);</span>
<span class="fc" id="L1036">      return combinedKey;</span>
    }
<span class="fc" id="L1038">    return CacheKey.NULL_CACHE_KEY;</span>
  }

  private List&lt;ResultMapping&gt; getResultMappingsForRowKey(ResultMap resultMap) {
<span class="fc" id="L1042">    List&lt;ResultMapping&gt; resultMappings = resultMap.getIdResultMappings();</span>
<span class="fc bfc" id="L1043" title="All 2 branches covered.">    if (resultMappings.isEmpty()) {</span>
<span class="fc" id="L1044">      resultMappings = resultMap.getPropertyResultMappings();</span>
    }
<span class="fc" id="L1046">    return resultMappings;</span>
  }

  private void createRowKeyForMappedProperties(ResultMap resultMap, ResultSetWrapper rsw, CacheKey cacheKey, List&lt;ResultMapping&gt; resultMappings, String columnPrefix) throws SQLException {
<span class="fc bfc" id="L1050" title="All 2 branches covered.">    for (ResultMapping resultMapping : resultMappings) {</span>
<span class="fc bfc" id="L1051" title="All 2 branches covered.">      if (resultMapping.isSimple()) {</span>
<span class="fc" id="L1052">        final String column = prependPrefix(resultMapping.getColumn(), columnPrefix);</span>
<span class="fc" id="L1053">        final TypeHandler&lt;?&gt; th = resultMapping.getTypeHandler();</span>
<span class="fc" id="L1054">        List&lt;String&gt; mappedColumnNames = rsw.getMappedColumnNames(resultMap, columnPrefix);</span>
        // Issue #114
<span class="pc bpc" id="L1056" title="1 of 4 branches missed.">        if (column != null &amp;&amp; mappedColumnNames.contains(column.toUpperCase(Locale.ENGLISH))) {</span>
<span class="fc" id="L1057">          final Object value = th.getResult(rsw.getResultSet(), column);</span>
<span class="fc bfc" id="L1058" title="All 4 branches covered.">          if (value != null || configuration.isReturnInstanceForEmptyRow()) {</span>
<span class="fc" id="L1059">            cacheKey.update(column);</span>
<span class="fc" id="L1060">            cacheKey.update(value);</span>
          }
        }
      }
<span class="fc" id="L1064">    }</span>
<span class="fc" id="L1065">  }</span>

  private void createRowKeyForUnmappedProperties(ResultMap resultMap, ResultSetWrapper rsw, CacheKey cacheKey, String columnPrefix) throws SQLException {
<span class="fc" id="L1068">    final MetaClass metaType = MetaClass.forClass(resultMap.getType(), reflectorFactory);</span>
<span class="fc" id="L1069">    List&lt;String&gt; unmappedColumnNames = rsw.getUnmappedColumnNames(resultMap, columnPrefix);</span>
<span class="fc bfc" id="L1070" title="All 2 branches covered.">    for (String column : unmappedColumnNames) {</span>
<span class="fc" id="L1071">      String property = column;</span>
<span class="pc bpc" id="L1072" title="1 of 4 branches missed.">      if (columnPrefix != null &amp;&amp; !columnPrefix.isEmpty()) {</span>
        // When columnPrefix is specified, ignore columns without the prefix.
<span class="fc bfc" id="L1074" title="All 2 branches covered.">        if (column.toUpperCase(Locale.ENGLISH).startsWith(columnPrefix)) {</span>
<span class="fc" id="L1075">          property = column.substring(columnPrefix.length());</span>
        } else {
          continue;
        }
      }
<span class="fc bfc" id="L1080" title="All 2 branches covered.">      if (metaType.findProperty(property, configuration.isMapUnderscoreToCamelCase()) != null) {</span>
<span class="fc" id="L1081">        String value = rsw.getResultSet().getString(column);</span>
<span class="fc bfc" id="L1082" title="All 2 branches covered.">        if (value != null) {</span>
<span class="fc" id="L1083">          cacheKey.update(column);</span>
<span class="fc" id="L1084">          cacheKey.update(value);</span>
        }
      }
<span class="fc" id="L1087">    }</span>
<span class="fc" id="L1088">  }</span>

  private void createRowKeyForMap(ResultSetWrapper rsw, CacheKey cacheKey) throws SQLException {
<span class="nc" id="L1091">    List&lt;String&gt; columnNames = rsw.getColumnNames();</span>
<span class="nc bnc" id="L1092" title="All 2 branches missed.">    for (String columnName : columnNames) {</span>
<span class="nc" id="L1093">      final String value = rsw.getResultSet().getString(columnName);</span>
<span class="nc bnc" id="L1094" title="All 2 branches missed.">      if (value != null) {</span>
<span class="nc" id="L1095">        cacheKey.update(columnName);</span>
<span class="nc" id="L1096">        cacheKey.update(value);</span>
      }
<span class="nc" id="L1098">    }</span>
<span class="nc" id="L1099">  }</span>

  private void linkObjects(MetaObject metaObject, ResultMapping resultMapping, Object rowValue) {
<span class="fc" id="L1102">    final Object collectionProperty = instantiateCollectionPropertyIfAppropriate(resultMapping, metaObject);</span>
<span class="fc bfc" id="L1103" title="All 2 branches covered.">    if (collectionProperty != null) {</span>
<span class="fc" id="L1104">      final MetaObject targetMetaObject = configuration.newMetaObject(collectionProperty);</span>
<span class="fc" id="L1105">      targetMetaObject.add(rowValue);</span>
<span class="fc" id="L1106">    } else {</span>
<span class="fc" id="L1107">      metaObject.setValue(resultMapping.getProperty(), rowValue);</span>
    }
<span class="fc" id="L1109">  }</span>

  private Object instantiateCollectionPropertyIfAppropriate(ResultMapping resultMapping, MetaObject metaObject) {
<span class="fc" id="L1112">    final String propertyName = resultMapping.getProperty();</span>
<span class="fc" id="L1113">    Object propertyValue = metaObject.getValue(propertyName);</span>
<span class="fc bfc" id="L1114" title="All 2 branches covered.">    if (propertyValue == null) {</span>
<span class="fc" id="L1115">      Class&lt;?&gt; type = resultMapping.getJavaType();</span>
<span class="fc bfc" id="L1116" title="All 2 branches covered.">      if (type == null) {</span>
<span class="fc" id="L1117">        type = metaObject.getSetterType(propertyName);</span>
      }
      try {
<span class="fc bfc" id="L1120" title="All 2 branches covered.">        if (objectFactory.isCollection(type)) {</span>
<span class="fc" id="L1121">          propertyValue = objectFactory.create(type);</span>
<span class="fc" id="L1122">          metaObject.setValue(propertyName, propertyValue);</span>
<span class="fc" id="L1123">          return propertyValue;</span>
        }
<span class="nc" id="L1125">      } catch (Exception e) {</span>
<span class="nc" id="L1126">        throw new ExecutorException(&quot;Error instantiating collection property for result '&quot; + resultMapping.getProperty() + &quot;'.  Cause: &quot; + e, e);</span>
<span class="fc" id="L1127">      }</span>
<span class="fc bfc" id="L1128" title="All 2 branches covered.">    } else if (objectFactory.isCollection(propertyValue.getClass())) {</span>
<span class="fc" id="L1129">      return propertyValue;</span>
    }
<span class="fc" id="L1131">    return null;</span>
  }

  private boolean hasTypeHandlerForResultObject(ResultSetWrapper rsw, Class&lt;?&gt; resultType) {
<span class="fc bfc" id="L1135" title="All 2 branches covered.">    if (rsw.getColumnNames().size() == 1) {</span>
<span class="fc" id="L1136">      return typeHandlerRegistry.hasTypeHandler(resultType, rsw.getJdbcType(rsw.getColumnNames().get(0)));</span>
    }
<span class="fc" id="L1138">    return typeHandlerRegistry.hasTypeHandler(resultType);</span>
  }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.7.202105040129</span></div></body></html>