<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>StructuredOptionsSplitter.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Flink : Core</a> &gt; <a href="index.source.html" class="el_package">org.apache.flink.configuration</a> &gt; <span class="el_source">StructuredOptionsSplitter.java</span></div><h1>StructuredOptionsSplitter.java</h1><pre class="source lang-java linenums">/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * &quot;License&quot;); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.apache.flink.configuration;

import org.apache.flink.annotation.Internal;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

import static org.apache.flink.util.Preconditions.checkNotNull;

/** Helper class for splitting a string on a given delimiter with quoting logic. */
@Internal
class StructuredOptionsSplitter {

    /**
     * Splits the given string on the given delimiter. It supports quoting parts of the string with
     * either single (') or double quotes (&quot;). Quotes can be escaped by doubling the quotes.
     *
     * &lt;p&gt;Examples:
     *
     * &lt;ul&gt;
     *   &lt;li&gt;'A;B';C =&gt; [A;B], [C]
     *   &lt;li&gt;&quot;AB'D&quot;;B;C =&gt; [AB'D], [B], [C]
     *   &lt;li&gt;&quot;AB'&quot;&quot;D;B&quot;;C =&gt; [AB'\&quot;D;B], [C]
     * &lt;/ul&gt;
     *
     * &lt;p&gt;For more examples check the tests.
     *
     * @param string a string to split
     * @param delimiter delimiter to split on
     * @return a list of splits
     */
    static List&lt;String&gt; splitEscaped(String string, char delimiter) {
<span class="fc" id="L52">        List&lt;Token&gt; tokens = tokenize(checkNotNull(string), delimiter);</span>
<span class="fc" id="L53">        return processTokens(tokens);</span>
    }

    /**
     * Escapes the given string with single quotes, if the input string contains a double quote or
     * any of the given {@code charsToEscape}. Any single quotes in the input string will be escaped
     * by doubling.
     *
     * &lt;p&gt;Given that the escapeChar is (;)
     *
     * &lt;p&gt;Examples:
     *
     * &lt;ul&gt;
     *   &lt;li&gt;A,B,C,D =&gt; A,B,C,D
     *   &lt;li&gt;A'B'C'D =&gt; 'A''B''C''D'
     *   &lt;li&gt;A;BCD =&gt; 'A;BCD'
     *   &lt;li&gt;AB&quot;C&quot;D =&gt; 'AB&quot;C&quot;D'
     *   &lt;li&gt;AB'&quot;D:B =&gt; 'AB''&quot;D:B'
     * &lt;/ul&gt;
     *
     * @param string a string which needs to be escaped
     * @param charsToEscape escape chars for the escape conditions
     * @return escaped string by single quote
     */
    static String escapeWithSingleQuote(String string, String... charsToEscape) {
<span class="fc" id="L78">        boolean escape =</span>
<span class="fc bfc" id="L79" title="All 2 branches covered.">                Arrays.stream(charsToEscape).anyMatch(string::contains)</span>
<span class="fc bfc" id="L80" title="All 2 branches covered.">                        || string.contains(&quot;\&quot;&quot;)</span>
<span class="fc bfc" id="L81" title="All 2 branches covered.">                        || string.contains(&quot;'&quot;);</span>

<span class="fc bfc" id="L83" title="All 2 branches covered.">        if (escape) {</span>
<span class="fc" id="L84">            return &quot;'&quot; + string.replaceAll(&quot;'&quot;, &quot;''&quot;) + &quot;'&quot;;</span>
        }

<span class="fc" id="L87">        return string;</span>
    }

    private static List&lt;String&gt; processTokens(List&lt;Token&gt; tokens) {
<span class="fc" id="L91">        final List&lt;String&gt; splits = new ArrayList&lt;&gt;();</span>
<span class="fc bfc" id="L92" title="All 2 branches covered.">        for (int i = 0; i &lt; tokens.size(); i++) {</span>
<span class="fc" id="L93">            Token token = tokens.get(i);</span>
<span class="pc bpc" id="L94" title="1 of 4 branches missed.">            switch (token.getTokenType()) {</span>
                case DOUBLE_QUOTED:
                case SINGLE_QUOTED:
<span class="fc bfc" id="L97" title="All 2 branches covered.">                    if (i + 1 &lt; tokens.size()</span>
<span class="fc bfc" id="L98" title="All 2 branches covered.">                            &amp;&amp; tokens.get(i + 1).getTokenType() != TokenType.DELIMITER) {</span>
<span class="fc" id="L99">                        int illegalPosition = tokens.get(i + 1).getPosition() - 1;</span>
<span class="fc" id="L100">                        throw new IllegalArgumentException(</span>
                                &quot;Could not split string. Illegal quoting at position: &quot;
                                        + illegalPosition);
                    }
<span class="fc" id="L104">                    splits.add(token.getString());</span>
<span class="fc" id="L105">                    break;</span>
                case UNQUOTED:
<span class="fc" id="L107">                    splits.add(token.getString());</span>
<span class="fc" id="L108">                    break;</span>
                case DELIMITER:
<span class="pc bpc" id="L110" title="1 of 2 branches missed.">                    if (i + 1 &lt; tokens.size()</span>
<span class="pc bpc" id="L111" title="1 of 2 branches missed.">                            &amp;&amp; tokens.get(i + 1).getTokenType() == TokenType.DELIMITER) {</span>
<span class="nc" id="L112">                        splits.add(&quot;&quot;);</span>
                    }
                    break;
            }
        }

<span class="fc" id="L118">        return splits;</span>
    }

    private static List&lt;Token&gt; tokenize(String string, char delimiter) {
<span class="fc" id="L122">        final List&lt;Token&gt; tokens = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L123">        final StringBuilder builder = new StringBuilder();</span>
<span class="fc bfc" id="L124" title="All 2 branches covered.">        for (int cursor = 0; cursor &lt; string.length(); ) {</span>
<span class="fc" id="L125">            final char c = string.charAt(cursor);</span>

<span class="fc" id="L127">            int nextChar = cursor + 1;</span>
<span class="fc bfc" id="L128" title="All 2 branches covered.">            if (c == '\'') {</span>
<span class="fc" id="L129">                nextChar = consumeInQuotes(string, '\'', cursor, builder);</span>
<span class="fc" id="L130">                tokens.add(new Token(TokenType.SINGLE_QUOTED, builder.toString(), cursor));</span>
<span class="fc bfc" id="L131" title="All 2 branches covered.">            } else if (c == '&quot;') {</span>
<span class="fc" id="L132">                nextChar = consumeInQuotes(string, '&quot;', cursor, builder);</span>
<span class="fc" id="L133">                tokens.add(new Token(TokenType.DOUBLE_QUOTED, builder.toString(), cursor));</span>
<span class="fc bfc" id="L134" title="All 2 branches covered.">            } else if (c == delimiter) {</span>
<span class="fc" id="L135">                tokens.add(new Token(TokenType.DELIMITER, String.valueOf(c), cursor));</span>
<span class="fc bfc" id="L136" title="All 2 branches covered.">            } else if (!Character.isWhitespace(c)) {</span>
<span class="fc" id="L137">                nextChar = consumeUnquoted(string, delimiter, cursor, builder);</span>
<span class="fc" id="L138">                tokens.add(new Token(TokenType.UNQUOTED, builder.toString().trim(), cursor));</span>
            }
<span class="fc" id="L140">            builder.setLength(0);</span>
<span class="fc" id="L141">            cursor = nextChar;</span>
<span class="fc" id="L142">        }</span>

<span class="fc" id="L144">        return tokens;</span>
    }

    private static int consumeInQuotes(
            String string, char quote, int cursor, StringBuilder builder) {
<span class="fc bfc" id="L149" title="All 2 branches covered.">        for (int i = cursor + 1; i &lt; string.length(); i++) {</span>
<span class="fc" id="L150">            char c = string.charAt(i);</span>
<span class="fc bfc" id="L151" title="All 2 branches covered.">            if (c == quote) {</span>
<span class="fc bfc" id="L152" title="All 4 branches covered.">                if (i + 1 &lt; string.length() &amp;&amp; string.charAt(i + 1) == quote) {</span>
<span class="fc" id="L153">                    builder.append(c);</span>
<span class="fc" id="L154">                    i += 1;</span>
                } else {
<span class="fc" id="L156">                    return i + 1;</span>
                }
            } else {
<span class="fc" id="L159">                builder.append(c);</span>
            }
        }

<span class="fc" id="L163">        throw new IllegalArgumentException(</span>
                &quot;Could not split string. Quoting was not closed properly.&quot;);
    }

    private static int consumeUnquoted(
            String string, char delimiter, int cursor, StringBuilder builder) {
        int i;
<span class="fc bfc" id="L170" title="All 2 branches covered.">        for (i = cursor; i &lt; string.length(); i++) {</span>
<span class="fc" id="L171">            char c = string.charAt(i);</span>
<span class="fc bfc" id="L172" title="All 2 branches covered.">            if (c == delimiter) {</span>
<span class="fc" id="L173">                return i;</span>
            }

<span class="fc" id="L176">            builder.append(c);</span>
        }

<span class="fc" id="L179">        return i;</span>
    }

<span class="fc" id="L182">    private enum TokenType {</span>
<span class="fc" id="L183">        DOUBLE_QUOTED,</span>
<span class="fc" id="L184">        SINGLE_QUOTED,</span>
<span class="fc" id="L185">        UNQUOTED,</span>
<span class="fc" id="L186">        DELIMITER</span>
    }

    private static class Token {
        private final TokenType tokenType;
        private final String string;
        private final int position;

<span class="fc" id="L194">        private Token(TokenType tokenType, String string, int position) {</span>
<span class="fc" id="L195">            this.tokenType = tokenType;</span>
<span class="fc" id="L196">            this.string = string;</span>
<span class="fc" id="L197">            this.position = position;</span>
<span class="fc" id="L198">        }</span>

        public TokenType getTokenType() {
<span class="fc" id="L201">            return tokenType;</span>
        }

        public String getString() {
<span class="fc" id="L205">            return string;</span>
        }

        public int getPosition() {
<span class="fc" id="L209">            return position;</span>
        }
    }

    private StructuredOptionsSplitter() {}
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.7.202105040129</span></div></body></html>