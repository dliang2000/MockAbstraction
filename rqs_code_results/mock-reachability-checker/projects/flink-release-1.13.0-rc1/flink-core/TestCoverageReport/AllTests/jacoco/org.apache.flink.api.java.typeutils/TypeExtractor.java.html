<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>TypeExtractor.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Flink : Core</a> &gt; <a href="index.source.html" class="el_package">org.apache.flink.api.java.typeutils</a> &gt; <span class="el_source">TypeExtractor.java</span></div><h1>TypeExtractor.java</h1><pre class="source lang-java linenums">/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * &quot;License&quot;); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.apache.flink.api.java.typeutils;

import org.apache.flink.annotation.Internal;
import org.apache.flink.annotation.Public;
import org.apache.flink.annotation.PublicEvolving;
import org.apache.flink.api.common.functions.AggregateFunction;
import org.apache.flink.api.common.functions.CoGroupFunction;
import org.apache.flink.api.common.functions.CrossFunction;
import org.apache.flink.api.common.functions.FlatJoinFunction;
import org.apache.flink.api.common.functions.FlatMapFunction;
import org.apache.flink.api.common.functions.Function;
import org.apache.flink.api.common.functions.GroupCombineFunction;
import org.apache.flink.api.common.functions.GroupReduceFunction;
import org.apache.flink.api.common.functions.InvalidTypesException;
import org.apache.flink.api.common.functions.JoinFunction;
import org.apache.flink.api.common.functions.MapFunction;
import org.apache.flink.api.common.functions.MapPartitionFunction;
import org.apache.flink.api.common.functions.Partitioner;
import org.apache.flink.api.common.io.InputFormat;
import org.apache.flink.api.common.typeinfo.BasicArrayTypeInfo;
import org.apache.flink.api.common.typeinfo.BasicTypeInfo;
import org.apache.flink.api.common.typeinfo.PrimitiveArrayTypeInfo;
import org.apache.flink.api.common.typeinfo.SqlTimeTypeInfo;
import org.apache.flink.api.common.typeinfo.TypeInfo;
import org.apache.flink.api.common.typeinfo.TypeInfoFactory;
import org.apache.flink.api.common.typeinfo.TypeInformation;
import org.apache.flink.api.common.typeutils.CompositeType;
import org.apache.flink.api.java.functions.KeySelector;
import org.apache.flink.api.java.tuple.Tuple;
import org.apache.flink.api.java.tuple.Tuple0;
import org.apache.flink.api.java.typeutils.TypeExtractionUtils.LambdaExecutable;
import org.apache.flink.types.Row;
import org.apache.flink.types.Value;
import org.apache.flink.util.InstantiationUtil;
import org.apache.flink.util.Preconditions;

import org.apache.commons.lang3.ClassUtils;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.lang.reflect.Constructor;
import java.lang.reflect.Field;
import java.lang.reflect.GenericArrayType;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.lang.reflect.Modifier;
import java.lang.reflect.ParameterizedType;
import java.lang.reflect.Type;
import java.lang.reflect.TypeVariable;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;

import static org.apache.flink.api.java.typeutils.TypeExtractionUtils.checkAndExtractLambda;
import static org.apache.flink.api.java.typeutils.TypeExtractionUtils.getAllDeclaredMethods;
import static org.apache.flink.api.java.typeutils.TypeExtractionUtils.getTypeHierarchy;
import static org.apache.flink.api.java.typeutils.TypeExtractionUtils.hasSuperclass;
import static org.apache.flink.api.java.typeutils.TypeExtractionUtils.isClassType;
import static org.apache.flink.api.java.typeutils.TypeExtractionUtils.sameTypeVars;
import static org.apache.flink.api.java.typeutils.TypeExtractionUtils.typeToClass;
import static org.apache.flink.util.Preconditions.checkNotNull;

/**
 * A utility for reflection analysis on classes, to determine the return type of implementations of
 * transformation functions.
 *
 * &lt;p&gt;NOTES FOR USERS OF THIS CLASS: Automatic type extraction is a hacky business that depends on a
 * lot of variables such as generics, compiler, interfaces, etc. The type extraction fails regularly
 * with either {@link MissingTypeInfo} or hard exceptions. Whenever you use methods of this class,
 * make sure to provide a way to pass custom type information as a fallback.
 */
<span class="fc bfc" id="L93" title="All 2 branches covered.">@Public</span>
public class TypeExtractor {

    /*
     * NOTE: Most methods of the TypeExtractor work with a so-called &quot;typeHierarchy&quot;.
     * The type hierarchy describes all types (Classes, ParameterizedTypes, TypeVariables etc. ) and intermediate
     * types from a given type of a function or type (e.g. MyMapper, Tuple2) until a current type
     * (depends on the method, e.g. MyPojoFieldType).
     *
     * Thus, it fully qualifies types until tuple/POJO field level.
     *
     * A typical typeHierarchy could look like:
     *
     * UDF: MyMapFunction.class
     * top-level UDF: MyMapFunctionBase.class
     * RichMapFunction: RichMapFunction.class
     * MapFunction: MapFunction.class
     * Function's OUT: Tuple1&lt;MyPojo&gt;
     * user-defined POJO: MyPojo.class
     * user-defined top-level POJO: MyPojoBase.class
     * POJO field: Tuple1&lt;String&gt;
     * Field type: String.class
     *
     */

    /** The name of the class representing Hadoop's writable */
    private static final String HADOOP_WRITABLE_CLASS = &quot;org.apache.hadoop.io.Writable&quot;;

    private static final String HADOOP_WRITABLE_TYPEINFO_CLASS =
            &quot;org.apache.flink.api.java.typeutils.WritableTypeInfo&quot;;

    private static final String AVRO_SPECIFIC_RECORD_BASE_CLASS =
            &quot;org.apache.avro.specific.SpecificRecordBase&quot;;

<span class="fc" id="L127">    private static final Logger LOG = LoggerFactory.getLogger(TypeExtractor.class);</span>

<span class="fc" id="L129">    public static final int[] NO_INDEX = new int[] {};</span>

<span class="fc" id="L131">    protected TypeExtractor() {</span>
        // only create instances for special use cases
<span class="fc" id="L133">    }</span>

    // --------------------------------------------------------------------------------------------
    //  Function specific methods
    // --------------------------------------------------------------------------------------------

    @PublicEvolving
    public static &lt;IN, OUT&gt; TypeInformation&lt;OUT&gt; getMapReturnTypes(
            MapFunction&lt;IN, OUT&gt; mapInterface, TypeInformation&lt;IN&gt; inType) {
<span class="fc" id="L142">        return getMapReturnTypes(mapInterface, inType, null, false);</span>
    }

    @PublicEvolving
    public static &lt;IN, OUT&gt; TypeInformation&lt;OUT&gt; getMapReturnTypes(
            MapFunction&lt;IN, OUT&gt; mapInterface,
            TypeInformation&lt;IN&gt; inType,
            String functionName,
            boolean allowMissing) {
<span class="fc" id="L151">        return getUnaryOperatorReturnType(</span>
                mapInterface,
                MapFunction.class,
                0,
                1,
                NO_INDEX,
                inType,
                functionName,
                allowMissing);
    }

    @PublicEvolving
    public static &lt;IN, OUT&gt; TypeInformation&lt;OUT&gt; getFlatMapReturnTypes(
            FlatMapFunction&lt;IN, OUT&gt; flatMapInterface, TypeInformation&lt;IN&gt; inType) {
<span class="fc" id="L165">        return getFlatMapReturnTypes(flatMapInterface, inType, null, false);</span>
    }

    @PublicEvolving
    public static &lt;IN, OUT&gt; TypeInformation&lt;OUT&gt; getFlatMapReturnTypes(
            FlatMapFunction&lt;IN, OUT&gt; flatMapInterface,
            TypeInformation&lt;IN&gt; inType,
            String functionName,
            boolean allowMissing) {
<span class="fc" id="L174">        return getUnaryOperatorReturnType(</span>
                flatMapInterface,
                FlatMapFunction.class,
                0,
                1,
                new int[] {1, 0},
                inType,
                functionName,
                allowMissing);
    }

    @PublicEvolving
    public static &lt;IN, ACC&gt; TypeInformation&lt;ACC&gt; getAggregateFunctionAccumulatorType(
            AggregateFunction&lt;IN, ACC, ?&gt; function,
            TypeInformation&lt;IN&gt; inType,
            String functionName,
            boolean allowMissing) {
<span class="nc" id="L191">        return getUnaryOperatorReturnType(</span>
                function,
                AggregateFunction.class,
                0,
                1,
                NO_INDEX,
                inType,
                functionName,
                allowMissing);
    }

    @PublicEvolving
    public static &lt;IN, OUT&gt; TypeInformation&lt;OUT&gt; getAggregateFunctionReturnType(
            AggregateFunction&lt;IN, ?, OUT&gt; function,
            TypeInformation&lt;IN&gt; inType,
            String functionName,
            boolean allowMissing) {
<span class="nc" id="L208">        return getUnaryOperatorReturnType(</span>
                function,
                AggregateFunction.class,
                0,
                2,
                NO_INDEX,
                inType,
                functionName,
                allowMissing);
    }

    @PublicEvolving
    public static &lt;IN, OUT&gt; TypeInformation&lt;OUT&gt; getMapPartitionReturnTypes(
            MapPartitionFunction&lt;IN, OUT&gt; mapPartitionInterface, TypeInformation&lt;IN&gt; inType) {
<span class="nc" id="L222">        return getMapPartitionReturnTypes(mapPartitionInterface, inType, null, false);</span>
    }

    @PublicEvolving
    public static &lt;IN, OUT&gt; TypeInformation&lt;OUT&gt; getMapPartitionReturnTypes(
            MapPartitionFunction&lt;IN, OUT&gt; mapPartitionInterface,
            TypeInformation&lt;IN&gt; inType,
            String functionName,
            boolean allowMissing) {
<span class="fc" id="L231">        return getUnaryOperatorReturnType(</span>
                mapPartitionInterface,
                MapPartitionFunction.class,
                0,
                1,
                new int[] {1, 0},
                inType,
                functionName,
                allowMissing);
    }

    @PublicEvolving
    public static &lt;IN, OUT&gt; TypeInformation&lt;OUT&gt; getGroupReduceReturnTypes(
            GroupReduceFunction&lt;IN, OUT&gt; groupReduceInterface, TypeInformation&lt;IN&gt; inType) {
<span class="fc" id="L245">        return getGroupReduceReturnTypes(groupReduceInterface, inType, null, false);</span>
    }

    @PublicEvolving
    public static &lt;IN, OUT&gt; TypeInformation&lt;OUT&gt; getGroupReduceReturnTypes(
            GroupReduceFunction&lt;IN, OUT&gt; groupReduceInterface,
            TypeInformation&lt;IN&gt; inType,
            String functionName,
            boolean allowMissing) {
<span class="fc" id="L254">        return getUnaryOperatorReturnType(</span>
                groupReduceInterface,
                GroupReduceFunction.class,
                0,
                1,
                new int[] {1, 0},
                inType,
                functionName,
                allowMissing);
    }

    @PublicEvolving
    public static &lt;IN, OUT&gt; TypeInformation&lt;OUT&gt; getGroupCombineReturnTypes(
            GroupCombineFunction&lt;IN, OUT&gt; combineInterface, TypeInformation&lt;IN&gt; inType) {
<span class="nc" id="L268">        return getGroupCombineReturnTypes(combineInterface, inType, null, false);</span>
    }

    @PublicEvolving
    public static &lt;IN, OUT&gt; TypeInformation&lt;OUT&gt; getGroupCombineReturnTypes(
            GroupCombineFunction&lt;IN, OUT&gt; combineInterface,
            TypeInformation&lt;IN&gt; inType,
            String functionName,
            boolean allowMissing) {
<span class="nc" id="L277">        return getUnaryOperatorReturnType(</span>
                combineInterface,
                GroupCombineFunction.class,
                0,
                1,
                new int[] {1, 0},
                inType,
                functionName,
                allowMissing);
    }

    @PublicEvolving
    public static &lt;IN1, IN2, OUT&gt; TypeInformation&lt;OUT&gt; getFlatJoinReturnTypes(
            FlatJoinFunction&lt;IN1, IN2, OUT&gt; joinInterface,
            TypeInformation&lt;IN1&gt; in1Type,
            TypeInformation&lt;IN2&gt; in2Type) {
<span class="fc" id="L293">        return getFlatJoinReturnTypes(joinInterface, in1Type, in2Type, null, false);</span>
    }

    @PublicEvolving
    public static &lt;IN1, IN2, OUT&gt; TypeInformation&lt;OUT&gt; getFlatJoinReturnTypes(
            FlatJoinFunction&lt;IN1, IN2, OUT&gt; joinInterface,
            TypeInformation&lt;IN1&gt; in1Type,
            TypeInformation&lt;IN2&gt; in2Type,
            String functionName,
            boolean allowMissing) {
<span class="fc" id="L303">        return getBinaryOperatorReturnType(</span>
                joinInterface,
                FlatJoinFunction.class,
                0,
                1,
                2,
                new int[] {2, 0},
                in1Type,
                in2Type,
                functionName,
                allowMissing);
    }

    @PublicEvolving
    public static &lt;IN1, IN2, OUT&gt; TypeInformation&lt;OUT&gt; getJoinReturnTypes(
            JoinFunction&lt;IN1, IN2, OUT&gt; joinInterface,
            TypeInformation&lt;IN1&gt; in1Type,
            TypeInformation&lt;IN2&gt; in2Type) {
<span class="fc" id="L321">        return getJoinReturnTypes(joinInterface, in1Type, in2Type, null, false);</span>
    }

    @PublicEvolving
    public static &lt;IN1, IN2, OUT&gt; TypeInformation&lt;OUT&gt; getJoinReturnTypes(
            JoinFunction&lt;IN1, IN2, OUT&gt; joinInterface,
            TypeInformation&lt;IN1&gt; in1Type,
            TypeInformation&lt;IN2&gt; in2Type,
            String functionName,
            boolean allowMissing) {
<span class="fc" id="L331">        return getBinaryOperatorReturnType(</span>
                joinInterface,
                JoinFunction.class,
                0,
                1,
                2,
                NO_INDEX,
                in1Type,
                in2Type,
                functionName,
                allowMissing);
    }

    @PublicEvolving
    public static &lt;IN1, IN2, OUT&gt; TypeInformation&lt;OUT&gt; getCoGroupReturnTypes(
            CoGroupFunction&lt;IN1, IN2, OUT&gt; coGroupInterface,
            TypeInformation&lt;IN1&gt; in1Type,
            TypeInformation&lt;IN2&gt; in2Type) {
<span class="fc" id="L349">        return getCoGroupReturnTypes(coGroupInterface, in1Type, in2Type, null, false);</span>
    }

    @PublicEvolving
    public static &lt;IN1, IN2, OUT&gt; TypeInformation&lt;OUT&gt; getCoGroupReturnTypes(
            CoGroupFunction&lt;IN1, IN2, OUT&gt; coGroupInterface,
            TypeInformation&lt;IN1&gt; in1Type,
            TypeInformation&lt;IN2&gt; in2Type,
            String functionName,
            boolean allowMissing) {
<span class="fc" id="L359">        return getBinaryOperatorReturnType(</span>
                coGroupInterface,
                CoGroupFunction.class,
                0,
                1,
                2,
                new int[] {2, 0},
                in1Type,
                in2Type,
                functionName,
                allowMissing);
    }

    @PublicEvolving
    public static &lt;IN1, IN2, OUT&gt; TypeInformation&lt;OUT&gt; getCrossReturnTypes(
            CrossFunction&lt;IN1, IN2, OUT&gt; crossInterface,
            TypeInformation&lt;IN1&gt; in1Type,
            TypeInformation&lt;IN2&gt; in2Type) {
<span class="fc" id="L377">        return getCrossReturnTypes(crossInterface, in1Type, in2Type, null, false);</span>
    }

    @PublicEvolving
    public static &lt;IN1, IN2, OUT&gt; TypeInformation&lt;OUT&gt; getCrossReturnTypes(
            CrossFunction&lt;IN1, IN2, OUT&gt; crossInterface,
            TypeInformation&lt;IN1&gt; in1Type,
            TypeInformation&lt;IN2&gt; in2Type,
            String functionName,
            boolean allowMissing) {
<span class="fc" id="L387">        return getBinaryOperatorReturnType(</span>
                crossInterface,
                CrossFunction.class,
                0,
                1,
                2,
                NO_INDEX,
                in1Type,
                in2Type,
                functionName,
                allowMissing);
    }

    @PublicEvolving
    public static &lt;IN, OUT&gt; TypeInformation&lt;OUT&gt; getKeySelectorTypes(
            KeySelector&lt;IN, OUT&gt; selectorInterface, TypeInformation&lt;IN&gt; inType) {
<span class="fc" id="L403">        return getKeySelectorTypes(selectorInterface, inType, null, false);</span>
    }

    @PublicEvolving
    public static &lt;IN, OUT&gt; TypeInformation&lt;OUT&gt; getKeySelectorTypes(
            KeySelector&lt;IN, OUT&gt; selectorInterface,
            TypeInformation&lt;IN&gt; inType,
            String functionName,
            boolean allowMissing) {
<span class="fc" id="L412">        return getUnaryOperatorReturnType(</span>
                selectorInterface,
                KeySelector.class,
                0,
                1,
                NO_INDEX,
                inType,
                functionName,
                allowMissing);
    }

    @PublicEvolving
    public static &lt;T&gt; TypeInformation&lt;T&gt; getPartitionerTypes(Partitioner&lt;T&gt; partitioner) {
<span class="nc" id="L425">        return getPartitionerTypes(partitioner, null, false);</span>
    }

    @PublicEvolving
    public static &lt;T&gt; TypeInformation&lt;T&gt; getPartitionerTypes(
            Partitioner&lt;T&gt; partitioner, String functionName, boolean allowMissing) {

<span class="fc" id="L432">        return getUnaryOperatorReturnType(</span>
                partitioner,
                Partitioner.class,
                -1,
                0,
                new int[] {0},
                null,
                functionName,
                allowMissing);
    }

    @SuppressWarnings(&quot;unchecked&quot;)
    @PublicEvolving
    public static &lt;IN&gt; TypeInformation&lt;IN&gt; getInputFormatTypes(
            InputFormat&lt;IN, ?&gt; inputFormatInterface) {
<span class="fc bfc" id="L447" title="All 2 branches covered.">        if (inputFormatInterface instanceof ResultTypeQueryable) {</span>
<span class="fc" id="L448">            return ((ResultTypeQueryable&lt;IN&gt;) inputFormatInterface).getProducedType();</span>
        }
<span class="fc" id="L450">        return new TypeExtractor()</span>
<span class="fc" id="L451">                .privateCreateTypeInfo(</span>
<span class="fc" id="L452">                        InputFormat.class, inputFormatInterface.getClass(), 0, null, null);</span>
    }

    // --------------------------------------------------------------------------------------------
    //  Generic extraction methods
    // --------------------------------------------------------------------------------------------

    /**
     * Returns the unary operator's return type.
     *
     * &lt;p&gt;This method can extract a type in 4 different ways:
     *
     * &lt;p&gt;1. By using the generics of the base class like MyFunction&lt;X, Y, Z, IN, OUT&gt;. This is what
     * outputTypeArgumentIndex (in this example &quot;4&quot;) is good for.
     *
     * &lt;p&gt;2. By using input type inference SubMyFunction&lt;T, String, String, String, T&gt;. This is what
     * inputTypeArgumentIndex (in this example &quot;0&quot;) and inType is good for.
     *
     * &lt;p&gt;3. By using the static method that a compiler generates for Java lambdas. This is what
     * lambdaOutputTypeArgumentIndices is good for. Given that MyFunction has the following single
     * abstract method:
     *
     * &lt;pre&gt;
     * &lt;code&gt;
     * void apply(IN value, Collector&lt;OUT&gt; value)
     * &lt;/code&gt;
     * &lt;/pre&gt;
     *
     * &lt;p&gt;Lambda type indices allow the extraction of a type from lambdas. To extract the output
     * type &lt;b&gt;OUT&lt;/b&gt; from the function one should pass {@code new int[] {1, 0}}. &quot;1&quot; for selecting
     * the parameter and 0 for the first generic in this type. Use {@code TypeExtractor.NO_INDEX}
     * for selecting the return type of the lambda for extraction or if the class cannot be a lambda
     * because it is not a single abstract method interface.
     *
     * &lt;p&gt;4. By using interfaces such as {@link TypeInfoFactory} or {@link ResultTypeQueryable}.
     *
     * &lt;p&gt;See also comments in the header of this class.
     *
     * @param function Function to extract the return type from
     * @param baseClass Base class of the function
     * @param inputTypeArgumentIndex Index of input generic type in the base class specification
     *     (ignored if inType is null)
     * @param outputTypeArgumentIndex Index of output generic type in the base class specification
     * @param lambdaOutputTypeArgumentIndices Table of indices of the type argument specifying the
     *     input type. See example.
     * @param inType Type of the input elements (In case of an iterable, it is the element type) or
     *     null
     * @param functionName Function name
     * @param allowMissing Can the type information be missing (this generates a MissingTypeInfo for
     *     postponing an exception)
     * @param &lt;IN&gt; Input type
     * @param &lt;OUT&gt; Output type
     * @return TypeInformation of the return type of the function
     */
    @SuppressWarnings(&quot;unchecked&quot;)
    @PublicEvolving
    public static &lt;IN, OUT&gt; TypeInformation&lt;OUT&gt; getUnaryOperatorReturnType(
            Function function,
            Class&lt;?&gt; baseClass,
            int inputTypeArgumentIndex,
            int outputTypeArgumentIndex,
            int[] lambdaOutputTypeArgumentIndices,
            TypeInformation&lt;IN&gt; inType,
            String functionName,
            boolean allowMissing) {

<span class="pc bpc" id="L518" title="1 of 4 branches missed.">        Preconditions.checkArgument(</span>
                inType == null || inputTypeArgumentIndex &gt;= 0,
                &quot;Input type argument index was not provided&quot;);
<span class="pc bpc" id="L521" title="1 of 2 branches missed.">        Preconditions.checkArgument(</span>
                outputTypeArgumentIndex &gt;= 0, &quot;Output type argument index was not provided&quot;);
<span class="pc bpc" id="L523" title="1 of 2 branches missed.">        Preconditions.checkArgument(</span>
                lambdaOutputTypeArgumentIndices != null,
                &quot;Indices for output type arguments within lambda not provided&quot;);

        // explicit result type has highest precedence
<span class="fc bfc" id="L528" title="All 2 branches covered.">        if (function instanceof ResultTypeQueryable) {</span>
<span class="fc" id="L529">            return ((ResultTypeQueryable&lt;OUT&gt;) function).getProducedType();</span>
        }

        // perform extraction
        try {
            final LambdaExecutable exec;
            try {
<span class="fc" id="L536">                exec = checkAndExtractLambda(function);</span>
<span class="nc" id="L537">            } catch (TypeExtractionException e) {</span>
<span class="nc" id="L538">                throw new InvalidTypesException(&quot;Internal error occurred.&quot;, e);</span>
<span class="fc" id="L539">            }</span>
<span class="fc bfc" id="L540" title="All 2 branches covered.">            if (exec != null) {</span>

                // parameters must be accessed from behind, since JVM can add additional parameters
                // e.g. when using local variables inside lambda function
                // paramLen is the total number of parameters of the provided lambda, it includes
                // parameters added through closure
<span class="fc" id="L546">                final int paramLen = exec.getParameterTypes().length;</span>

<span class="fc" id="L548">                final Method sam = TypeExtractionUtils.getSingleAbstractMethod(baseClass);</span>

                // number of parameters the SAM of implemented interface has; the parameter indexing
                // applies to this range
<span class="fc" id="L552">                final int baseParametersLen = sam.getParameterTypes().length;</span>

                final Type output;
<span class="fc bfc" id="L555" title="All 2 branches covered.">                if (lambdaOutputTypeArgumentIndices.length &gt; 0) {</span>
<span class="fc" id="L556">                    output =</span>
<span class="nc" id="L557">                            TypeExtractionUtils.extractTypeFromLambda(</span>
                                    baseClass,
                                    exec,
                                    lambdaOutputTypeArgumentIndices,
                                    paramLen,
                                    baseParametersLen);
                } else {
<span class="fc" id="L564">                    output = exec.getReturnType();</span>
<span class="fc" id="L565">                    TypeExtractionUtils.validateLambdaType(baseClass, output);</span>
                }

<span class="fc" id="L568">                return new TypeExtractor().privateCreateTypeInfo(output, inType, null);</span>
            } else {
<span class="fc bfc" id="L570" title="All 2 branches covered.">                if (inType != null) {</span>
<span class="fc" id="L571">                    validateInputType(</span>
<span class="fc" id="L572">                            baseClass, function.getClass(), inputTypeArgumentIndex, inType);</span>
                }
<span class="fc" id="L574">                return new TypeExtractor()</span>
<span class="fc" id="L575">                        .privateCreateTypeInfo(</span>
                                baseClass,
<span class="fc" id="L577">                                function.getClass(),</span>
                                outputTypeArgumentIndex,
                                inType,
                                null);
            }
<span class="fc" id="L582">        } catch (InvalidTypesException e) {</span>
<span class="fc bfc" id="L583" title="All 2 branches covered.">            if (allowMissing) {</span>
<span class="fc bfc" id="L584" title="All 2 branches covered.">                return (TypeInformation&lt;OUT&gt;)</span>
                        new MissingTypeInfo(
<span class="fc" id="L586">                                functionName != null ? functionName : function.toString(), e);</span>
            } else {
<span class="fc" id="L588">                throw e;</span>
            }
        }
    }

    /**
     * Returns the binary operator's return type.
     *
     * &lt;p&gt;This method can extract a type in 4 different ways:
     *
     * &lt;p&gt;1. By using the generics of the base class like MyFunction&lt;X, Y, Z, IN, OUT&gt;. This is what
     * outputTypeArgumentIndex (in this example &quot;4&quot;) is good for.
     *
     * &lt;p&gt;2. By using input type inference SubMyFunction&lt;T, String, String, String, T&gt;. This is what
     * inputTypeArgumentIndex (in this example &quot;0&quot;) and inType is good for.
     *
     * &lt;p&gt;3. By using the static method that a compiler generates for Java lambdas. This is what
     * lambdaOutputTypeArgumentIndices is good for. Given that MyFunction has the following single
     * abstract method:
     *
     * &lt;pre&gt;
     * &lt;code&gt;
     * void apply(IN value, Collector&lt;OUT&gt; value)
     * &lt;/code&gt;
     * &lt;/pre&gt;
     *
     * &lt;p&gt;Lambda type indices allow the extraction of a type from lambdas. To extract the output
     * type &lt;b&gt;OUT&lt;/b&gt; from the function one should pass {@code new int[] {1, 0}}. &quot;1&quot; for selecting
     * the parameter and 0 for the first generic in this type. Use {@code TypeExtractor.NO_INDEX}
     * for selecting the return type of the lambda for extraction or if the class cannot be a lambda
     * because it is not a single abstract method interface.
     *
     * &lt;p&gt;4. By using interfaces such as {@link TypeInfoFactory} or {@link ResultTypeQueryable}.
     *
     * &lt;p&gt;See also comments in the header of this class.
     *
     * @param function Function to extract the return type from
     * @param baseClass Base class of the function
     * @param input1TypeArgumentIndex Index of first input generic type in the class specification
     *     (ignored if in1Type is null)
     * @param input2TypeArgumentIndex Index of second input generic type in the class specification
     *     (ignored if in2Type is null)
     * @param outputTypeArgumentIndex Index of output generic type in the class specification
     * @param lambdaOutputTypeArgumentIndices Table of indices of the type argument specifying the
     *     output type. See example.
     * @param in1Type Type of the left side input elements (In case of an iterable, it is the
     *     element type)
     * @param in2Type Type of the right side input elements (In case of an iterable, it is the
     *     element type)
     * @param functionName Function name
     * @param allowMissing Can the type information be missing (this generates a MissingTypeInfo for
     *     postponing an exception)
     * @param &lt;IN1&gt; Left side input type
     * @param &lt;IN2&gt; Right side input type
     * @param &lt;OUT&gt; Output type
     * @return TypeInformation of the return type of the function
     */
    @SuppressWarnings(&quot;unchecked&quot;)
    @PublicEvolving
    public static &lt;IN1, IN2, OUT&gt; TypeInformation&lt;OUT&gt; getBinaryOperatorReturnType(
            Function function,
            Class&lt;?&gt; baseClass,
            int input1TypeArgumentIndex,
            int input2TypeArgumentIndex,
            int outputTypeArgumentIndex,
            int[] lambdaOutputTypeArgumentIndices,
            TypeInformation&lt;IN1&gt; in1Type,
            TypeInformation&lt;IN2&gt; in2Type,
            String functionName,
            boolean allowMissing) {

<span class="pc bpc" id="L659" title="2 of 4 branches missed.">        Preconditions.checkArgument(</span>
                in1Type == null || input1TypeArgumentIndex &gt;= 0,
                &quot;Input 1 type argument index was not provided&quot;);
<span class="pc bpc" id="L662" title="2 of 4 branches missed.">        Preconditions.checkArgument(</span>
                in2Type == null || input2TypeArgumentIndex &gt;= 0,
                &quot;Input 2 type argument index was not provided&quot;);
<span class="pc bpc" id="L665" title="1 of 2 branches missed.">        Preconditions.checkArgument(</span>
                outputTypeArgumentIndex &gt;= 0, &quot;Output type argument index was not provided&quot;);
<span class="pc bpc" id="L667" title="1 of 2 branches missed.">        Preconditions.checkArgument(</span>
                lambdaOutputTypeArgumentIndices != null,
                &quot;Indices for output type arguments within lambda not provided&quot;);

        // explicit result type has highest precedence
<span class="pc bpc" id="L672" title="1 of 2 branches missed.">        if (function instanceof ResultTypeQueryable) {</span>
<span class="nc" id="L673">            return ((ResultTypeQueryable&lt;OUT&gt;) function).getProducedType();</span>
        }

        // perform extraction
        try {
            final LambdaExecutable exec;
            try {
<span class="fc" id="L680">                exec = checkAndExtractLambda(function);</span>
<span class="nc" id="L681">            } catch (TypeExtractionException e) {</span>
<span class="nc" id="L682">                throw new InvalidTypesException(&quot;Internal error occurred.&quot;, e);</span>
<span class="fc" id="L683">            }</span>
<span class="fc bfc" id="L684" title="All 2 branches covered.">            if (exec != null) {</span>

<span class="fc" id="L686">                final Method sam = TypeExtractionUtils.getSingleAbstractMethod(baseClass);</span>
<span class="fc" id="L687">                final int baseParametersLen = sam.getParameterTypes().length;</span>

                // parameters must be accessed from behind, since JVM can add additional parameters
                // e.g. when using local variables inside lambda function
<span class="fc" id="L691">                final int paramLen = exec.getParameterTypes().length;</span>

                final Type output;
<span class="fc bfc" id="L694" title="All 2 branches covered.">                if (lambdaOutputTypeArgumentIndices.length &gt; 0) {</span>
<span class="fc" id="L695">                    output =</span>
<span class="nc" id="L696">                            TypeExtractionUtils.extractTypeFromLambda(</span>
                                    baseClass,
                                    exec,
                                    lambdaOutputTypeArgumentIndices,
                                    paramLen,
                                    baseParametersLen);
                } else {
<span class="fc" id="L703">                    output = exec.getReturnType();</span>
<span class="nc" id="L704">                    TypeExtractionUtils.validateLambdaType(baseClass, output);</span>
                }

<span class="nc" id="L707">                return new TypeExtractor().privateCreateTypeInfo(output, in1Type, in2Type);</span>
            } else {
<span class="pc bpc" id="L709" title="1 of 2 branches missed.">                if (in1Type != null) {</span>
<span class="fc" id="L710">                    validateInputType(</span>
<span class="fc" id="L711">                            baseClass, function.getClass(), input1TypeArgumentIndex, in1Type);</span>
                }
<span class="pc bpc" id="L713" title="1 of 2 branches missed.">                if (in2Type != null) {</span>
<span class="fc" id="L714">                    validateInputType(</span>
<span class="fc" id="L715">                            baseClass, function.getClass(), input2TypeArgumentIndex, in2Type);</span>
                }
<span class="fc" id="L717">                return new TypeExtractor()</span>
<span class="fc" id="L718">                        .privateCreateTypeInfo(</span>
                                baseClass,
<span class="fc" id="L720">                                function.getClass(),</span>
                                outputTypeArgumentIndex,
                                in1Type,
                                in2Type);
            }
<span class="fc" id="L725">        } catch (InvalidTypesException e) {</span>
<span class="pc bpc" id="L726" title="1 of 2 branches missed.">            if (allowMissing) {</span>
<span class="pc bpc" id="L727" title="1 of 2 branches missed.">                return (TypeInformation&lt;OUT&gt;)</span>
                        new MissingTypeInfo(
<span class="fc" id="L729">                                functionName != null ? functionName : function.toString(), e);</span>
            } else {
<span class="nc" id="L731">                throw e;</span>
            }
        }
    }

    // --------------------------------------------------------------------------------------------
    //  Create type information
    // --------------------------------------------------------------------------------------------

    @SuppressWarnings(&quot;unchecked&quot;)
    public static &lt;T&gt; TypeInformation&lt;T&gt; createTypeInfo(Class&lt;T&gt; type) {
<span class="fc" id="L742">        return (TypeInformation&lt;T&gt;) createTypeInfo((Type) type);</span>
    }

    public static TypeInformation&lt;?&gt; createTypeInfo(Type t) {
<span class="fc" id="L746">        TypeInformation&lt;?&gt; ti = new TypeExtractor().privateCreateTypeInfo(t);</span>
<span class="pc bpc" id="L747" title="1 of 2 branches missed.">        if (ti == null) {</span>
<span class="nc" id="L748">            throw new InvalidTypesException(&quot;Could not extract type information.&quot;);</span>
        }
<span class="fc" id="L750">        return ti;</span>
    }

    /**
     * Creates a {@link TypeInformation} from the given parameters.
     *
     * &lt;p&gt;If the given {@code instance} implements {@link ResultTypeQueryable}, its information is
     * used to determine the type information. Otherwise, the type information is derived based on
     * the given class information.
     *
     * @param instance instance to determine type information for
     * @param baseClass base class of {@code instance}
     * @param clazz class of {@code instance}
     * @param returnParamPos index of the return type in the type arguments of {@code clazz}
     * @param &lt;OUT&gt; output type
     * @return type information
     */
    @SuppressWarnings(&quot;unchecked&quot;)
    @PublicEvolving
    public static &lt;OUT&gt; TypeInformation&lt;OUT&gt; createTypeInfo(
            Object instance, Class&lt;?&gt; baseClass, Class&lt;?&gt; clazz, int returnParamPos) {
<span class="fc bfc" id="L771" title="All 2 branches covered.">        if (instance instanceof ResultTypeQueryable) {</span>
<span class="fc" id="L772">            return ((ResultTypeQueryable&lt;OUT&gt;) instance).getProducedType();</span>
        } else {
<span class="fc" id="L774">            return createTypeInfo(baseClass, clazz, returnParamPos, null, null);</span>
        }
    }

    @PublicEvolving
    public static &lt;IN1, IN2, OUT&gt; TypeInformation&lt;OUT&gt; createTypeInfo(
            Class&lt;?&gt; baseClass,
            Class&lt;?&gt; clazz,
            int returnParamPos,
            TypeInformation&lt;IN1&gt; in1Type,
            TypeInformation&lt;IN2&gt; in2Type) {
<span class="fc" id="L785">        TypeInformation&lt;OUT&gt; ti =</span>
                new TypeExtractor()
<span class="fc" id="L787">                        .privateCreateTypeInfo(baseClass, clazz, returnParamPos, in1Type, in2Type);</span>
<span class="pc bpc" id="L788" title="1 of 2 branches missed.">        if (ti == null) {</span>
<span class="nc" id="L789">            throw new InvalidTypesException(&quot;Could not extract type information.&quot;);</span>
        }
<span class="fc" id="L791">        return ti;</span>
    }

    // ----------------------------------- private methods ----------------------------------------

    private TypeInformation&lt;?&gt; privateCreateTypeInfo(Type t) {
<span class="fc" id="L797">        List&lt;Type&gt; typeHierarchy = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L798">        typeHierarchy.add(t);</span>
<span class="fc" id="L799">        return createTypeInfoWithTypeHierarchy(typeHierarchy, t, null, null);</span>
    }

    // for (Rich)Functions
    @SuppressWarnings(&quot;unchecked&quot;)
    private &lt;IN1, IN2, OUT&gt; TypeInformation&lt;OUT&gt; privateCreateTypeInfo(
            Class&lt;?&gt; baseClass,
            Class&lt;?&gt; clazz,
            int returnParamPos,
            TypeInformation&lt;IN1&gt; in1Type,
            TypeInformation&lt;IN2&gt; in2Type) {
<span class="fc" id="L810">        List&lt;Type&gt; typeHierarchy = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L811">        Type returnType = getParameterType(baseClass, typeHierarchy, clazz, returnParamPos);</span>

        TypeInformation&lt;OUT&gt; typeInfo;

        // return type is a variable -&gt; try to get the type info from the input directly
<span class="fc bfc" id="L816" title="All 2 branches covered.">        if (returnType instanceof TypeVariable&lt;?&gt;) {</span>
<span class="fc" id="L817">            typeInfo =</span>
                    (TypeInformation&lt;OUT&gt;)
<span class="fc" id="L819">                            createTypeInfoFromInputs(</span>
                                    (TypeVariable&lt;?&gt;) returnType, typeHierarchy, in1Type, in2Type);

<span class="fc bfc" id="L822" title="All 2 branches covered.">            if (typeInfo != null) {</span>
<span class="fc" id="L823">                return typeInfo;</span>
            }
        }

        // get info from hierarchy
<span class="fc" id="L828">        return createTypeInfoWithTypeHierarchy(typeHierarchy, returnType, in1Type, in2Type);</span>
    }

    // for LambdaFunctions
    private &lt;IN1, IN2, OUT&gt; TypeInformation&lt;OUT&gt; privateCreateTypeInfo(
            Type returnType, TypeInformation&lt;IN1&gt; in1Type, TypeInformation&lt;IN2&gt; in2Type) {
<span class="fc" id="L834">        List&lt;Type&gt; typeHierarchy = new ArrayList&lt;&gt;();</span>

        // get info from hierarchy
<span class="fc" id="L837">        return createTypeInfoWithTypeHierarchy(typeHierarchy, returnType, in1Type, in2Type);</span>
    }

    @SuppressWarnings({&quot;unchecked&quot;, &quot;rawtypes&quot;})
    private &lt;IN1, IN2, OUT&gt; TypeInformation&lt;OUT&gt; createTypeInfoWithTypeHierarchy(
            List&lt;Type&gt; typeHierarchy,
            Type t,
            TypeInformation&lt;IN1&gt; in1Type,
            TypeInformation&lt;IN2&gt; in2Type) {

        // check if type information can be created using a type factory
<span class="fc" id="L848">        final TypeInformation&lt;OUT&gt; typeFromFactory =</span>
<span class="fc" id="L849">                createTypeInfoFromFactory(t, typeHierarchy, in1Type, in2Type);</span>
<span class="fc bfc" id="L850" title="All 2 branches covered.">        if (typeFromFactory != null) {</span>
<span class="fc" id="L851">            return typeFromFactory;</span>
        }
        // check if type is a subclass of tuple
<span class="fc bfc" id="L854" title="All 4 branches covered.">        else if (isClassType(t) &amp;&amp; Tuple.class.isAssignableFrom(typeToClass(t))) {</span>
<span class="fc" id="L855">            Type curT = t;</span>

            // do not allow usage of Tuple as type
<span class="fc bfc" id="L858" title="All 2 branches covered.">            if (typeToClass(t).equals(Tuple.class)) {</span>
<span class="fc" id="L859">                throw new InvalidTypesException(</span>
                        &quot;Usage of class Tuple as a type is not allowed. Use a concrete subclass (e.g. Tuple1, Tuple2, etc.) instead.&quot;);
            }

            // go up the hierarchy until we reach immediate child of Tuple (with or without
            // generics)
            // collect the types while moving up for a later top-down
<span class="fc" id="L866">            List&lt;Type&gt; typeHierarchyForSubtypes = new ArrayList&lt;&gt;(typeHierarchy);</span>
<span class="pc bpc" id="L867" title="1 of 4 branches missed.">            while (!(isClassType(curT) &amp;&amp; typeToClass(curT).getSuperclass().equals(Tuple.class))) {</span>
<span class="fc" id="L868">                typeHierarchyForSubtypes.add(curT);</span>
<span class="fc" id="L869">                curT = typeToClass(curT).getGenericSuperclass();</span>
            }

<span class="fc bfc" id="L872" title="All 2 branches covered.">            if (curT == Tuple0.class) {</span>
<span class="fc" id="L873">                return new TupleTypeInfo(Tuple0.class);</span>
            }

            // check if immediate child of Tuple has generics
<span class="fc bfc" id="L877" title="All 2 branches covered.">            if (curT instanceof Class&lt;?&gt;) {</span>
<span class="fc" id="L878">                throw new InvalidTypesException(</span>
                        &quot;Tuple needs to be parameterized by using generics.&quot;);
            }

<span class="fc" id="L882">            typeHierarchyForSubtypes.add(curT);</span>

            // create the type information for the subtypes
<span class="fc" id="L885">            final TypeInformation&lt;?&gt;[] subTypesInfo =</span>
<span class="fc" id="L886">                    createSubTypesInfo(</span>
                            t,
                            (ParameterizedType) curT,
                            typeHierarchyForSubtypes,
                            in1Type,
                            in2Type,
                            false);
            // type needs to be treated a pojo due to additional fields
<span class="fc bfc" id="L894" title="All 2 branches covered.">            if (subTypesInfo == null) {</span>
<span class="fc" id="L895">                return analyzePojo(t, new ArrayList&lt;&gt;(typeHierarchy), in1Type, in2Type);</span>
            }
            // return tuple info
<span class="fc" id="L898">            return new TupleTypeInfo(typeToClass(t), subTypesInfo);</span>

        }
        // type depends on another type
        // e.g. class MyMapper&lt;E&gt; extends MapFunction&lt;String, E&gt;
<span class="fc bfc" id="L903" title="All 2 branches covered.">        else if (t instanceof TypeVariable) {</span>
<span class="fc" id="L904">            Type typeVar = materializeTypeVariable(typeHierarchy, (TypeVariable&lt;?&gt;) t);</span>

<span class="fc bfc" id="L906" title="All 2 branches covered.">            if (!(typeVar instanceof TypeVariable)) {</span>
<span class="fc" id="L907">                return createTypeInfoWithTypeHierarchy(typeHierarchy, typeVar, in1Type, in2Type);</span>
            }
            // try to derive the type info of the TypeVariable from the immediate base child input
            // as a last attempt
            else {
<span class="fc" id="L912">                TypeInformation&lt;OUT&gt; typeInfo =</span>
                        (TypeInformation&lt;OUT&gt;)
<span class="fc" id="L914">                                createTypeInfoFromInputs(</span>
                                        (TypeVariable&lt;?&gt;) t, typeHierarchy, in1Type, in2Type);
<span class="fc bfc" id="L916" title="All 2 branches covered.">                if (typeInfo != null) {</span>
<span class="fc" id="L917">                    return typeInfo;</span>
                } else {
<span class="fc" id="L919">                    throw new InvalidTypesException(</span>
                            &quot;Type of TypeVariable '&quot;
<span class="fc" id="L921">                                    + ((TypeVariable&lt;?&gt;) t).getName()</span>
                                    + &quot;' in '&quot;
<span class="fc" id="L923">                                    + ((TypeVariable&lt;?&gt;) t).getGenericDeclaration()</span>
                                    + &quot;' could not be determined. This is most likely a type erasure problem. &quot;
                                    + &quot;The type extraction currently supports types with generic variables only in cases where &quot;
                                    + &quot;all variables in the return type can be deduced from the input type(s). &quot;
                                    + &quot;Otherwise the type has to be specified explicitly using type information.&quot;);
                }
            }
        }
        // arrays with generics
<span class="fc bfc" id="L932" title="All 2 branches covered.">        else if (t instanceof GenericArrayType) {</span>
<span class="fc" id="L933">            GenericArrayType genericArray = (GenericArrayType) t;</span>

<span class="fc" id="L935">            Type componentType = genericArray.getGenericComponentType();</span>

            // due to a Java 6 bug, it is possible that the JVM classifies e.g. String[] or int[] as
            // GenericArrayType instead of Class
<span class="pc bpc" id="L939" title="1 of 2 branches missed.">            if (componentType instanceof Class) {</span>
<span class="nc" id="L940">                Class&lt;?&gt; componentClass = (Class&lt;?&gt;) componentType;</span>

<span class="nc" id="L942">                Class&lt;OUT&gt; classArray =</span>
                        (Class&lt;OUT&gt;)
<span class="nc" id="L944">                                (java.lang.reflect.Array.newInstance(componentClass, 0).getClass());</span>

<span class="nc" id="L946">                return getForClass(classArray);</span>
            } else {
<span class="fc" id="L948">                TypeInformation&lt;?&gt; componentInfo =</span>
<span class="fc" id="L949">                        createTypeInfoWithTypeHierarchy(</span>
                                typeHierarchy,
<span class="fc" id="L951">                                genericArray.getGenericComponentType(),</span>
                                in1Type,
                                in2Type);

<span class="fc" id="L955">                Class&lt;?&gt; componentClass = componentInfo.getTypeClass();</span>
<span class="fc" id="L956">                Class&lt;OUT&gt; classArray =</span>
                        (Class&lt;OUT&gt;)
<span class="fc" id="L958">                                (java.lang.reflect.Array.newInstance(componentClass, 0).getClass());</span>

<span class="fc" id="L960">                return ObjectArrayTypeInfo.getInfoFor(classArray, componentInfo);</span>
            }
        }
        // objects with generics are treated as Class first
<span class="fc bfc" id="L964" title="All 2 branches covered.">        else if (t instanceof ParameterizedType) {</span>
<span class="fc" id="L965">            return privateGetForClass(</span>
<span class="fc" id="L966">                    typeToClass(t), typeHierarchy, (ParameterizedType) t, in1Type, in2Type);</span>
        }
        // no tuple, no TypeVariable, no generic type
<span class="pc bpc" id="L969" title="1 of 2 branches missed.">        else if (t instanceof Class) {</span>
<span class="fc" id="L970">            return privateGetForClass((Class&lt;OUT&gt;) t, typeHierarchy);</span>
        }

<span class="nc" id="L973">        throw new InvalidTypesException(&quot;Type Information could not be created.&quot;);</span>
    }

    private &lt;IN1, IN2&gt; TypeInformation&lt;?&gt; createTypeInfoFromInputs(
            TypeVariable&lt;?&gt; returnTypeVar,
            List&lt;Type&gt; returnTypeHierarchy,
            TypeInformation&lt;IN1&gt; in1TypeInfo,
            TypeInformation&lt;IN2&gt; in2TypeInfo) {

<span class="fc" id="L982">        Type matReturnTypeVar = materializeTypeVariable(returnTypeHierarchy, returnTypeVar);</span>

        // variable could be resolved
<span class="fc bfc" id="L985" title="All 2 branches covered.">        if (!(matReturnTypeVar instanceof TypeVariable)) {</span>
<span class="fc" id="L986">            return createTypeInfoWithTypeHierarchy(</span>
                    returnTypeHierarchy, matReturnTypeVar, in1TypeInfo, in2TypeInfo);
        } else {
<span class="fc" id="L989">            returnTypeVar = (TypeVariable&lt;?&gt;) matReturnTypeVar;</span>
        }

        // no input information exists
<span class="pc bpc" id="L993" title="1 of 4 branches missed.">        if (in1TypeInfo == null &amp;&amp; in2TypeInfo == null) {</span>
<span class="fc" id="L994">            return null;</span>
        }

        // create a new type hierarchy for the input
<span class="fc" id="L998">        List&lt;Type&gt; inputTypeHierarchy = new ArrayList&lt;&gt;();</span>
        // copy the function part of the type hierarchy
<span class="fc bfc" id="L1000" title="All 2 branches covered.">        for (Type t : returnTypeHierarchy) {</span>
<span class="fc" id="L1001">            Class&lt;?&gt; clazz = typeToClass(t);</span>
<span class="pc bpc" id="L1002" title="1 of 2 branches missed.">            if (isClassType(t)</span>
<span class="pc bpc" id="L1003" title="1 of 4 branches missed.">                    &amp;&amp; Function.class.isAssignableFrom(clazz)</span>
                    &amp;&amp; clazz != Function.class) {
<span class="fc" id="L1005">                inputTypeHierarchy.add(t);</span>
            } else {
                break;
            }
<span class="fc" id="L1009">        }</span>

<span class="fc bfc" id="L1011" title="All 2 branches covered.">        if (inputTypeHierarchy.size() == 0) {</span>
<span class="fc" id="L1012">            return null;</span>
        }

<span class="fc" id="L1015">        ParameterizedType baseClass =</span>
<span class="fc" id="L1016">                (ParameterizedType) inputTypeHierarchy.get(inputTypeHierarchy.size() - 1);</span>

<span class="fc" id="L1018">        TypeInformation&lt;?&gt; info = null;</span>
<span class="pc bpc" id="L1019" title="1 of 2 branches missed.">        if (in1TypeInfo != null) {</span>
            // find the deepest type variable that describes the type of input 1
<span class="fc" id="L1021">            Type in1Type = baseClass.getActualTypeArguments()[0];</span>

<span class="fc" id="L1023">            info =</span>
<span class="fc" id="L1024">                    createTypeInfoFromInput(</span>
                            returnTypeVar,
                            new ArrayList&lt;&gt;(inputTypeHierarchy),
                            in1Type,
                            in1TypeInfo);
        }

<span class="pc bpc" id="L1031" title="1 of 4 branches missed.">        if (info == null &amp;&amp; in2TypeInfo != null) {</span>
            // find the deepest type variable that describes the type of input 2
<span class="nc" id="L1033">            Type in2Type = baseClass.getActualTypeArguments()[1];</span>

<span class="nc" id="L1035">            info =</span>
<span class="nc" id="L1036">                    createTypeInfoFromInput(</span>
                            returnTypeVar,
                            new ArrayList&lt;&gt;(inputTypeHierarchy),
                            in2Type,
                            in2TypeInfo);
        }

<span class="fc" id="L1043">        return info;</span>
    }

    /**
     * Finds the type information to a type variable.
     *
     * &lt;p&gt;It solve the following:
     *
     * &lt;p&gt;Return the type information for &quot;returnTypeVar&quot; given that &quot;inType&quot; has type information
     * &quot;inTypeInfo&quot;. Thus &quot;inType&quot; must contain &quot;returnTypeVar&quot; in a &quot;inputTypeHierarchy&quot;, otherwise
     * null is returned.
     */
    private &lt;IN1&gt; TypeInformation&lt;?&gt; createTypeInfoFromInput(
            TypeVariable&lt;?&gt; returnTypeVar,
            List&lt;Type&gt; inputTypeHierarchy,
            Type inType,
            TypeInformation&lt;IN1&gt; inTypeInfo) {
<span class="fc" id="L1060">        TypeInformation&lt;?&gt; info = null;</span>

        // use a factory to find corresponding type information to type variable
<span class="fc" id="L1063">        final List&lt;Type&gt; factoryHierarchy = new ArrayList&lt;&gt;(inputTypeHierarchy);</span>
<span class="fc" id="L1064">        final TypeInfoFactory&lt;?&gt; factory = getClosestFactory(factoryHierarchy, inType);</span>
<span class="fc bfc" id="L1065" title="All 2 branches covered.">        if (factory != null) {</span>
            // the type that defines the factory is last in factory hierarchy
<span class="fc" id="L1067">            final Type factoryDefiningType = factoryHierarchy.get(factoryHierarchy.size() - 1);</span>
            // defining type has generics, the factory need to be asked for a mapping of subtypes to
            // type information
<span class="pc bpc" id="L1070" title="1 of 2 branches missed.">            if (factoryDefiningType instanceof ParameterizedType) {</span>
<span class="fc" id="L1071">                final Type[] typeParams = typeToClass(factoryDefiningType).getTypeParameters();</span>
<span class="fc" id="L1072">                final Type[] actualParams =</span>
<span class="fc" id="L1073">                        ((ParameterizedType) factoryDefiningType).getActualTypeArguments();</span>
                // go thru all elements and search for type variables
<span class="pc bpc" id="L1075" title="1 of 2 branches missed.">                for (int i = 0; i &lt; actualParams.length; i++) {</span>
<span class="fc" id="L1076">                    final Map&lt;String, TypeInformation&lt;?&gt;&gt; componentInfo =</span>
<span class="fc" id="L1077">                            inTypeInfo.getGenericParameters();</span>
<span class="fc" id="L1078">                    final String typeParamName = typeParams[i].toString();</span>
<span class="fc bfc" id="L1079" title="All 2 branches covered.">                    if (!componentInfo.containsKey(typeParamName)</span>
<span class="pc bpc" id="L1080" title="1 of 2 branches missed.">                            || componentInfo.get(typeParamName) == null) {</span>
<span class="fc" id="L1081">                        throw new InvalidTypesException(</span>
                                &quot;TypeInformation '&quot;
<span class="fc" id="L1083">                                        + inTypeInfo.getClass().getSimpleName()</span>
                                        + &quot;' does not supply a mapping of TypeVariable '&quot;
                                        + typeParamName
                                        + &quot;' to corresponding TypeInformation. &quot;
                                        + &quot;Input type inference can only produce a result with this information. &quot;
                                        + &quot;Please implement method 'TypeInformation.getGenericParameters()' for this.&quot;);
                    }
<span class="fc" id="L1090">                    info =</span>
<span class="fc" id="L1091">                            createTypeInfoFromInput(</span>
                                    returnTypeVar,
                                    factoryHierarchy,
                                    actualParams[i],
<span class="fc" id="L1095">                                    componentInfo.get(typeParamName));</span>
<span class="pc bpc" id="L1096" title="1 of 2 branches missed.">                    if (info != null) {</span>
<span class="fc" id="L1097">                        break;</span>
                    }
                }
            }
<span class="fc" id="L1101">        }</span>
        // the input is a type variable
<span class="fc bfc" id="L1103" title="All 2 branches covered.">        else if (sameTypeVars(inType, returnTypeVar)) {</span>
<span class="fc" id="L1104">            return inTypeInfo;</span>
<span class="fc bfc" id="L1105" title="All 2 branches covered.">        } else if (inType instanceof TypeVariable) {</span>
<span class="fc" id="L1106">            Type resolvedInType =</span>
<span class="fc" id="L1107">                    materializeTypeVariable(inputTypeHierarchy, (TypeVariable&lt;?&gt;) inType);</span>
<span class="fc bfc" id="L1108" title="All 2 branches covered.">            if (resolvedInType != inType) {</span>
<span class="fc" id="L1109">                info =</span>
<span class="fc" id="L1110">                        createTypeInfoFromInput(</span>
                                returnTypeVar, inputTypeHierarchy, resolvedInType, inTypeInfo);
            }
<span class="fc" id="L1113">        }</span>
        // input is an array
<span class="fc bfc" id="L1115" title="All 2 branches covered.">        else if (inType instanceof GenericArrayType) {</span>
<span class="fc" id="L1116">            TypeInformation&lt;?&gt; componentInfo = null;</span>
<span class="fc bfc" id="L1117" title="All 2 branches covered.">            if (inTypeInfo instanceof BasicArrayTypeInfo) {</span>
<span class="fc" id="L1118">                componentInfo = ((BasicArrayTypeInfo&lt;?, ?&gt;) inTypeInfo).getComponentInfo();</span>
<span class="pc bpc" id="L1119" title="1 of 2 branches missed.">            } else if (inTypeInfo instanceof PrimitiveArrayTypeInfo) {</span>
<span class="nc" id="L1120">                componentInfo =</span>
<span class="nc" id="L1121">                        BasicTypeInfo.getInfoFor(inTypeInfo.getTypeClass().getComponentType());</span>
<span class="pc bpc" id="L1122" title="1 of 2 branches missed.">            } else if (inTypeInfo instanceof ObjectArrayTypeInfo) {</span>
<span class="fc" id="L1123">                componentInfo = ((ObjectArrayTypeInfo&lt;?, ?&gt;) inTypeInfo).getComponentInfo();</span>
            }
<span class="fc" id="L1125">            info =</span>
<span class="fc" id="L1126">                    createTypeInfoFromInput(</span>
                            returnTypeVar,
                            inputTypeHierarchy,
<span class="fc" id="L1129">                            ((GenericArrayType) inType).getGenericComponentType(),</span>
                            componentInfo);
<span class="fc" id="L1131">        }</span>
        // the input is a tuple
<span class="fc bfc" id="L1133" title="All 2 branches covered.">        else if (inTypeInfo instanceof TupleTypeInfo</span>
<span class="pc bpc" id="L1134" title="1 of 2 branches missed.">                &amp;&amp; isClassType(inType)</span>
<span class="pc bpc" id="L1135" title="1 of 2 branches missed.">                &amp;&amp; Tuple.class.isAssignableFrom(typeToClass(inType))) {</span>
            ParameterizedType tupleBaseClass;

            // get tuple from possible tuple subclass
<span class="pc bpc" id="L1139" title="1 of 2 branches missed.">            while (!(isClassType(inType)</span>
<span class="fc bfc" id="L1140" title="All 2 branches covered.">                    &amp;&amp; typeToClass(inType).getSuperclass().equals(Tuple.class))) {</span>
<span class="fc" id="L1141">                inputTypeHierarchy.add(inType);</span>
<span class="fc" id="L1142">                inType = typeToClass(inType).getGenericSuperclass();</span>
            }
<span class="fc" id="L1144">            inputTypeHierarchy.add(inType);</span>

            // we can assume to be parameterized since we
            // already did input validation
<span class="fc" id="L1148">            tupleBaseClass = (ParameterizedType) inType;</span>

<span class="fc" id="L1150">            Type[] tupleElements = tupleBaseClass.getActualTypeArguments();</span>
            // go thru all tuple elements and search for type variables
<span class="fc bfc" id="L1152" title="All 2 branches covered.">            for (int i = 0; i &lt; tupleElements.length; i++) {</span>
<span class="fc" id="L1153">                info =</span>
<span class="fc" id="L1154">                        createTypeInfoFromInput(</span>
                                returnTypeVar,
                                inputTypeHierarchy,
                                tupleElements[i],
<span class="fc" id="L1158">                                ((TupleTypeInfo&lt;?&gt;) inTypeInfo).getTypeAt(i));</span>
<span class="fc bfc" id="L1159" title="All 2 branches covered.">                if (info != null) {</span>
<span class="fc" id="L1160">                    break;</span>
                }
            }
<span class="fc" id="L1163">        }</span>
        // the input is a pojo
<span class="pc bpc" id="L1165" title="2 of 4 branches missed.">        else if (inTypeInfo instanceof PojoTypeInfo &amp;&amp; isClassType(inType)) {</span>
            // build the entire type hierarchy for the pojo
<span class="fc" id="L1167">            getTypeHierarchy(inputTypeHierarchy, inType, Object.class);</span>
            // determine a field containing the type variable
<span class="fc" id="L1169">            List&lt;Field&gt; fields = getAllDeclaredFields(typeToClass(inType), false);</span>
<span class="pc bpc" id="L1170" title="1 of 2 branches missed.">            for (Field field : fields) {</span>
<span class="fc" id="L1171">                Type fieldType = field.getGenericType();</span>
<span class="fc bfc" id="L1172" title="All 2 branches covered.">                if (fieldType instanceof TypeVariable</span>
<span class="fc bfc" id="L1173" title="All 2 branches covered.">                        &amp;&amp; sameTypeVars(</span>
                                returnTypeVar,
<span class="fc" id="L1175">                                materializeTypeVariable(</span>
                                        inputTypeHierarchy, (TypeVariable&lt;?&gt;) fieldType))) {
<span class="fc" id="L1177">                    return getTypeOfPojoField(inTypeInfo, field);</span>
<span class="fc bfc" id="L1178" title="All 4 branches covered.">                } else if (fieldType instanceof ParameterizedType</span>
                        || fieldType instanceof GenericArrayType) {
<span class="fc" id="L1180">                    List&lt;Type&gt; typeHierarchyWithFieldType = new ArrayList&lt;&gt;(inputTypeHierarchy);</span>
<span class="fc" id="L1181">                    typeHierarchyWithFieldType.add(fieldType);</span>
<span class="fc" id="L1182">                    TypeInformation&lt;?&gt; foundInfo =</span>
<span class="fc" id="L1183">                            createTypeInfoFromInput(</span>
                                    returnTypeVar,
                                    typeHierarchyWithFieldType,
                                    fieldType,
<span class="fc" id="L1187">                                    getTypeOfPojoField(inTypeInfo, field));</span>
<span class="pc bpc" id="L1188" title="1 of 2 branches missed.">                    if (foundInfo != null) {</span>
<span class="fc" id="L1189">                        return foundInfo;</span>
                    }
                }
<span class="fc" id="L1192">            }</span>
        }
<span class="fc" id="L1194">        return info;</span>
    }

    /**
     * Creates the TypeInformation for all elements of a type that expects a certain number of
     * subtypes (e.g. TupleXX).
     *
     * @param originalType most concrete subclass
     * @param definingType type that defines the number of subtypes (e.g. Tuple2 -&gt; 2 subtypes)
     * @param typeHierarchy necessary for type inference
     * @param in1Type necessary for type inference
     * @param in2Type necessary for type inference
     * @param lenient decides whether exceptions should be thrown if a subtype can not be determined
     * @return array containing TypeInformation of sub types or null if definingType contains more
     *     subtypes (fields) that defined
     */
    private &lt;IN1, IN2&gt; TypeInformation&lt;?&gt;[] createSubTypesInfo(
            Type originalType,
            ParameterizedType definingType,
            List&lt;Type&gt; typeHierarchy,
            TypeInformation&lt;IN1&gt; in1Type,
            TypeInformation&lt;IN2&gt; in2Type,
            boolean lenient) {
<span class="fc" id="L1217">        Type[] subtypes = new Type[definingType.getActualTypeArguments().length];</span>

        // materialize possible type variables
<span class="fc bfc" id="L1220" title="All 2 branches covered.">        for (int i = 0; i &lt; subtypes.length; i++) {</span>
<span class="fc" id="L1221">            final Type actualTypeArg = definingType.getActualTypeArguments()[i];</span>
            // materialize immediate TypeVariables
<span class="fc bfc" id="L1223" title="All 2 branches covered.">            if (actualTypeArg instanceof TypeVariable&lt;?&gt;) {</span>
<span class="fc" id="L1224">                subtypes[i] =</span>
<span class="fc" id="L1225">                        materializeTypeVariable(typeHierarchy, (TypeVariable&lt;?&gt;) actualTypeArg);</span>
            }
            // class or parameterized type
            else {
<span class="fc" id="L1229">                subtypes[i] = actualTypeArg;</span>
            }
        }

<span class="fc" id="L1233">        TypeInformation&lt;?&gt;[] subTypesInfo = new TypeInformation&lt;?&gt;[subtypes.length];</span>
<span class="fc bfc" id="L1234" title="All 2 branches covered.">        for (int i = 0; i &lt; subtypes.length; i++) {</span>
<span class="fc" id="L1235">            final List&lt;Type&gt; subTypeHierarchy = new ArrayList&lt;&gt;(typeHierarchy);</span>
<span class="fc" id="L1236">            subTypeHierarchy.add(subtypes[i]);</span>
            // sub type could not be determined with materializing
            // try to derive the type info of the TypeVariable from the immediate base child input
            // as a last attempt
<span class="fc bfc" id="L1240" title="All 2 branches covered.">            if (subtypes[i] instanceof TypeVariable&lt;?&gt;) {</span>
<span class="fc" id="L1241">                subTypesInfo[i] =</span>
<span class="fc" id="L1242">                        createTypeInfoFromInputs(</span>
                                (TypeVariable&lt;?&gt;) subtypes[i], subTypeHierarchy, in1Type, in2Type);

                // variable could not be determined
<span class="fc bfc" id="L1246" title="All 4 branches covered.">                if (subTypesInfo[i] == null &amp;&amp; !lenient) {</span>
<span class="fc" id="L1247">                    throw new InvalidTypesException(</span>
                            &quot;Type of TypeVariable '&quot;
<span class="fc" id="L1249">                                    + ((TypeVariable&lt;?&gt;) subtypes[i]).getName()</span>
                                    + &quot;' in '&quot;
<span class="fc" id="L1251">                                    + ((TypeVariable&lt;?&gt;) subtypes[i]).getGenericDeclaration()</span>
                                    + &quot;' could not be determined. This is most likely a type erasure problem. &quot;
                                    + &quot;The type extraction currently supports types with generic variables only in cases where &quot;
                                    + &quot;all variables in the return type can be deduced from the input type(s). &quot;
                                    + &quot;Otherwise the type has to be specified explicitly using type information.&quot;);
                }
            } else {
                // create the type information of the subtype or null/exception
                try {
<span class="fc" id="L1260">                    subTypesInfo[i] =</span>
<span class="fc" id="L1261">                            createTypeInfoWithTypeHierarchy(</span>
                                    subTypeHierarchy, subtypes[i], in1Type, in2Type);
<span class="nc" id="L1263">                } catch (InvalidTypesException e) {</span>
<span class="nc bnc" id="L1264" title="All 2 branches missed.">                    if (lenient) {</span>
<span class="nc" id="L1265">                        subTypesInfo[i] = null;</span>
                    } else {
<span class="nc" id="L1267">                        throw e;</span>
                    }
<span class="fc" id="L1269">                }</span>
            }
        }

        // check that number of fields matches the number of subtypes
<span class="fc bfc" id="L1274" title="All 2 branches covered.">        if (!lenient) {</span>
<span class="fc" id="L1275">            Class&lt;?&gt; originalTypeAsClass = null;</span>
<span class="pc bpc" id="L1276" title="1 of 2 branches missed.">            if (isClassType(originalType)) {</span>
<span class="fc" id="L1277">                originalTypeAsClass = typeToClass(originalType);</span>
            }
<span class="fc" id="L1279">            checkNotNull(originalTypeAsClass, &quot;originalType has an unexpected type&quot;);</span>
            // check if the class we assumed to conform to the defining type so far is actually a
            // pojo because the
            // original type contains additional fields.
            // check for additional fields.
<span class="fc" id="L1284">            int fieldCount = countFieldsInClass(originalTypeAsClass);</span>
<span class="fc bfc" id="L1285" title="All 2 branches covered.">            if (fieldCount &gt; subTypesInfo.length) {</span>
<span class="fc" id="L1286">                return null;</span>
            }
        }

<span class="fc" id="L1290">        return subTypesInfo;</span>
    }

    /**
     * Creates type information using a factory if for this type or super types. Returns null
     * otherwise.
     */
    @SuppressWarnings(&quot;unchecked&quot;)
    private &lt;IN1, IN2, OUT&gt; TypeInformation&lt;OUT&gt; createTypeInfoFromFactory(
            Type t,
            List&lt;Type&gt; typeHierarchy,
            TypeInformation&lt;IN1&gt; in1Type,
            TypeInformation&lt;IN2&gt; in2Type) {

<span class="fc" id="L1304">        final List&lt;Type&gt; factoryHierarchy = new ArrayList&lt;&gt;(typeHierarchy);</span>
<span class="fc" id="L1305">        final TypeInfoFactory&lt;? super OUT&gt; factory = getClosestFactory(factoryHierarchy, t);</span>
<span class="fc bfc" id="L1306" title="All 2 branches covered.">        if (factory == null) {</span>
<span class="fc" id="L1307">            return null;</span>
        }
<span class="fc" id="L1309">        final Type factoryDefiningType = factoryHierarchy.get(factoryHierarchy.size() - 1);</span>

        // infer possible type parameters from input
        final Map&lt;String, TypeInformation&lt;?&gt;&gt; genericParams;
<span class="fc bfc" id="L1313" title="All 2 branches covered.">        if (factoryDefiningType instanceof ParameterizedType) {</span>
<span class="fc" id="L1314">            genericParams = new HashMap&lt;&gt;();</span>
<span class="fc" id="L1315">            final ParameterizedType paramDefiningType = (ParameterizedType) factoryDefiningType;</span>
<span class="fc" id="L1316">            final Type[] args = typeToClass(paramDefiningType).getTypeParameters();</span>

<span class="fc" id="L1318">            final TypeInformation&lt;?&gt;[] subtypeInfo =</span>
<span class="fc" id="L1319">                    createSubTypesInfo(</span>
                            t, paramDefiningType, factoryHierarchy, in1Type, in2Type, true);
<span class="pc bpc" id="L1321" title="2 of 4 branches missed.">            assert subtypeInfo != null;</span>
<span class="fc bfc" id="L1322" title="All 2 branches covered.">            for (int i = 0; i &lt; subtypeInfo.length; i++) {</span>
<span class="fc" id="L1323">                genericParams.put(args[i].toString(), subtypeInfo[i]);</span>
            }
<span class="fc" id="L1325">        } else {</span>
<span class="fc" id="L1326">            genericParams = Collections.emptyMap();</span>
        }

<span class="fc" id="L1329">        final TypeInformation&lt;OUT&gt; createdTypeInfo =</span>
<span class="fc" id="L1330">                (TypeInformation&lt;OUT&gt;) factory.createTypeInfo(t, genericParams);</span>
<span class="fc bfc" id="L1331" title="All 2 branches covered.">        if (createdTypeInfo == null) {</span>
<span class="fc" id="L1332">            throw new InvalidTypesException(</span>
                    &quot;TypeInfoFactory returned invalid TypeInformation 'null'&quot;);
        }
<span class="fc" id="L1335">        return createdTypeInfo;</span>
    }

    // --------------------------------------------------------------------------------------------
    //  Extract type parameters
    // --------------------------------------------------------------------------------------------

    @PublicEvolving
    public static Type getParameterType(Class&lt;?&gt; baseClass, Class&lt;?&gt; clazz, int pos) {
<span class="nc" id="L1344">        return getParameterType(baseClass, null, clazz, pos);</span>
    }

    private static Type getParameterType(
            Class&lt;?&gt; baseClass, List&lt;Type&gt; typeHierarchy, Class&lt;?&gt; clazz, int pos) {
<span class="pc bpc" id="L1349" title="1 of 2 branches missed.">        if (typeHierarchy != null) {</span>
<span class="fc" id="L1350">            typeHierarchy.add(clazz);</span>
        }
<span class="fc" id="L1352">        Type[] interfaceTypes = clazz.getGenericInterfaces();</span>

        // search in interfaces for base class
<span class="fc bfc" id="L1355" title="All 2 branches covered.">        for (Type t : interfaceTypes) {</span>
<span class="fc" id="L1356">            Type parameter = getParameterTypeFromGenericType(baseClass, typeHierarchy, t, pos);</span>
<span class="fc bfc" id="L1357" title="All 2 branches covered.">            if (parameter != null) {</span>
<span class="fc" id="L1358">                return parameter;</span>
            }
        }

        // search in superclass for base class
<span class="fc" id="L1363">        Type t = clazz.getGenericSuperclass();</span>
<span class="fc" id="L1364">        Type parameter = getParameterTypeFromGenericType(baseClass, typeHierarchy, t, pos);</span>
<span class="fc bfc" id="L1365" title="All 2 branches covered.">        if (parameter != null) {</span>
<span class="fc" id="L1366">            return parameter;</span>
        }

<span class="fc" id="L1369">        throw new InvalidTypesException(</span>
                &quot;The types of the interface &quot;
<span class="fc" id="L1371">                        + baseClass.getName()</span>
                        + &quot; could not be inferred. &quot;
                        + &quot;Support for synthetic interfaces, lambdas, and generic or raw types is limited at this point&quot;);
    }

    private static Type getParameterTypeFromGenericType(
            Class&lt;?&gt; baseClass, List&lt;Type&gt; typeHierarchy, Type t, int pos) {
        // base class
<span class="fc bfc" id="L1379" title="All 2 branches covered.">        if (t instanceof ParameterizedType</span>
<span class="fc bfc" id="L1380" title="All 2 branches covered.">                &amp;&amp; baseClass.equals(((ParameterizedType) t).getRawType())) {</span>
<span class="pc bpc" id="L1381" title="1 of 2 branches missed.">            if (typeHierarchy != null) {</span>
<span class="fc" id="L1382">                typeHierarchy.add(t);</span>
            }
<span class="fc" id="L1384">            ParameterizedType baseClassChild = (ParameterizedType) t;</span>
<span class="fc" id="L1385">            return baseClassChild.getActualTypeArguments()[pos];</span>
        }
        // interface that extended base class as class or parameterized type
<span class="fc bfc" id="L1388" title="All 2 branches covered.">        else if (t instanceof ParameterizedType</span>
<span class="fc bfc" id="L1389" title="All 2 branches covered.">                &amp;&amp; baseClass.isAssignableFrom((Class&lt;?&gt;) ((ParameterizedType) t).getRawType())) {</span>
<span class="pc bpc" id="L1390" title="1 of 2 branches missed.">            if (typeHierarchy != null) {</span>
<span class="fc" id="L1391">                typeHierarchy.add(t);</span>
            }
<span class="fc" id="L1393">            return getParameterType(</span>
<span class="fc" id="L1394">                    baseClass, typeHierarchy, (Class&lt;?&gt;) ((ParameterizedType) t).getRawType(), pos);</span>
<span class="fc bfc" id="L1395" title="All 4 branches covered.">        } else if (t instanceof Class&lt;?&gt; &amp;&amp; baseClass.isAssignableFrom((Class&lt;?&gt;) t)) {</span>
<span class="pc bpc" id="L1396" title="1 of 2 branches missed.">            if (typeHierarchy != null) {</span>
<span class="fc" id="L1397">                typeHierarchy.add(t);</span>
            }
<span class="fc" id="L1399">            return getParameterType(baseClass, typeHierarchy, (Class&lt;?&gt;) t, pos);</span>
        }
<span class="fc" id="L1401">        return null;</span>
    }

    // --------------------------------------------------------------------------------------------
    //  Validate input
    // --------------------------------------------------------------------------------------------

    private static void validateInputType(
            Class&lt;?&gt; baseClass, Class&lt;?&gt; clazz, int inputParamPos, TypeInformation&lt;?&gt; inTypeInfo) {
<span class="fc" id="L1410">        List&lt;Type&gt; typeHierarchy = new ArrayList&lt;&gt;();</span>

        // try to get generic parameter
        Type inType;
        try {
<span class="fc" id="L1415">            inType = getParameterType(baseClass, typeHierarchy, clazz, inputParamPos);</span>
<span class="nc" id="L1416">        } catch (InvalidTypesException e) {</span>
<span class="nc" id="L1417">            return; // skip input validation e.g. for raw types</span>
<span class="fc" id="L1418">        }</span>

        try {
<span class="fc" id="L1421">            validateInfo(typeHierarchy, inType, inTypeInfo);</span>
<span class="fc" id="L1422">        } catch (InvalidTypesException e) {</span>
<span class="fc" id="L1423">            throw new InvalidTypesException(&quot;Input mismatch: &quot; + e.getMessage(), e);</span>
<span class="fc" id="L1424">        }</span>
<span class="fc" id="L1425">    }</span>

    @SuppressWarnings(&quot;unchecked&quot;)
    private static void validateInfo(
            List&lt;Type&gt; typeHierarchy, Type type, TypeInformation&lt;?&gt; typeInfo) {
<span class="pc bpc" id="L1430" title="1 of 2 branches missed.">        if (type == null) {</span>
<span class="nc" id="L1431">            throw new InvalidTypesException(&quot;Unknown Error. Type is null.&quot;);</span>
        }

<span class="pc bpc" id="L1434" title="1 of 2 branches missed.">        if (typeInfo == null) {</span>
<span class="nc" id="L1435">            throw new InvalidTypesException(&quot;Unknown Error. TypeInformation is null.&quot;);</span>
        }

<span class="fc bfc" id="L1438" title="All 2 branches covered.">        if (!(type instanceof TypeVariable&lt;?&gt;)) {</span>
            // check for Java Basic Types
<span class="fc bfc" id="L1440" title="All 2 branches covered.">            if (typeInfo instanceof BasicTypeInfo) {</span>

                TypeInformation&lt;?&gt; actual;
                // check if basic type at all
<span class="fc bfc" id="L1444" title="All 2 branches covered.">                if (!(type instanceof Class&lt;?&gt;)</span>
<span class="pc bpc" id="L1445" title="1 of 2 branches missed.">                        || (actual = BasicTypeInfo.getInfoFor((Class&lt;?&gt;) type)) == null) {</span>
<span class="fc" id="L1446">                    throw new InvalidTypesException(&quot;Basic type expected.&quot;);</span>
                }
                // check if correct basic type
<span class="fc bfc" id="L1449" title="All 2 branches covered.">                if (!typeInfo.equals(actual)) {</span>
<span class="fc" id="L1450">                    throw new InvalidTypesException(</span>
                            &quot;Basic type '&quot; + typeInfo + &quot;' expected but was '&quot; + actual + &quot;'.&quot;);
                }

<span class="fc" id="L1454">            }</span>
            // check for Java SQL time types
<span class="fc bfc" id="L1456" title="All 2 branches covered.">            else if (typeInfo instanceof SqlTimeTypeInfo) {</span>

                TypeInformation&lt;?&gt; actual;
                // check if SQL time type at all
<span class="pc bpc" id="L1460" title="1 of 2 branches missed.">                if (!(type instanceof Class&lt;?&gt;)</span>
<span class="pc bpc" id="L1461" title="1 of 2 branches missed.">                        || (actual = SqlTimeTypeInfo.getInfoFor((Class&lt;?&gt;) type)) == null) {</span>
<span class="nc" id="L1462">                    throw new InvalidTypesException(&quot;SQL time type expected.&quot;);</span>
                }
                // check if correct SQL time type
<span class="pc bpc" id="L1465" title="1 of 2 branches missed.">                if (!typeInfo.equals(actual)) {</span>
<span class="nc" id="L1466">                    throw new InvalidTypesException(</span>
                            &quot;SQL time type '&quot; + typeInfo + &quot;' expected but was '&quot; + actual + &quot;'.&quot;);
                }

<span class="fc" id="L1470">            }</span>
            // check for Java Tuples
<span class="fc bfc" id="L1472" title="All 2 branches covered.">            else if (typeInfo instanceof TupleTypeInfo) {</span>
                // check if tuple at all
<span class="pc bpc" id="L1474" title="2 of 4 branches missed.">                if (!(isClassType(type) &amp;&amp; Tuple.class.isAssignableFrom(typeToClass(type)))) {</span>
<span class="nc" id="L1475">                    throw new InvalidTypesException(&quot;Tuple type expected.&quot;);</span>
                }

                // do not allow usage of Tuple as type
<span class="pc bpc" id="L1479" title="2 of 4 branches missed.">                if (isClassType(type) &amp;&amp; typeToClass(type).equals(Tuple.class)) {</span>
<span class="nc" id="L1480">                    throw new InvalidTypesException(&quot;Concrete subclass of Tuple expected.&quot;);</span>
                }

                // go up the hierarchy until we reach immediate child of Tuple (with or without
                // generics)
<span class="pc bpc" id="L1485" title="1 of 2 branches missed.">                while (!(isClassType(type)</span>
<span class="fc bfc" id="L1486" title="All 2 branches covered.">                        &amp;&amp; typeToClass(type).getSuperclass().equals(Tuple.class))) {</span>
<span class="fc" id="L1487">                    typeHierarchy.add(type);</span>
<span class="fc" id="L1488">                    type = typeToClass(type).getGenericSuperclass();</span>
                }

<span class="fc bfc" id="L1491" title="All 2 branches covered.">                if (type == Tuple0.class) {</span>
<span class="fc" id="L1492">                    return;</span>
                }

                // check if immediate child of Tuple has generics
<span class="pc bpc" id="L1496" title="1 of 2 branches missed.">                if (type instanceof Class&lt;?&gt;) {</span>
<span class="nc" id="L1497">                    throw new InvalidTypesException(&quot;Parameterized Tuple type expected.&quot;);</span>
                }

<span class="fc" id="L1500">                TupleTypeInfo&lt;?&gt; tti = (TupleTypeInfo&lt;?&gt;) typeInfo;</span>

<span class="fc" id="L1502">                Type[] subTypes = ((ParameterizedType) type).getActualTypeArguments();</span>

<span class="fc bfc" id="L1504" title="All 2 branches covered.">                if (subTypes.length != tti.getArity()) {</span>
<span class="fc" id="L1505">                    throw new InvalidTypesException(</span>
                            &quot;Tuple arity '&quot;
<span class="fc" id="L1507">                                    + tti.getArity()</span>
                                    + &quot;' expected but was '&quot;
                                    + subTypes.length
                                    + &quot;'.&quot;);
                }

<span class="fc bfc" id="L1513" title="All 2 branches covered.">                for (int i = 0; i &lt; subTypes.length; i++) {</span>
<span class="fc" id="L1514">                    validateInfo(new ArrayList&lt;&gt;(typeHierarchy), subTypes[i], tti.getTypeAt(i));</span>
                }
<span class="fc" id="L1516">            }</span>
            // check for primitive array
<span class="fc bfc" id="L1518" title="All 2 branches covered.">            else if (typeInfo instanceof PrimitiveArrayTypeInfo) {</span>
                Type component;
                // check if array at all
<span class="pc bpc" id="L1521" title="1 of 2 branches missed.">                if (!(type instanceof Class&lt;?&gt;</span>
<span class="pc bpc" id="L1522" title="1 of 2 branches missed.">                                &amp;&amp; ((Class&lt;?&gt;) type).isArray()</span>
<span class="pc bpc" id="L1523" title="3 of 4 branches missed.">                                &amp;&amp; (component = ((Class&lt;?&gt;) type).getComponentType()) != null)</span>
                        &amp;&amp; !(type instanceof GenericArrayType
<span class="nc bnc" id="L1525" title="All 2 branches missed.">                                &amp;&amp; (component = ((GenericArrayType) type).getGenericComponentType())</span>
                                        != null)) {
<span class="nc" id="L1527">                    throw new InvalidTypesException(&quot;Array type expected.&quot;);</span>
                }
<span class="pc bpc" id="L1529" title="1 of 2 branches missed.">                if (component instanceof TypeVariable&lt;?&gt;) {</span>
<span class="nc" id="L1530">                    component = materializeTypeVariable(typeHierarchy, (TypeVariable&lt;?&gt;) component);</span>
<span class="nc bnc" id="L1531" title="All 2 branches missed.">                    if (component instanceof TypeVariable) {</span>
<span class="nc" id="L1532">                        return;</span>
                    }
                }
<span class="pc bpc" id="L1535" title="2 of 4 branches missed.">                if (!(component instanceof Class&lt;?&gt; &amp;&amp; ((Class&lt;?&gt;) component).isPrimitive())) {</span>
<span class="nc" id="L1536">                    throw new InvalidTypesException(&quot;Primitive component expected.&quot;);</span>
                }
<span class="fc" id="L1538">            }</span>
            // check for basic array
<span class="fc bfc" id="L1540" title="All 2 branches covered.">            else if (typeInfo instanceof BasicArrayTypeInfo&lt;?, ?&gt;) {</span>
                Type component;
                // check if array at all
<span class="fc bfc" id="L1543" title="All 2 branches covered.">                if (!(type instanceof Class&lt;?&gt;</span>
<span class="pc bpc" id="L1544" title="1 of 2 branches missed.">                                &amp;&amp; ((Class&lt;?&gt;) type).isArray()</span>
<span class="pc bpc" id="L1545" title="2 of 4 branches missed.">                                &amp;&amp; (component = ((Class&lt;?&gt;) type).getComponentType()) != null)</span>
                        &amp;&amp; !(type instanceof GenericArrayType
<span class="pc bpc" id="L1547" title="1 of 2 branches missed.">                                &amp;&amp; (component = ((GenericArrayType) type).getGenericComponentType())</span>
                                        != null)) {
<span class="nc" id="L1549">                    throw new InvalidTypesException(&quot;Array type expected.&quot;);</span>
                }

<span class="fc bfc" id="L1552" title="All 2 branches covered.">                if (component instanceof TypeVariable&lt;?&gt;) {</span>
<span class="fc" id="L1553">                    component = materializeTypeVariable(typeHierarchy, (TypeVariable&lt;?&gt;) component);</span>
<span class="fc bfc" id="L1554" title="All 2 branches covered.">                    if (component instanceof TypeVariable) {</span>
<span class="fc" id="L1555">                        return;</span>
                    }
                }

<span class="fc" id="L1559">                validateInfo(</span>
                        typeHierarchy,
                        component,
<span class="fc" id="L1562">                        ((BasicArrayTypeInfo&lt;?, ?&gt;) typeInfo).getComponentInfo());</span>

<span class="fc" id="L1564">            }</span>
            // check for object array
<span class="fc bfc" id="L1566" title="All 2 branches covered.">            else if (typeInfo instanceof ObjectArrayTypeInfo&lt;?, ?&gt;) {</span>
                // check if array at all
<span class="pc bpc" id="L1568" title="2 of 6 branches missed.">                if (!(type instanceof Class&lt;?&gt; &amp;&amp; ((Class&lt;?&gt;) type).isArray())</span>
                        &amp;&amp; !(type instanceof GenericArrayType)) {
<span class="nc" id="L1570">                    throw new InvalidTypesException(&quot;Object array type expected.&quot;);</span>
                }

                // check component
                Type component;
<span class="fc bfc" id="L1575" title="All 2 branches covered.">                if (type instanceof Class&lt;?&gt;) {</span>
<span class="fc" id="L1576">                    component = ((Class&lt;?&gt;) type).getComponentType();</span>
                } else {
<span class="fc" id="L1578">                    component = ((GenericArrayType) type).getGenericComponentType();</span>
                }

<span class="fc bfc" id="L1581" title="All 2 branches covered.">                if (component instanceof TypeVariable&lt;?&gt;) {</span>
<span class="fc" id="L1582">                    component = materializeTypeVariable(typeHierarchy, (TypeVariable&lt;?&gt;) component);</span>
<span class="pc bpc" id="L1583" title="1 of 2 branches missed.">                    if (component instanceof TypeVariable) {</span>
<span class="fc" id="L1584">                        return;</span>
                    }
                }

<span class="fc" id="L1588">                validateInfo(</span>
                        typeHierarchy,
                        component,
<span class="fc" id="L1591">                        ((ObjectArrayTypeInfo&lt;?, ?&gt;) typeInfo).getComponentInfo());</span>
<span class="fc" id="L1592">            }</span>
            // check for value
<span class="fc bfc" id="L1594" title="All 2 branches covered.">            else if (typeInfo instanceof ValueTypeInfo&lt;?&gt;) {</span>
                // check if value at all
<span class="pc bpc" id="L1596" title="2 of 4 branches missed.">                if (!(type instanceof Class&lt;?&gt; &amp;&amp; Value.class.isAssignableFrom((Class&lt;?&gt;) type))) {</span>
<span class="nc" id="L1597">                    throw new InvalidTypesException(&quot;Value type expected.&quot;);</span>
                }

                TypeInformation&lt;?&gt; actual;
                // check value type contents
<span class="fc bfc" id="L1602" title="All 2 branches covered.">                if (!typeInfo.equals(</span>
<span class="fc" id="L1603">                        actual = ValueTypeInfo.getValueTypeInfo((Class&lt;? extends Value&gt;) type))) {</span>
<span class="fc" id="L1604">                    throw new InvalidTypesException(</span>
                            &quot;Value type '&quot; + typeInfo + &quot;' expected but was '&quot; + actual + &quot;'.&quot;);
                }
<span class="fc" id="L1607">            }</span>
            // check for POJO
<span class="fc bfc" id="L1609" title="All 2 branches covered.">            else if (typeInfo instanceof PojoTypeInfo) {</span>
<span class="fc" id="L1610">                Class&lt;?&gt; clazz = null;</span>
<span class="pc bpc" id="L1611" title="1 of 2 branches missed.">                if (!(isClassType(type)</span>
<span class="fc" id="L1612">                        &amp;&amp; ((PojoTypeInfo&lt;?&gt;) typeInfo).getTypeClass()</span>
<span class="pc bpc" id="L1613" title="1 of 2 branches missed.">                                == (clazz = typeToClass(type)))) {</span>
<span class="nc" id="L1614">                    throw new InvalidTypesException(</span>
                            &quot;POJO type '&quot;
<span class="nc" id="L1616">                                    + ((PojoTypeInfo&lt;?&gt;) typeInfo).getTypeClass().getCanonicalName()</span>
                                    + &quot;' expected but was '&quot;
<span class="nc" id="L1618">                                    + clazz.getCanonicalName()</span>
                                    + &quot;'.&quot;);
                }
<span class="fc" id="L1621">            }</span>
            // check for Enum
<span class="fc bfc" id="L1623" title="All 2 branches covered.">            else if (typeInfo instanceof EnumTypeInfo) {</span>
<span class="pc bpc" id="L1624" title="2 of 4 branches missed.">                if (!(type instanceof Class&lt;?&gt; &amp;&amp; Enum.class.isAssignableFrom((Class&lt;?&gt;) type))) {</span>
<span class="nc" id="L1625">                    throw new InvalidTypesException(&quot;Enum type expected.&quot;);</span>
                }
                // check enum type contents
<span class="pc bpc" id="L1628" title="1 of 2 branches missed.">                if (!(typeInfo.getTypeClass() == type)) {</span>
<span class="nc" id="L1629">                    throw new InvalidTypesException(</span>
                            &quot;Enum type '&quot;
<span class="nc" id="L1631">                                    + typeInfo.getTypeClass().getCanonicalName()</span>
                                    + &quot;' expected but was '&quot;
<span class="nc" id="L1633">                                    + typeToClass(type).getCanonicalName()</span>
                                    + &quot;'.&quot;);
                }
            }
            // check for generic object
<span class="fc bfc" id="L1638" title="All 2 branches covered.">            else if (typeInfo instanceof GenericTypeInfo&lt;?&gt;) {</span>
<span class="fc" id="L1639">                Class&lt;?&gt; clazz = null;</span>
<span class="pc bpc" id="L1640" title="1 of 2 branches missed.">                if (!(isClassType(type)</span>
<span class="fc" id="L1641">                        &amp;&amp; (clazz = typeToClass(type))</span>
<span class="fc bfc" id="L1642" title="All 2 branches covered.">                                .isAssignableFrom(</span>
<span class="fc" id="L1643">                                        ((GenericTypeInfo&lt;?&gt;) typeInfo).getTypeClass()))) {</span>
<span class="fc" id="L1644">                    throw new InvalidTypesException(</span>
                            &quot;Generic type '&quot;
                                    + ((GenericTypeInfo&lt;?&gt;) typeInfo)
<span class="fc" id="L1647">                                            .getTypeClass()</span>
<span class="fc" id="L1648">                                            .getCanonicalName()</span>
                                    + &quot;' or a subclass of it expected but was '&quot;
<span class="fc" id="L1650">                                    + clazz.getCanonicalName()</span>
                                    + &quot;'.&quot;);
                }
<span class="fc" id="L1653">            }</span>
            // check for Writable
            else {
<span class="fc" id="L1656">                validateIfWritable(typeInfo, type);</span>
            }
        } else {
<span class="fc" id="L1659">            type = materializeTypeVariable(typeHierarchy, (TypeVariable&lt;?&gt;) type);</span>
<span class="fc bfc" id="L1660" title="All 2 branches covered.">            if (!(type instanceof TypeVariable)) {</span>
<span class="fc" id="L1661">                validateInfo(typeHierarchy, type, typeInfo);</span>
            }
        }
<span class="fc" id="L1664">    }</span>

    // --------------------------------------------------------------------------------------------
    //  Utility methods
    // --------------------------------------------------------------------------------------------

    /**
     * Returns the type information factory for a type using the factory registry or annotations.
     */
    @Internal
    @SuppressWarnings(&quot;unchecked&quot;)
    public static &lt;OUT&gt; TypeInfoFactory&lt;OUT&gt; getTypeInfoFactory(Type t) {
        final Class&lt;?&gt; factoryClass;
<span class="pc bpc" id="L1677" title="1 of 4 branches missed.">        if (!isClassType(t) || !typeToClass(t).isAnnotationPresent(TypeInfo.class)) {</span>
<span class="fc" id="L1678">            return null;</span>
        }
<span class="fc" id="L1680">        final TypeInfo typeInfoAnnotation = typeToClass(t).getAnnotation(TypeInfo.class);</span>
<span class="fc" id="L1681">        factoryClass = typeInfoAnnotation.value();</span>
        // check for valid factory class
<span class="pc bpc" id="L1683" title="1 of 2 branches missed.">        if (!TypeInfoFactory.class.isAssignableFrom(factoryClass)) {</span>
<span class="nc" id="L1684">            throw new InvalidTypesException(</span>
                    &quot;TypeInfo annotation does not specify a valid TypeInfoFactory.&quot;);
        }

        // instantiate
<span class="fc" id="L1689">        return (TypeInfoFactory&lt;OUT&gt;) InstantiationUtil.instantiate(factoryClass);</span>
    }

    /** @return number of items with equal type or same raw type */
    private static int countTypeInHierarchy(List&lt;Type&gt; typeHierarchy, Type type) {
<span class="fc" id="L1694">        int count = 0;</span>
<span class="fc bfc" id="L1695" title="All 2 branches covered.">        for (Type t : typeHierarchy) {</span>
<span class="fc bfc" id="L1696" title="All 2 branches covered.">            if (t == type</span>
<span class="pc bpc" id="L1697" title="2 of 4 branches missed.">                    || (isClassType(type) &amp;&amp; t == typeToClass(type))</span>
<span class="fc bfc" id="L1698" title="All 4 branches covered.">                    || (isClassType(t) &amp;&amp; typeToClass(t) == type)) {</span>
<span class="fc" id="L1699">                count++;</span>
            }
<span class="fc" id="L1701">        }</span>
<span class="fc" id="L1702">        return count;</span>
    }

    /**
     * Traverses the type hierarchy up until a type information factory can be found.
     *
     * @param typeHierarchy hierarchy to be filled while traversing up
     * @param t type for which a factory needs to be found
     * @return closest type information factory or null if there is no factory in the type hierarchy
     */
    private static &lt;OUT&gt; TypeInfoFactory&lt;? super OUT&gt; getClosestFactory(
            List&lt;Type&gt; typeHierarchy, Type t) {
<span class="fc" id="L1714">        TypeInfoFactory&lt;OUT&gt; factory = null;</span>
<span class="fc bfc" id="L1715" title="All 6 branches covered.">        while (factory == null &amp;&amp; isClassType(t) &amp;&amp; !(typeToClass(t).equals(Object.class))) {</span>
<span class="fc" id="L1716">            typeHierarchy.add(t);</span>
<span class="fc" id="L1717">            factory = getTypeInfoFactory(t);</span>
<span class="fc" id="L1718">            t = typeToClass(t).getGenericSuperclass();</span>

<span class="fc bfc" id="L1720" title="All 2 branches covered.">            if (t == null) {</span>
<span class="fc" id="L1721">                break;</span>
            }
        }
<span class="fc" id="L1724">        return factory;</span>
    }

    private int countFieldsInClass(Class&lt;?&gt; clazz) {
<span class="fc" id="L1728">        int fieldCount = 0;</span>
<span class="fc bfc" id="L1729" title="All 2 branches covered.">        for (Field field : clazz.getFields()) { // get all fields</span>
<span class="fc bfc" id="L1730" title="All 2 branches covered.">            if (!Modifier.isStatic(field.getModifiers())</span>
<span class="pc bpc" id="L1731" title="1 of 2 branches missed.">                    &amp;&amp; !Modifier.isTransient(field.getModifiers())) {</span>
<span class="fc" id="L1732">                fieldCount++;</span>
            }
        }
<span class="fc" id="L1735">        return fieldCount;</span>
    }

    /**
     * Tries to find a concrete value (Class, ParameterizedType etc. ) for a TypeVariable by
     * traversing the type hierarchy downwards. If a value could not be found it will return the
     * most bottom type variable in the hierarchy.
     */
    private static Type materializeTypeVariable(List&lt;Type&gt; typeHierarchy, TypeVariable&lt;?&gt; typeVar) {
<span class="fc" id="L1744">        TypeVariable&lt;?&gt; inTypeTypeVar = typeVar;</span>
        // iterate thru hierarchy from top to bottom until type variable gets a class assigned
<span class="fc bfc" id="L1746" title="All 2 branches covered.">        for (int i = typeHierarchy.size() - 1; i &gt;= 0; i--) {</span>
<span class="fc" id="L1747">            Type curT = typeHierarchy.get(i);</span>

            // parameterized type
<span class="fc bfc" id="L1750" title="All 2 branches covered.">            if (curT instanceof ParameterizedType) {</span>
<span class="fc" id="L1751">                Class&lt;?&gt; rawType = ((Class&lt;?&gt;) ((ParameterizedType) curT).getRawType());</span>

<span class="fc" id="L1753">                for (int paramIndex = 0;</span>
<span class="fc bfc" id="L1754" title="All 2 branches covered.">                        paramIndex &lt; rawType.getTypeParameters().length;</span>
<span class="fc" id="L1755">                        paramIndex++) {</span>

<span class="fc" id="L1757">                    TypeVariable&lt;?&gt; curVarOfCurT = rawType.getTypeParameters()[paramIndex];</span>

                    // check if variable names match
<span class="fc bfc" id="L1760" title="All 2 branches covered.">                    if (sameTypeVars(curVarOfCurT, inTypeTypeVar)) {</span>
<span class="fc" id="L1761">                        Type curVarType =</span>
<span class="fc" id="L1762">                                ((ParameterizedType) curT).getActualTypeArguments()[paramIndex];</span>

                        // another type variable level
<span class="fc bfc" id="L1765" title="All 2 branches covered.">                        if (curVarType instanceof TypeVariable&lt;?&gt;) {</span>
<span class="fc" id="L1766">                            inTypeTypeVar = (TypeVariable&lt;?&gt;) curVarType;</span>
                        }
                        // class
                        else {
<span class="fc" id="L1770">                            return curVarType;</span>
                        }
                    }
                }
            }
        }
        // can not be materialized, most likely due to type erasure
        // return the type variable of the deepest level
<span class="fc" id="L1778">        return inTypeTypeVar;</span>
    }

    /**
     * Creates type information from a given Class such as Integer, String[] or POJOs.
     *
     * &lt;p&gt;This method does not support ParameterizedTypes such as Tuples or complex type
     * hierarchies. In most cases {@link TypeExtractor#createTypeInfo(Type)} is the recommended
     * method for type extraction (a Class is a child of Type).
     *
     * @param clazz a Class to create TypeInformation for
     * @return TypeInformation that describes the passed Class
     */
    public static &lt;X&gt; TypeInformation&lt;X&gt; getForClass(Class&lt;X&gt; clazz) {
<span class="fc" id="L1792">        final List&lt;Type&gt; typeHierarchy = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L1793">        typeHierarchy.add(clazz);</span>
<span class="fc" id="L1794">        return new TypeExtractor().privateGetForClass(clazz, typeHierarchy);</span>
    }

    private &lt;X&gt; TypeInformation&lt;X&gt; privateGetForClass(Class&lt;X&gt; clazz, List&lt;Type&gt; typeHierarchy) {
<span class="fc" id="L1798">        return privateGetForClass(clazz, typeHierarchy, null, null, null);</span>
    }

    @SuppressWarnings({&quot;unchecked&quot;, &quot;rawtypes&quot;})
    private &lt;OUT, IN1, IN2&gt; TypeInformation&lt;OUT&gt; privateGetForClass(
            Class&lt;OUT&gt; clazz,
            List&lt;Type&gt; typeHierarchy,
            ParameterizedType parameterizedType,
            TypeInformation&lt;IN1&gt; in1Type,
            TypeInformation&lt;IN2&gt; in2Type) {
<span class="fc" id="L1808">        checkNotNull(clazz);</span>

        // check if type information can be produced using a factory
<span class="fc" id="L1811">        final TypeInformation&lt;OUT&gt; typeFromFactory =</span>
<span class="fc" id="L1812">                createTypeInfoFromFactory(clazz, typeHierarchy, in1Type, in2Type);</span>
<span class="fc bfc" id="L1813" title="All 2 branches covered.">        if (typeFromFactory != null) {</span>
<span class="fc" id="L1814">            return typeFromFactory;</span>
        }

        // Object is handled as generic type info
<span class="fc bfc" id="L1818" title="All 2 branches covered.">        if (clazz.equals(Object.class)) {</span>
<span class="fc" id="L1819">            return new GenericTypeInfo&lt;&gt;(clazz);</span>
        }

        // Class is handled as generic type info
<span class="pc bpc" id="L1823" title="1 of 2 branches missed.">        if (clazz.equals(Class.class)) {</span>
<span class="nc" id="L1824">            return new GenericTypeInfo&lt;&gt;(clazz);</span>
        }

        // recursive types are handled as generic type info
<span class="fc bfc" id="L1828" title="All 2 branches covered.">        if (countTypeInHierarchy(typeHierarchy, clazz) &gt; 1) {</span>
<span class="fc" id="L1829">            return new GenericTypeInfo&lt;&gt;(clazz);</span>
        }

        // check for arrays
<span class="fc bfc" id="L1833" title="All 2 branches covered.">        if (clazz.isArray()) {</span>

            // primitive arrays: int[], byte[], ...
<span class="fc" id="L1836">            PrimitiveArrayTypeInfo&lt;OUT&gt; primitiveArrayInfo =</span>
<span class="fc" id="L1837">                    PrimitiveArrayTypeInfo.getInfoFor(clazz);</span>
<span class="fc bfc" id="L1838" title="All 2 branches covered.">            if (primitiveArrayInfo != null) {</span>
<span class="fc" id="L1839">                return primitiveArrayInfo;</span>
            }

            // basic type arrays: String[], Integer[], Double[]
<span class="fc" id="L1843">            BasicArrayTypeInfo&lt;OUT, ?&gt; basicArrayInfo = BasicArrayTypeInfo.getInfoFor(clazz);</span>
<span class="fc bfc" id="L1844" title="All 2 branches covered.">            if (basicArrayInfo != null) {</span>
<span class="fc" id="L1845">                return basicArrayInfo;</span>
            }

            // object arrays
            else {
<span class="fc" id="L1850">                TypeInformation&lt;?&gt; componentTypeInfo =</span>
<span class="fc" id="L1851">                        createTypeInfoWithTypeHierarchy(</span>
<span class="fc" id="L1852">                                typeHierarchy, clazz.getComponentType(), in1Type, in2Type);</span>

<span class="fc" id="L1854">                return ObjectArrayTypeInfo.getInfoFor(clazz, componentTypeInfo);</span>
            }
        }

        // check for writable types
<span class="pc bpc" id="L1859" title="1 of 2 branches missed.">        if (isHadoopWritable(clazz)) {</span>
<span class="nc" id="L1860">            return createHadoopWritableTypeInfo(clazz);</span>
        }

        // check for basic types
<span class="fc" id="L1864">        TypeInformation&lt;OUT&gt; basicTypeInfo = BasicTypeInfo.getInfoFor(clazz);</span>
<span class="fc bfc" id="L1865" title="All 2 branches covered.">        if (basicTypeInfo != null) {</span>
<span class="fc" id="L1866">            return basicTypeInfo;</span>
        }

        // check for SQL time types
<span class="fc" id="L1870">        TypeInformation&lt;OUT&gt; timeTypeInfo = SqlTimeTypeInfo.getInfoFor(clazz);</span>
<span class="fc bfc" id="L1871" title="All 2 branches covered.">        if (timeTypeInfo != null) {</span>
<span class="fc" id="L1872">            return timeTypeInfo;</span>
        }

        // check for subclasses of Value
<span class="fc bfc" id="L1876" title="All 2 branches covered.">        if (Value.class.isAssignableFrom(clazz)) {</span>
<span class="fc" id="L1877">            Class&lt;? extends Value&gt; valueClass = clazz.asSubclass(Value.class);</span>
<span class="fc" id="L1878">            return (TypeInformation&lt;OUT&gt;) ValueTypeInfo.getValueTypeInfo(valueClass);</span>
        }

        // check for subclasses of Tuple
<span class="fc bfc" id="L1882" title="All 2 branches covered.">        if (Tuple.class.isAssignableFrom(clazz)) {</span>
<span class="pc bpc" id="L1883" title="1 of 2 branches missed.">            if (clazz == Tuple0.class) {</span>
<span class="nc" id="L1884">                return new TupleTypeInfo(Tuple0.class);</span>
            }
<span class="fc" id="L1886">            throw new InvalidTypesException(</span>
                    &quot;Type information extraction for tuples (except Tuple0) cannot be done based on the class.&quot;);
        }

        // check for Enums
<span class="fc bfc" id="L1891" title="All 2 branches covered.">        if (Enum.class.isAssignableFrom(clazz)) {</span>
<span class="fc" id="L1892">            return new EnumTypeInfo(clazz);</span>
        }

        // special case for POJOs generated by Avro.
<span class="pc bpc" id="L1896" title="1 of 2 branches missed.">        if (hasSuperclass(clazz, AVRO_SPECIFIC_RECORD_BASE_CLASS)) {</span>
<span class="nc" id="L1897">            return AvroUtils.getAvroUtils().createAvroTypeInfo(clazz);</span>
        }

<span class="fc bfc" id="L1900" title="All 2 branches covered.">        if (Modifier.isInterface(clazz.getModifiers())) {</span>
            // Interface has no members and is therefore not handled as POJO
<span class="fc" id="L1902">            return new GenericTypeInfo&lt;&gt;(clazz);</span>
        }

        try {
<span class="fc bfc" id="L1906" title="All 2 branches covered.">            Type t = parameterizedType != null ? parameterizedType : clazz;</span>
<span class="fc" id="L1907">            TypeInformation&lt;OUT&gt; pojoType =</span>
<span class="fc" id="L1908">                    analyzePojo(t, new ArrayList&lt;&gt;(typeHierarchy), in1Type, in2Type);</span>
<span class="fc bfc" id="L1909" title="All 2 branches covered.">            if (pojoType != null) {</span>
<span class="fc" id="L1910">                return pojoType;</span>
            }
<span class="fc" id="L1912">        } catch (InvalidTypesException e) {</span>
<span class="pc bpc" id="L1913" title="1 of 2 branches missed.">            if (LOG.isDebugEnabled()) {</span>
<span class="nc" id="L1914">                LOG.debug(</span>
<span class="nc" id="L1915">                        &quot;Unable to handle type &quot; + clazz + &quot; as POJO. Message: &quot; + e.getMessage(),</span>
                        e);
            }
            // ignore and create generic type info
<span class="fc" id="L1919">        }</span>

        // return a generic type
<span class="fc" id="L1922">        return new GenericTypeInfo&lt;&gt;(clazz);</span>
    }

    /**
     * Checks if the given field is a valid pojo field: - it is public OR - there are getter and
     * setter methods for the field.
     *
     * @param f field to check
     * @param clazz class of field
     * @param typeHierarchy type hierarchy for materializing generic types
     */
    private boolean isValidPojoField(Field f, Class&lt;?&gt; clazz, List&lt;Type&gt; typeHierarchy) {
<span class="fc bfc" id="L1934" title="All 2 branches covered.">        if (Modifier.isPublic(f.getModifiers())) {</span>
<span class="fc" id="L1935">            return true;</span>
        } else {
<span class="fc" id="L1937">            boolean hasGetter = false, hasSetter = false;</span>
<span class="fc" id="L1938">            final String fieldNameLow = f.getName().toLowerCase().replaceAll(&quot;_&quot;, &quot;&quot;);</span>

<span class="fc" id="L1940">            Type fieldType = f.getGenericType();</span>
<span class="fc" id="L1941">            Class&lt;?&gt; fieldTypeWrapper = ClassUtils.primitiveToWrapper(f.getType());</span>

<span class="fc" id="L1943">            TypeVariable&lt;?&gt; fieldTypeGeneric = null;</span>
<span class="fc bfc" id="L1944" title="All 2 branches covered.">            if (fieldType instanceof TypeVariable) {</span>
<span class="fc" id="L1945">                fieldTypeGeneric = (TypeVariable&lt;?&gt;) fieldType;</span>
<span class="fc" id="L1946">                fieldType = materializeTypeVariable(typeHierarchy, (TypeVariable&lt;?&gt;) fieldType);</span>
            }
<span class="fc bfc" id="L1948" title="All 2 branches covered.">            for (Method m : clazz.getMethods()) {</span>
<span class="fc" id="L1949">                final String methodNameLow =</span>
<span class="pc bpc" id="L1950" title="1 of 2 branches missed.">                        m.getName().endsWith(&quot;_$eq&quot;)</span>
<span class="nc" id="L1951">                                ? m.getName()</span>
<span class="nc" id="L1952">                                        .toLowerCase()</span>
<span class="nc" id="L1953">                                        .replaceAll(&quot;_&quot;, &quot;&quot;)</span>
<span class="pc" id="L1954">                                        .replaceFirst(&quot;\\$eq$&quot;, &quot;_\\$eq&quot;)</span>
<span class="fc" id="L1955">                                : m.getName().toLowerCase().replaceAll(&quot;_&quot;, &quot;&quot;);</span>

                // check for getter
<span class="fc" id="L1958">                if ( // The name should be &quot;get&lt;FieldName&gt;&quot; or &quot;&lt;fieldName&gt;&quot; (for scala) or</span>
                // &quot;is&lt;fieldName&gt;&quot; for boolean fields.
<span class="fc bfc" id="L1960" title="All 2 branches covered.">                (methodNameLow.equals(&quot;get&quot; + fieldNameLow)</span>
<span class="fc bfc" id="L1961" title="All 2 branches covered.">                                || methodNameLow.equals(&quot;is&quot; + fieldNameLow)</span>
<span class="fc bfc" id="L1962" title="All 2 branches covered.">                                || methodNameLow.equals(fieldNameLow))</span>
                        &amp;&amp;
                        // no arguments for the getter
<span class="pc bpc" id="L1965" title="1 of 2 branches missed.">                        m.getParameterTypes().length == 0</span>
                        &amp;&amp;
                        // return type is same as field type (or the generic variant of it)
<span class="fc bfc" id="L1968" title="All 2 branches covered.">                        (m.getGenericReturnType().equals(fieldType)</span>
<span class="pc bpc" id="L1969" title="1 of 2 branches missed.">                                || (m.getReturnType().equals(fieldTypeWrapper))</span>
<span class="nc bnc" id="L1970" title="All 2 branches missed.">                                || (m.getGenericReturnType().equals(fieldTypeGeneric)))) {</span>
<span class="fc" id="L1971">                    hasGetter = true;</span>
                }
                // check for setters (&lt;FieldName&gt;_$eq for scala)
<span class="fc bfc" id="L1974" title="All 2 branches covered.">                if ((methodNameLow.equals(&quot;set&quot; + fieldNameLow)</span>
<span class="pc bpc" id="L1975" title="1 of 2 branches missed.">                                || methodNameLow.equals(fieldNameLow + &quot;_$eq&quot;))</span>
<span class="pc bpc" id="L1976" title="1 of 2 branches missed.">                        &amp;&amp; m.getParameterTypes().length == 1</span>
                        &amp;&amp; // one parameter of the field's type
<span class="fc bfc" id="L1978" title="All 2 branches covered.">                        (m.getGenericParameterTypes()[0].equals(fieldType)</span>
<span class="pc bpc" id="L1979" title="1 of 2 branches missed.">                                || (m.getParameterTypes()[0].equals(fieldTypeWrapper))</span>
<span class="pc bnc" id="L1980" title="All 2 branches missed.">                                || (m.getGenericParameterTypes()[0].equals(fieldTypeGeneric)))</span>
                        &amp;&amp;
                        // return type is void (or the class self).
<span class="pc bpc" id="L1983" title="1 of 4 branches missed.">                        (m.getReturnType().equals(Void.TYPE) || m.getReturnType().equals(clazz))) {</span>
<span class="fc" id="L1984">                    hasSetter = true;</span>
                }
            }
<span class="fc bfc" id="L1987" title="All 4 branches covered.">            if (hasGetter &amp;&amp; hasSetter) {</span>
<span class="fc" id="L1988">                return true;</span>
            } else {
<span class="fc bfc" id="L1990" title="All 4 branches covered.">                if (!hasGetter &amp;&amp; clazz != Row.class) {</span>
<span class="fc" id="L1991">                    LOG.info(clazz + &quot; does not contain a getter for field &quot; + f.getName());</span>
                }
<span class="pc bpc" id="L1993" title="1 of 4 branches missed.">                if (!hasSetter &amp;&amp; clazz != Row.class) {</span>
<span class="fc" id="L1994">                    LOG.info(clazz + &quot; does not contain a setter for field &quot; + f.getName());</span>
                }
<span class="fc" id="L1996">                return false;</span>
            }
        }
    }

    @SuppressWarnings(&quot;unchecked&quot;)
    protected &lt;OUT, IN1, IN2&gt; TypeInformation&lt;OUT&gt; analyzePojo(
            Type type,
            List&lt;Type&gt; typeHierarchy,
            TypeInformation&lt;IN1&gt; in1Type,
            TypeInformation&lt;IN2&gt; in2Type) {

<span class="fc" id="L2008">        Class&lt;OUT&gt; clazz = typeToClass(type);</span>
<span class="fc bfc" id="L2009" title="All 2 branches covered.">        if (!Modifier.isPublic(clazz.getModifiers())) {</span>
<span class="fc" id="L2010">            LOG.info(</span>
                    &quot;Class &quot;
<span class="fc" id="L2012">                            + clazz.getName()</span>
                            + &quot; is not public so it cannot be used as a POJO type &quot;
                            + &quot;and must be processed as GenericType. Please read the Flink documentation &quot;
                            + &quot;on \&quot;Data Types &amp; Serialization\&quot; for details of the effect on performance.&quot;);
<span class="fc" id="L2016">            return new GenericTypeInfo&lt;&gt;(clazz);</span>
        }

        // add the hierarchy of the POJO
<span class="fc" id="L2020">        getTypeHierarchy(typeHierarchy, type, Object.class);</span>

<span class="fc" id="L2022">        List&lt;Field&gt; fields = getAllDeclaredFields(clazz, false);</span>
<span class="fc bfc" id="L2023" title="All 2 branches covered.">        if (fields.size() == 0) {</span>
<span class="fc" id="L2024">            LOG.info(</span>
                    &quot;No fields were detected for &quot;
                            + clazz
                            + &quot; so it cannot be used as a POJO type &quot;
                            + &quot;and must be processed as GenericType. Please read the Flink documentation &quot;
                            + &quot;on \&quot;Data Types &amp; Serialization\&quot; for details of the effect on performance.&quot;);
<span class="fc" id="L2030">            return new GenericTypeInfo&lt;&gt;(clazz);</span>
        }

<span class="fc" id="L2033">        List&lt;PojoField&gt; pojoFields = new ArrayList&lt;&gt;();</span>
<span class="fc bfc" id="L2034" title="All 2 branches covered.">        for (Field field : fields) {</span>
<span class="fc" id="L2035">            Type fieldType = field.getGenericType();</span>
<span class="fc bfc" id="L2036" title="All 4 branches covered.">            if (!isValidPojoField(field, clazz, typeHierarchy) &amp;&amp; clazz != Row.class) {</span>
<span class="fc" id="L2037">                LOG.info(</span>
                        &quot;Class &quot;
                                + clazz
                                + &quot; cannot be used as a POJO type because not all fields are valid POJO fields, &quot;
                                + &quot;and must be processed as GenericType. Please read the Flink documentation &quot;
                                + &quot;on \&quot;Data Types &amp; Serialization\&quot; for details of the effect on performance.&quot;);
<span class="fc" id="L2043">                return null;</span>
            }
            try {
<span class="fc" id="L2046">                List&lt;Type&gt; fieldTypeHierarchy = new ArrayList&lt;&gt;(typeHierarchy);</span>
<span class="fc" id="L2047">                fieldTypeHierarchy.add(fieldType);</span>
<span class="fc" id="L2048">                TypeInformation&lt;?&gt; ti =</span>
<span class="fc" id="L2049">                        createTypeInfoWithTypeHierarchy(</span>
                                fieldTypeHierarchy, fieldType, in1Type, in2Type);
<span class="fc" id="L2051">                pojoFields.add(new PojoField(field, ti));</span>
<span class="fc" id="L2052">            } catch (InvalidTypesException e) {</span>
<span class="fc" id="L2053">                Class&lt;?&gt; genericClass = Object.class;</span>
<span class="pc bpc" id="L2054" title="1 of 2 branches missed.">                if (isClassType(fieldType)) {</span>
<span class="nc" id="L2055">                    genericClass = typeToClass(fieldType);</span>
                }
<span class="fc" id="L2057">                pojoFields.add(</span>
                        new PojoField(field, new GenericTypeInfo&lt;&gt;((Class&lt;OUT&gt;) genericClass)));
<span class="fc" id="L2059">            }</span>
<span class="fc" id="L2060">        }</span>

<span class="fc" id="L2062">        CompositeType&lt;OUT&gt; pojoType = new PojoTypeInfo&lt;&gt;(clazz, pojoFields);</span>

        //
        // Validate the correctness of the pojo.
        // returning &quot;null&quot; will result create a generic type information.
        //
<span class="fc" id="L2068">        List&lt;Method&gt; methods = getAllDeclaredMethods(clazz);</span>
<span class="fc bfc" id="L2069" title="All 2 branches covered.">        for (Method method : methods) {</span>
<span class="pc bpc" id="L2070" title="2 of 4 branches missed.">            if (method.getName().equals(&quot;readObject&quot;) || method.getName().equals(&quot;writeObject&quot;)) {</span>
<span class="nc" id="L2071">                LOG.info(</span>
                        &quot;Class &quot;
                                + clazz
                                + &quot; contains custom serialization methods we do not call, so it cannot be used as a POJO type &quot;
                                + &quot;and must be processed as GenericType. Please read the Flink documentation &quot;
                                + &quot;on \&quot;Data Types &amp; Serialization\&quot; for details of the effect on performance.&quot;);
<span class="nc" id="L2077">                return null;</span>
            }
<span class="fc" id="L2079">        }</span>

        // Try retrieving the default constructor, if it does not have one
        // we cannot use this because the serializer uses it.
<span class="fc" id="L2083">        Constructor&lt;OUT&gt; defaultConstructor = null;</span>
        try {
<span class="fc" id="L2085">            defaultConstructor = clazz.getDeclaredConstructor();</span>
<span class="fc" id="L2086">        } catch (NoSuchMethodException e) {</span>
<span class="pc bpc" id="L2087" title="2 of 4 branches missed.">            if (clazz.isInterface() || Modifier.isAbstract(clazz.getModifiers())) {</span>
<span class="nc" id="L2088">                LOG.info(</span>
                        clazz
                                + &quot; is abstract or an interface, having a concrete &quot;
                                + &quot;type can increase performance.&quot;);
            } else {
<span class="fc" id="L2093">                LOG.info(</span>
                        clazz
                                + &quot; is missing a default constructor so it cannot be used as a POJO type &quot;
                                + &quot;and must be processed as GenericType. Please read the Flink documentation &quot;
                                + &quot;on \&quot;Data Types &amp; Serialization\&quot; for details of the effect on performance.&quot;);
<span class="fc" id="L2098">                return null;</span>
            }
<span class="fc" id="L2100">        }</span>
<span class="pc bpc" id="L2101" title="1 of 4 branches missed.">        if (defaultConstructor != null &amp;&amp; !Modifier.isPublic(defaultConstructor.getModifiers())) {</span>
<span class="fc" id="L2102">            LOG.info(</span>
                    &quot;The default constructor of &quot;
                            + clazz
                            + &quot; is not Public so it cannot be used as a POJO type &quot;
                            + &quot;and must be processed as GenericType. Please read the Flink documentation &quot;
                            + &quot;on \&quot;Data Types &amp; Serialization\&quot; for details of the effect on performance.&quot;);
<span class="fc" id="L2108">            return null;</span>
        }

        // everything is checked, we return the pojo
<span class="fc" id="L2112">        return pojoType;</span>
    }

    /**
     * Recursively determine all declared fields This is required because class.getFields() is not
     * returning fields defined in parent classes.
     *
     * @param clazz class to be analyzed
     * @param ignoreDuplicates if true, in case of duplicate field names only the lowest one in a
     *     hierarchy will be returned; throws an exception otherwise
     * @return list of fields
     */
    @PublicEvolving
    public static List&lt;Field&gt; getAllDeclaredFields(Class&lt;?&gt; clazz, boolean ignoreDuplicates) {
<span class="fc" id="L2126">        List&lt;Field&gt; result = new ArrayList&lt;&gt;();</span>
<span class="fc bfc" id="L2127" title="All 2 branches covered.">        while (clazz != null) {</span>
<span class="fc" id="L2128">            Field[] fields = clazz.getDeclaredFields();</span>
<span class="fc bfc" id="L2129" title="All 2 branches covered.">            for (Field field : fields) {</span>
<span class="fc bfc" id="L2130" title="All 2 branches covered.">                if (Modifier.isTransient(field.getModifiers())</span>
<span class="fc bfc" id="L2131" title="All 2 branches covered.">                        || Modifier.isStatic(field.getModifiers())) {</span>
<span class="fc" id="L2132">                    continue; // we have no use for transient or static fields</span>
                }
<span class="fc bfc" id="L2134" title="All 2 branches covered.">                if (hasFieldWithSameName(field.getName(), result)) {</span>
<span class="pc bpc" id="L2135" title="1 of 2 branches missed.">                    if (ignoreDuplicates) {</span>
<span class="nc" id="L2136">                        continue;</span>
                    } else {
<span class="fc" id="L2138">                        throw new InvalidTypesException(</span>
                                &quot;The field &quot;
                                        + field
                                        + &quot; is already contained in the hierarchy of the &quot;
                                        + clazz
                                        + &quot;.&quot;
                                        + &quot;Please use unique field names through your classes hierarchy&quot;);
                    }
                }
<span class="fc" id="L2147">                result.add(field);</span>
            }
<span class="fc" id="L2149">            clazz = clazz.getSuperclass();</span>
<span class="fc" id="L2150">        }</span>
<span class="fc" id="L2151">        return result;</span>
    }

    @PublicEvolving
    public static Field getDeclaredField(Class&lt;?&gt; clazz, String name) {
<span class="pc bpc" id="L2156" title="1 of 2 branches missed.">        for (Field field : getAllDeclaredFields(clazz, true)) {</span>
<span class="fc bfc" id="L2157" title="All 2 branches covered.">            if (field.getName().equals(name)) {</span>
<span class="fc" id="L2158">                return field;</span>
            }
<span class="fc" id="L2160">        }</span>
<span class="nc" id="L2161">        return null;</span>
    }

    private static boolean hasFieldWithSameName(String name, List&lt;Field&gt; fields) {
<span class="fc bfc" id="L2165" title="All 2 branches covered.">        for (Field field : fields) {</span>
<span class="fc bfc" id="L2166" title="All 2 branches covered.">            if (name.equals(field.getName())) {</span>
<span class="fc" id="L2167">                return true;</span>
            }
<span class="fc" id="L2169">        }</span>
<span class="fc" id="L2170">        return false;</span>
    }

    private static TypeInformation&lt;?&gt; getTypeOfPojoField(TypeInformation&lt;?&gt; pojoInfo, Field field) {
<span class="pc bpc" id="L2174" title="1 of 2 branches missed.">        for (int j = 0; j &lt; pojoInfo.getArity(); j++) {</span>
<span class="fc" id="L2175">            PojoField pf = ((PojoTypeInfo&lt;?&gt;) pojoInfo).getPojoFieldAt(j);</span>
<span class="fc bfc" id="L2176" title="All 2 branches covered.">            if (pf.getField().getName().equals(field.getName())) {</span>
<span class="fc" id="L2177">                return pf.getTypeInformation();</span>
            }
        }
<span class="nc" id="L2180">        return null;</span>
    }

    public static &lt;X&gt; TypeInformation&lt;X&gt; getForObject(X value) {
<span class="fc" id="L2184">        return new TypeExtractor().privateGetForObject(value);</span>
    }

    @SuppressWarnings({&quot;unchecked&quot;, &quot;rawtypes&quot;})
    private &lt;X&gt; TypeInformation&lt;X&gt; privateGetForObject(X value) {
<span class="fc" id="L2189">        checkNotNull(value);</span>

        // check if type information can be produced using a factory
<span class="fc" id="L2192">        final List&lt;Type&gt; typeHierarchy = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L2193">        typeHierarchy.add(value.getClass());</span>
<span class="fc" id="L2194">        final TypeInformation&lt;X&gt; typeFromFactory =</span>
<span class="fc" id="L2195">                createTypeInfoFromFactory(value.getClass(), typeHierarchy, null, null);</span>
<span class="fc bfc" id="L2196" title="All 2 branches covered.">        if (typeFromFactory != null) {</span>
<span class="fc" id="L2197">            return typeFromFactory;</span>
        }

        // check if we can extract the types from tuples, otherwise work with the class
<span class="fc bfc" id="L2201" title="All 2 branches covered.">        if (value instanceof Tuple) {</span>
<span class="fc" id="L2202">            Tuple t = (Tuple) value;</span>
<span class="fc" id="L2203">            int numFields = t.getArity();</span>
<span class="fc bfc" id="L2204" title="All 2 branches covered.">            if (numFields != countFieldsInClass(value.getClass())) {</span>
                // not a tuple since it has more fields.
<span class="fc" id="L2206">                return analyzePojo(</span>
<span class="fc" id="L2207">                        value.getClass(),</span>
                        new ArrayList&lt;&gt;(),
                        null,
                        null); // we immediately call analyze Pojo here, because
                // there is currently no other type that can handle such a class.
            }

<span class="fc" id="L2214">            TypeInformation&lt;?&gt;[] infos = new TypeInformation[numFields];</span>
<span class="fc bfc" id="L2215" title="All 2 branches covered.">            for (int i = 0; i &lt; numFields; i++) {</span>
<span class="fc" id="L2216">                Object field = t.getField(i);</span>

<span class="pc bpc" id="L2218" title="1 of 2 branches missed.">                if (field == null) {</span>
<span class="nc" id="L2219">                    throw new InvalidTypesException(</span>
                            &quot;Automatic type extraction is not possible on candidates with null values. &quot;
                                    + &quot;Please specify the types directly.&quot;);
                }

<span class="fc" id="L2224">                infos[i] = privateGetForObject(field);</span>
            }
<span class="fc" id="L2226">            return new TupleTypeInfo(value.getClass(), infos);</span>
<span class="fc bfc" id="L2227" title="All 2 branches covered.">        } else if (value instanceof Row) {</span>
<span class="fc" id="L2228">            Row row = (Row) value;</span>
<span class="fc" id="L2229">            int arity = row.getArity();</span>
<span class="fc bfc" id="L2230" title="All 2 branches covered.">            for (int i = 0; i &lt; arity; i++) {</span>
<span class="fc bfc" id="L2231" title="All 2 branches covered.">                if (row.getField(i) == null) {</span>
<span class="fc" id="L2232">                    LOG.warn(</span>
                            &quot;Cannot extract type of Row field, because of Row field[&quot;
                                    + i
                                    + &quot;] is null. &quot;
                                    + &quot;Should define RowTypeInfo explicitly.&quot;);
<span class="fc" id="L2237">                    return privateGetForClass((Class&lt;X&gt;) value.getClass(), new ArrayList&lt;&gt;());</span>
                }
            }
<span class="fc" id="L2240">            TypeInformation&lt;?&gt;[] typeArray = new TypeInformation&lt;?&gt;[arity];</span>
<span class="fc bfc" id="L2241" title="All 2 branches covered.">            for (int i = 0; i &lt; arity; i++) {</span>
<span class="fc" id="L2242">                typeArray[i] = TypeExtractor.getForObject(row.getField(i));</span>
            }
<span class="fc" id="L2244">            return (TypeInformation&lt;X&gt;) new RowTypeInfo(typeArray);</span>
        } else {
<span class="fc" id="L2246">            return privateGetForClass((Class&lt;X&gt;) value.getClass(), new ArrayList&lt;&gt;());</span>
        }
    }

    // ------------------------------------------------------------------------
    //  Utilities to handle Hadoop's 'Writable' type via reflection
    // ------------------------------------------------------------------------

    // visible for testing
    static boolean isHadoopWritable(Class&lt;?&gt; typeClass) {
        // check if this is directly the writable interface
<span class="pc bpc" id="L2257" title="1 of 2 branches missed.">        if (typeClass.getName().equals(HADOOP_WRITABLE_CLASS)) {</span>
<span class="nc" id="L2258">            return false;</span>
        }

<span class="fc" id="L2261">        final HashSet&lt;Class&lt;?&gt;&gt; alreadySeen = new HashSet&lt;&gt;();</span>
<span class="fc" id="L2262">        alreadySeen.add(typeClass);</span>
<span class="fc" id="L2263">        return hasHadoopWritableInterface(typeClass, alreadySeen);</span>
    }

    private static boolean hasHadoopWritableInterface(
            Class&lt;?&gt; clazz, HashSet&lt;Class&lt;?&gt;&gt; alreadySeen) {
<span class="fc" id="L2268">        Class&lt;?&gt;[] interfaces = clazz.getInterfaces();</span>
<span class="fc bfc" id="L2269" title="All 2 branches covered.">        for (Class&lt;?&gt; c : interfaces) {</span>
<span class="pc bpc" id="L2270" title="1 of 2 branches missed.">            if (c.getName().equals(HADOOP_WRITABLE_CLASS)) {</span>
<span class="nc" id="L2271">                return true;</span>
<span class="pc bpc" id="L2272" title="1 of 4 branches missed.">            } else if (alreadySeen.add(c) &amp;&amp; hasHadoopWritableInterface(c, alreadySeen)) {</span>
<span class="nc" id="L2273">                return true;</span>
            }
        }

<span class="fc" id="L2277">        Class&lt;?&gt; superclass = clazz.getSuperclass();</span>
<span class="fc bfc" id="L2278" title="All 2 branches covered.">        return superclass != null</span>
<span class="pc bpc" id="L2279" title="1 of 2 branches missed.">                &amp;&amp; alreadySeen.add(superclass)</span>
<span class="pc bpc" id="L2280" title="1 of 2 branches missed.">                &amp;&amp; hasHadoopWritableInterface(superclass, alreadySeen);</span>
    }

    // visible for testing
    public static &lt;T&gt; TypeInformation&lt;T&gt; createHadoopWritableTypeInfo(Class&lt;T&gt; clazz) {
<span class="nc" id="L2285">        checkNotNull(clazz);</span>

        Class&lt;?&gt; typeInfoClass;
        try {
<span class="nc" id="L2289">            typeInfoClass =</span>
<span class="nc" id="L2290">                    Class.forName(</span>
                            HADOOP_WRITABLE_TYPEINFO_CLASS,
                            false,
<span class="nc" id="L2293">                            Thread.currentThread().getContextClassLoader());</span>
<span class="nc" id="L2294">        } catch (ClassNotFoundException e) {</span>
<span class="nc" id="L2295">            throw new RuntimeException(</span>
                    &quot;Could not load the TypeInformation for the class '&quot;
                            + HADOOP_WRITABLE_CLASS
                            + &quot;'. You may be missing the 'flink-hadoop-compatibility' dependency.&quot;);
<span class="nc" id="L2299">        }</span>

        try {
<span class="nc" id="L2302">            Constructor&lt;?&gt; constr = typeInfoClass.getConstructor(Class.class);</span>

            @SuppressWarnings(&quot;unchecked&quot;)
<span class="nc" id="L2305">            TypeInformation&lt;T&gt; typeInfo = (TypeInformation&lt;T&gt;) constr.newInstance(clazz);</span>
<span class="nc" id="L2306">            return typeInfo;</span>
<span class="nc" id="L2307">        } catch (NoSuchMethodException | IllegalAccessException | InstantiationException e) {</span>
<span class="nc" id="L2308">            throw new RuntimeException(</span>
                    &quot;Incompatible versions of the Hadoop Compatibility classes found.&quot;);
<span class="nc" id="L2310">        } catch (InvocationTargetException e) {</span>
<span class="nc" id="L2311">            throw new RuntimeException(</span>
<span class="nc" id="L2312">                    &quot;Cannot create Hadoop WritableTypeInfo.&quot;, e.getTargetException());</span>
        }
    }

    // visible for testing
    static void validateIfWritable(TypeInformation&lt;?&gt; typeInfo, Type type) {
        try {
            // try to load the writable type info

<span class="fc" id="L2321">            Class&lt;?&gt; writableTypeInfoClass =</span>
<span class="nc" id="L2322">                    Class.forName(</span>
                            HADOOP_WRITABLE_TYPEINFO_CLASS,
                            false,
<span class="fc" id="L2325">                            typeInfo.getClass().getClassLoader());</span>

<span class="nc bnc" id="L2327" title="All 2 branches missed.">            if (writableTypeInfoClass.isAssignableFrom(typeInfo.getClass())) {</span>
                // this is actually a writable type info
                // check if the type is a writable
<span class="nc bnc" id="L2330" title="All 4 branches missed.">                if (!(type instanceof Class &amp;&amp; isHadoopWritable((Class&lt;?&gt;) type))) {</span>
<span class="nc" id="L2331">                    throw new InvalidTypesException(HADOOP_WRITABLE_CLASS + &quot; type expected.&quot;);</span>
                }

                // check writable type contents
<span class="nc" id="L2335">                Class&lt;?&gt; clazz = (Class&lt;?&gt;) type;</span>
<span class="nc bnc" id="L2336" title="All 2 branches missed.">                if (typeInfo.getTypeClass() != clazz) {</span>
<span class="nc" id="L2337">                    throw new InvalidTypesException(</span>
                            &quot;Writable type '&quot;
<span class="nc" id="L2339">                                    + typeInfo.getTypeClass().getCanonicalName()</span>
                                    + &quot;' expected but was '&quot;
<span class="nc" id="L2341">                                    + clazz.getCanonicalName()</span>
                                    + &quot;'.&quot;);
                }
            }
<span class="fc" id="L2345">        } catch (ClassNotFoundException e) {</span>
            // class not present at all, so cannot be that type info
            // ignore
<span class="nc" id="L2348">        }</span>
<span class="fc" id="L2349">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.7.202105040129</span></div></body></html>