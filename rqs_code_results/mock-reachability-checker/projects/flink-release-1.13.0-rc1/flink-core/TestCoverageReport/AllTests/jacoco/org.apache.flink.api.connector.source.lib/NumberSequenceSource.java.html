<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>NumberSequenceSource.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Flink : Core</a> &gt; <a href="index.source.html" class="el_package">org.apache.flink.api.connector.source.lib</a> &gt; <span class="el_source">NumberSequenceSource.java</span></div><h1>NumberSequenceSource.java</h1><pre class="source lang-java linenums">/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * &quot;License&quot;); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.apache.flink.api.connector.source.lib;

import org.apache.flink.api.common.typeinfo.TypeInformation;
import org.apache.flink.api.common.typeinfo.Types;
import org.apache.flink.api.connector.source.Boundedness;
import org.apache.flink.api.connector.source.Source;
import org.apache.flink.api.connector.source.SourceReader;
import org.apache.flink.api.connector.source.SourceReaderContext;
import org.apache.flink.api.connector.source.SplitEnumerator;
import org.apache.flink.api.connector.source.SplitEnumeratorContext;
import org.apache.flink.api.connector.source.lib.util.IteratorSourceEnumerator;
import org.apache.flink.api.connector.source.lib.util.IteratorSourceReader;
import org.apache.flink.api.connector.source.lib.util.IteratorSourceSplit;
import org.apache.flink.api.java.typeutils.ResultTypeQueryable;
import org.apache.flink.core.io.SimpleVersionedSerializer;
import org.apache.flink.core.memory.DataInputDeserializer;
import org.apache.flink.core.memory.DataInputView;
import org.apache.flink.core.memory.DataOutputSerializer;
import org.apache.flink.core.memory.DataOutputView;
import org.apache.flink.util.NumberSequenceIterator;

import java.io.IOException;
import java.util.ArrayList;
import java.util.Collection;
import java.util.List;

import static org.apache.flink.util.Preconditions.checkArgument;
import static org.apache.flink.util.Preconditions.checkNotNull;

/**
 * A data source that produces a sequence of numbers (longs). This source is useful for testing and
 * for cases that just need a stream of N events of any kind.
 *
 * &lt;p&gt;The source splits the sequence into as many parallel sub-sequences as there are parallel
 * source readers. Each sub-sequence will be produced in order. Consequently, if the parallelism is
 * limited to one, this will produce one sequence in order.
 *
 * &lt;p&gt;This source is always bounded. For very long sequences (for example over the entire domain of
 * long integer values), user may want to consider executing the application in a streaming manner,
 * because, despite the fact that the produced stream is bounded, the end bound is pretty far away.
 */
public class NumberSequenceSource
        implements Source&lt;
                        Long,
                        NumberSequenceSource.NumberSequenceSplit,
                        Collection&lt;NumberSequenceSource.NumberSequenceSplit&gt;&gt;,
                ResultTypeQueryable&lt;Long&gt; {

    private static final long serialVersionUID = 1L;

    /** The starting number in the sequence, inclusive. */
    private final long from;

    /** The end number in the sequence, inclusive. */
    private final long to;

    /**
     * Creates a new {@code NumberSequenceSource} that produces parallel sequences covering the
     * range {@code from} to {@code to} (both boundaries are inclusive).
     */
<span class="fc" id="L79">    public NumberSequenceSource(long from, long to) {</span>
<span class="pc bpc" id="L80" title="1 of 2 branches missed.">        checkArgument(from &lt;= to, &quot;'from' must be &lt;= 'to'&quot;);</span>
<span class="fc" id="L81">        this.from = from;</span>
<span class="fc" id="L82">        this.to = to;</span>
<span class="fc" id="L83">    }</span>

    public long getFrom() {
<span class="nc" id="L86">        return from;</span>
    }

    public long getTo() {
<span class="nc" id="L90">        return to;</span>
    }

    // ------------------------------------------------------------------------
    //  source methods
    // ------------------------------------------------------------------------

    @Override
    public TypeInformation&lt;Long&gt; getProducedType() {
<span class="nc" id="L99">        return Types.LONG;</span>
    }

    @Override
    public Boundedness getBoundedness() {
<span class="nc" id="L104">        return Boundedness.BOUNDED;</span>
    }

    @Override
    public SourceReader&lt;Long, NumberSequenceSplit&gt; createReader(SourceReaderContext readerContext) {
<span class="fc" id="L109">        return new IteratorSourceReader&lt;&gt;(readerContext);</span>
    }

    @Override
    public SplitEnumerator&lt;NumberSequenceSplit, Collection&lt;NumberSequenceSplit&gt;&gt; createEnumerator(
            final SplitEnumeratorContext&lt;NumberSequenceSplit&gt; enumContext) {

<span class="nc" id="L116">        final List&lt;NumberSequenceSplit&gt; splits =</span>
<span class="nc" id="L117">                splitNumberRange(from, to, enumContext.currentParallelism());</span>
<span class="nc" id="L118">        return new IteratorSourceEnumerator&lt;&gt;(enumContext, splits);</span>
    }

    @Override
    public SplitEnumerator&lt;NumberSequenceSplit, Collection&lt;NumberSequenceSplit&gt;&gt; restoreEnumerator(
            final SplitEnumeratorContext&lt;NumberSequenceSplit&gt; enumContext,
            Collection&lt;NumberSequenceSplit&gt; checkpoint) {
<span class="nc" id="L125">        return new IteratorSourceEnumerator&lt;&gt;(enumContext, checkpoint);</span>
    }

    @Override
    public SimpleVersionedSerializer&lt;NumberSequenceSplit&gt; getSplitSerializer() {
<span class="nc" id="L130">        return new SplitSerializer();</span>
    }

    @Override
    public SimpleVersionedSerializer&lt;Collection&lt;NumberSequenceSplit&gt;&gt;
            getEnumeratorCheckpointSerializer() {
<span class="nc" id="L136">        return new CheckpointSerializer();</span>
    }

    protected List&lt;NumberSequenceSplit&gt; splitNumberRange(long from, long to, int numSplits) {
<span class="nc" id="L140">        final NumberSequenceIterator[] subSequences =</span>
<span class="nc" id="L141">                new NumberSequenceIterator(from, to).split(numSplits);</span>
<span class="nc" id="L142">        final ArrayList&lt;NumberSequenceSplit&gt; splits = new ArrayList&lt;&gt;(subSequences.length);</span>

<span class="nc" id="L144">        int splitId = 1;</span>
<span class="nc bnc" id="L145" title="All 2 branches missed.">        for (NumberSequenceIterator seq : subSequences) {</span>
<span class="nc bnc" id="L146" title="All 2 branches missed.">            if (seq.hasNext()) {</span>
<span class="nc" id="L147">                splits.add(</span>
                        new NumberSequenceSplit(
<span class="nc" id="L149">                                String.valueOf(splitId++), seq.getCurrent(), seq.getTo()));</span>
            }
        }

<span class="nc" id="L153">        return splits;</span>
    }

    // ------------------------------------------------------------------------
    //  splits &amp; checkpoint
    // ------------------------------------------------------------------------

    /** A split of the source, representing a number sub-sequence. */
    public static class NumberSequenceSplit
            implements IteratorSourceSplit&lt;Long, NumberSequenceIterator&gt; {

        private final String splitId;
        private final long from;
        private final long to;

<span class="fc" id="L168">        public NumberSequenceSplit(String splitId, long from, long to) {</span>
<span class="pc bpc" id="L169" title="1 of 2 branches missed.">            checkArgument(from &lt;= to, &quot;'from' must be &lt;= 'to'&quot;);</span>
<span class="fc" id="L170">            this.splitId = checkNotNull(splitId);</span>
<span class="fc" id="L171">            this.from = from;</span>
<span class="fc" id="L172">            this.to = to;</span>
<span class="fc" id="L173">        }</span>

        @Override
        public String splitId() {
<span class="nc" id="L177">            return splitId;</span>
        }

        public long from() {
<span class="nc" id="L181">            return from;</span>
        }

        public long to() {
<span class="nc" id="L185">            return to;</span>
        }

        @Override
        public NumberSequenceIterator getIterator() {
<span class="fc" id="L190">            return new NumberSequenceIterator(from, to);</span>
        }

        @Override
        public IteratorSourceSplit&lt;Long, NumberSequenceIterator&gt; getUpdatedSplitForIterator(
                final NumberSequenceIterator iterator) {
<span class="fc" id="L196">            return new NumberSequenceSplit(splitId, iterator.getCurrent(), iterator.getTo());</span>
        }

        @Override
        public String toString() {
<span class="nc" id="L201">            return String.format(&quot;NumberSequenceSplit [%d, %d] (%s)&quot;, from, to, splitId);</span>
        }
    }

    private static final class SplitSerializer
            implements SimpleVersionedSerializer&lt;NumberSequenceSplit&gt; {

        private static final int CURRENT_VERSION = 1;

        @Override
        public int getVersion() {
<span class="nc" id="L212">            return CURRENT_VERSION;</span>
        }

        @Override
        public byte[] serialize(NumberSequenceSplit split) throws IOException {
<span class="nc" id="L217">            checkArgument(</span>
<span class="nc bnc" id="L218" title="All 2 branches missed.">                    split.getClass() == NumberSequenceSplit.class, &quot;cannot serialize subclasses&quot;);</span>

            // We will serialize 2 longs (16 bytes) plus the UFT representation of the string (2 +
            // length)
<span class="nc" id="L222">            final DataOutputSerializer out =</span>
<span class="nc" id="L223">                    new DataOutputSerializer(split.splitId().length() + 18);</span>
<span class="nc" id="L224">            serializeV1(out, split);</span>
<span class="nc" id="L225">            return out.getCopyOfBuffer();</span>
        }

        @Override
        public NumberSequenceSplit deserialize(int version, byte[] serialized) throws IOException {
<span class="nc bnc" id="L230" title="All 2 branches missed.">            if (version != CURRENT_VERSION) {</span>
<span class="nc" id="L231">                throw new IOException(&quot;Unrecognized version: &quot; + version);</span>
            }
<span class="nc" id="L233">            final DataInputDeserializer in = new DataInputDeserializer(serialized);</span>
<span class="nc" id="L234">            return deserializeV1(in);</span>
        }

        static void serializeV1(DataOutputView out, NumberSequenceSplit split) throws IOException {
<span class="nc" id="L238">            out.writeUTF(split.splitId());</span>
<span class="nc" id="L239">            out.writeLong(split.from());</span>
<span class="nc" id="L240">            out.writeLong(split.to());</span>
<span class="nc" id="L241">        }</span>

        static NumberSequenceSplit deserializeV1(DataInputView in) throws IOException {
<span class="nc" id="L244">            return new NumberSequenceSplit(in.readUTF(), in.readLong(), in.readLong());</span>
        }
    }

    private static final class CheckpointSerializer
            implements SimpleVersionedSerializer&lt;Collection&lt;NumberSequenceSplit&gt;&gt; {

        private static final int CURRENT_VERSION = 1;

        @Override
        public int getVersion() {
<span class="nc" id="L255">            return CURRENT_VERSION;</span>
        }

        @Override
        public byte[] serialize(Collection&lt;NumberSequenceSplit&gt; checkpoint) throws IOException {
            // Each split needs 2 longs (16 bytes) plus the UFT representation of the string (2 +
            // length)
            // Assuming at most 4 digit split IDs, 22 bytes per split avoids any intermediate array
            // resizing.
            // plus four bytes for the length field
<span class="nc" id="L265">            final DataOutputSerializer out = new DataOutputSerializer(checkpoint.size() * 22 + 4);</span>
<span class="nc" id="L266">            out.writeInt(checkpoint.size());</span>
<span class="nc bnc" id="L267" title="All 2 branches missed.">            for (NumberSequenceSplit split : checkpoint) {</span>
<span class="nc" id="L268">                SplitSerializer.serializeV1(out, split);</span>
<span class="nc" id="L269">            }</span>
<span class="nc" id="L270">            return out.getCopyOfBuffer();</span>
        }

        @Override
        public Collection&lt;NumberSequenceSplit&gt; deserialize(int version, byte[] serialized)
                throws IOException {
<span class="nc bnc" id="L276" title="All 2 branches missed.">            if (version != CURRENT_VERSION) {</span>
<span class="nc" id="L277">                throw new IOException(&quot;Unrecognized version: &quot; + version);</span>
            }
<span class="nc" id="L279">            final DataInputDeserializer in = new DataInputDeserializer(serialized);</span>
<span class="nc" id="L280">            final int num = in.readInt();</span>
<span class="nc" id="L281">            final ArrayList&lt;NumberSequenceSplit&gt; result = new ArrayList&lt;&gt;(num);</span>
<span class="nc bnc" id="L282" title="All 2 branches missed.">            for (int remaining = num; remaining &gt; 0; remaining--) {</span>
<span class="nc" id="L283">                result.add(SplitSerializer.deserializeV1(in));</span>
            }
<span class="nc" id="L285">            return result;</span>
        }
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.7.202105040129</span></div></body></html>