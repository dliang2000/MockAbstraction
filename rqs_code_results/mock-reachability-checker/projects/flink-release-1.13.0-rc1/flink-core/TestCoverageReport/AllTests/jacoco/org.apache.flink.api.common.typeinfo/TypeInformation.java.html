<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>TypeInformation.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Flink : Core</a> &gt; <a href="index.source.html" class="el_package">org.apache.flink.api.common.typeinfo</a> &gt; <span class="el_source">TypeInformation.java</span></div><h1>TypeInformation.java</h1><pre class="source lang-java linenums">/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * &quot;License&quot;); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.apache.flink.api.common.typeinfo;

import org.apache.flink.annotation.Public;
import org.apache.flink.annotation.PublicEvolving;
import org.apache.flink.api.common.ExecutionConfig;
import org.apache.flink.api.common.functions.InvalidTypesException;
import org.apache.flink.api.common.typeutils.TypeSerializer;
import org.apache.flink.api.java.tuple.Tuple2;
import org.apache.flink.api.java.typeutils.TypeExtractor;
import org.apache.flink.util.FlinkRuntimeException;

import java.io.Serializable;
import java.util.Collections;
import java.util.Map;

/**
 * TypeInformation is the core class of Flink's type system. Flink requires a type information for
 * all types that are used as input or return type of a user function. This type information class
 * acts as the tool to generate serializers and comparators, and to perform semantic checks such as
 * whether the fields that are used as join/grouping keys actually exist.
 *
 * &lt;p&gt;The type information also bridges between the programming languages object model and a logical
 * flat schema. It maps fields from the types to columns (fields) in a flat schema. Not all fields
 * from a type are mapped to a separate fields in the flat schema and often, entire types are mapped
 * to one field. It is important to notice that the schema must hold for all instances of a type.
 * For that reason, elements in lists and arrays are not assigned to individual fields, but the
 * lists and arrays are considered to be one field in total, to account for different lengths in the
 * arrays.
 *
 * &lt;ul&gt;
 *   &lt;li&gt;Basic types are indivisible and are considered a single field.
 *   &lt;li&gt;Arrays and collections are one field
 *   &lt;li&gt;Tuples and case classes represent as many fields as the class has fields
 * &lt;/ul&gt;
 *
 * &lt;p&gt;To represent this properly, each type has an &lt;i&gt;arity&lt;/i&gt; (the number of fields it contains
 * directly), and a &lt;i&gt;total number of fields&lt;/i&gt; (number of fields in the entire schema of this
 * type, including nested types).
 *
 * &lt;p&gt;Consider the example below:
 *
 * &lt;pre&gt;{@code
 * public class InnerType {
 *   public int id;
 *   public String text;
 * }
 *
 * public class OuterType {
 *   public long timestamp;
 *   public InnerType nestedType;
 * }
 * }&lt;/pre&gt;
 *
 * &lt;p&gt;The types &quot;id&quot;, &quot;text&quot;, and &quot;timestamp&quot; are basic types that take up one field. The
 * &quot;InnerType&quot; has an arity of two, and also two fields totally. The &quot;OuterType&quot; has an arity of two
 * fields, and a total number of three fields ( it contains &quot;id&quot;, &quot;text&quot;, and &quot;timestamp&quot; through
 * recursive flattening).
 *
 * @param &lt;T&gt; The type represented by this type information.
 */
@Public
<span class="fc" id="L80">public abstract class TypeInformation&lt;T&gt; implements Serializable {</span>

    private static final long serialVersionUID = -7742311969684489493L;

    /**
     * Checks if this type information represents a basic type. Basic types are defined in {@link
     * BasicTypeInfo} and are primitives, their boxing types, Strings, Date, Void, ...
     *
     * @return True, if this type information describes a basic type, false otherwise.
     */
    @PublicEvolving
    public abstract boolean isBasicType();

    /**
     * Checks if this type information represents a Tuple type. Tuple types are subclasses of the
     * Java API tuples.
     *
     * @return True, if this type information describes a tuple type, false otherwise.
     */
    @PublicEvolving
    public abstract boolean isTupleType();

    /**
     * Gets the arity of this type - the number of fields without nesting.
     *
     * @return Gets the number of fields in this type without nesting.
     */
    @PublicEvolving
    public abstract int getArity();

    /**
     * Gets the number of logical fields in this type. This includes its nested and transitively
     * nested fields, in the case of composite types. In the example above, the OuterType type has
     * three fields in total.
     *
     * &lt;p&gt;The total number of fields must be at least 1.
     *
     * @return The number of fields in this type, including its sub-fields (for composite types)
     */
    @PublicEvolving
    public abstract int getTotalFields();

    /**
     * Gets the class of the type represented by this type information.
     *
     * @return The class of the type represented by this type information.
     */
    @PublicEvolving
    public abstract Class&lt;T&gt; getTypeClass();

    /**
     * Optional method for giving Flink's type extraction system information about the mapping of a
     * generic type parameter to the type information of a subtype. This information is necessary in
     * cases where type information should be deduced from an input type.
     *
     * &lt;p&gt;For instance, a method for a {@link Tuple2} would look like this: &lt;code&gt;
     * Map m = new HashMap();
     * m.put(&quot;T0&quot;, this.getTypeAt(0));
     * m.put(&quot;T1&quot;, this.getTypeAt(1));
     * return m;
     * &lt;/code&gt;
     *
     * @return map of inferred subtypes; it does not have to contain all generic parameters as key;
     *     values may be null if type could not be inferred
     */
    @PublicEvolving
    public Map&lt;String, TypeInformation&lt;?&gt;&gt; getGenericParameters() {
        // return an empty map as the default implementation
<span class="fc" id="L148">        return Collections.emptyMap();</span>
    }

    /**
     * Checks whether this type can be used as a key. As a bare minimum, types have to be hashable
     * and comparable to be keys.
     *
     * @return True, if the type can be used as a key, false otherwise.
     */
    @PublicEvolving
    public abstract boolean isKeyType();

    /**
     * Checks whether this type can be used as a key for sorting. The order produced by sorting this
     * type must be meaningful.
     */
    @PublicEvolving
    public boolean isSortKeyType() {
<span class="nc" id="L166">        return isKeyType();</span>
    }

    /**
     * Creates a serializer for the type. The serializer may use the ExecutionConfig for
     * parameterization.
     *
     * @param config The config used to parameterize the serializer.
     * @return A serializer for this type.
     */
    @PublicEvolving
    public abstract TypeSerializer&lt;T&gt; createSerializer(ExecutionConfig config);

    @Override
    public abstract String toString();

    @Override
    public abstract boolean equals(Object obj);

    @Override
    public abstract int hashCode();

    /**
     * Returns true if the given object can be equaled with this object. If not, it returns false.
     *
     * @param obj Object which wants to take part in the equality relation
     * @return true if obj can be equaled with this, otherwise false
     */
    public abstract boolean canEqual(Object obj);

    // ------------------------------------------------------------------------

    /**
     * Creates a TypeInformation for the type described by the given class.
     *
     * &lt;p&gt;This method only works for non-generic types. For generic types, use the {@link
     * #of(TypeHint)} method.
     *
     * @param typeClass The class of the type.
     * @param &lt;T&gt; The generic type.
     * @return The TypeInformation object for the type described by the hint.
     */
    public static &lt;T&gt; TypeInformation&lt;T&gt; of(Class&lt;T&gt; typeClass) {
        try {
<span class="fc" id="L210">            return TypeExtractor.createTypeInfo(typeClass);</span>
<span class="fc" id="L211">        } catch (InvalidTypesException e) {</span>
<span class="fc" id="L212">            throw new FlinkRuntimeException(</span>
                    &quot;Cannot extract TypeInformation from Class alone, because generic parameters are missing. &quot;
                            + &quot;Please use TypeInformation.of(TypeHint) instead, or another equivalent method in the API that &quot;
                            + &quot;accepts a TypeHint instead of a Class. &quot;
                            + &quot;For example for a Tuple2&lt;Long, String&gt; pass a 'new TypeHint&lt;Tuple2&lt;Long, String&gt;&gt;(){}'.&quot;);
        }
    }

    /**
     * Creates a TypeInformation for a generic type via a utility &quot;type hint&quot;. This method can be
     * used as follows:
     *
     * &lt;pre&gt;{@code
     * TypeInformation&lt;Tuple2&lt;String, Long&gt;&gt; info = TypeInformation.of(new TypeHint&lt;Tuple2&lt;String, Long&gt;&gt;(){});
     * }&lt;/pre&gt;
     *
     * @param typeHint The hint for the generic type.
     * @param &lt;T&gt; The generic type.
     * @return The TypeInformation object for the type described by the hint.
     */
    public static &lt;T&gt; TypeInformation&lt;T&gt; of(TypeHint&lt;T&gt; typeHint) {
<span class="fc" id="L233">        return typeHint.getTypeInfo();</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.7.202105040129</span></div></body></html>