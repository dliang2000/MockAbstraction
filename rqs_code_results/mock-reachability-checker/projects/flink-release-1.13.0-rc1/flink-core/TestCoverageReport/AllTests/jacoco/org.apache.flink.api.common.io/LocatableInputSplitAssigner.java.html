<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>LocatableInputSplitAssigner.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Flink : Core</a> &gt; <a href="index.source.html" class="el_package">org.apache.flink.api.common.io</a> &gt; <span class="el_source">LocatableInputSplitAssigner.java</span></div><h1>LocatableInputSplitAssigner.java</h1><pre class="source lang-java linenums">/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * &quot;License&quot;); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.apache.flink.api.common.io;

import org.apache.flink.annotation.Public;
import org.apache.flink.core.io.InputSplit;
import org.apache.flink.core.io.InputSplitAssigner;
import org.apache.flink.core.io.LocatableInputSplit;
import org.apache.flink.util.NetUtils;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.util.Collection;
import java.util.HashSet;
import java.util.LinkedList;
import java.util.List;
import java.util.Locale;
import java.util.Set;
import java.util.concurrent.ConcurrentHashMap;

/**
 * The locatable input split assigner assigns to each host splits that are local, before assigning
 * splits that are not local.
 */
@Public
public final class LocatableInputSplitAssigner implements InputSplitAssigner {

<span class="fc" id="L45">    private static final Logger LOG = LoggerFactory.getLogger(LocatableInputSplitAssigner.class);</span>

    // unassigned input splits
<span class="pc" id="L48">    private final Set&lt;LocatableInputSplitWithCount&gt; unassigned =</span>
            new HashSet&lt;LocatableInputSplitWithCount&gt;();

    // input splits indexed by host for local assignment
<span class="pc" id="L52">    private final ConcurrentHashMap&lt;String, LocatableInputSplitChooser&gt; localPerHost =</span>
            new ConcurrentHashMap&lt;String, LocatableInputSplitChooser&gt;();

    // unassigned splits for remote assignment
    private final LocatableInputSplitChooser remoteSplitChooser;

    private int localAssignments; // lock protected by the unassigned set lock

    private int remoteAssignments; // lock protected by the unassigned set lock

    // --------------------------------------------------------------------------------------------

<span class="fc" id="L64">    public LocatableInputSplitAssigner(Collection&lt;LocatableInputSplit&gt; splits) {</span>
<span class="fc bfc" id="L65" title="All 2 branches covered.">        for (LocatableInputSplit split : splits) {</span>
<span class="fc" id="L66">            this.unassigned.add(new LocatableInputSplitWithCount(split));</span>
<span class="fc" id="L67">        }</span>
<span class="fc" id="L68">        this.remoteSplitChooser = new LocatableInputSplitChooser(unassigned);</span>
<span class="fc" id="L69">    }</span>

<span class="nc" id="L71">    public LocatableInputSplitAssigner(LocatableInputSplit[] splits) {</span>
<span class="nc bnc" id="L72" title="All 2 branches missed.">        for (LocatableInputSplit split : splits) {</span>
<span class="nc" id="L73">            this.unassigned.add(new LocatableInputSplitWithCount(split));</span>
        }
<span class="nc" id="L75">        this.remoteSplitChooser = new LocatableInputSplitChooser(unassigned);</span>
<span class="nc" id="L76">    }</span>

    // --------------------------------------------------------------------------------------------

    @Override
    public LocatableInputSplit getNextInputSplit(String host, int taskId) {

        // for a null host, we return a remote split
<span class="fc bfc" id="L84" title="All 2 branches covered.">        if (host == null) {</span>
<span class="fc" id="L85">            synchronized (this.remoteSplitChooser) {</span>
<span class="fc" id="L86">                synchronized (this.unassigned) {</span>
<span class="fc" id="L87">                    LocatableInputSplitWithCount split =</span>
<span class="fc" id="L88">                            this.remoteSplitChooser.getNextUnassignedMinLocalCountSplit(</span>
                                    this.unassigned);

<span class="fc bfc" id="L91" title="All 2 branches covered.">                    if (split != null) {</span>
                        // got a split to assign. Double check that it hasn't been assigned before.
<span class="pc bpc" id="L93" title="1 of 2 branches missed.">                        if (this.unassigned.remove(split)) {</span>
<span class="pc bpc" id="L94" title="1 of 2 branches missed.">                            if (LOG.isInfoEnabled()) {</span>
<span class="nc" id="L95">                                LOG.info(&quot;Assigning split to null host (random assignment).&quot;);</span>
                            }

<span class="fc" id="L98">                            remoteAssignments++;</span>
<span class="fc" id="L99">                            return split.getSplit();</span>
                        } else {
<span class="nc" id="L101">                            throw new IllegalStateException(</span>
                                    &quot;Chosen InputSplit has already been assigned. This should not happen!&quot;);
                        }
                    } else {
                        // all splits consumed
<span class="fc" id="L106">                        return null;</span>
                    }
                }
            }
        }

<span class="fc" id="L112">        host = host.toLowerCase(Locale.US);</span>

        // for any non-null host, we take the list of non-null splits
<span class="fc" id="L115">        LocatableInputSplitChooser localSplits = this.localPerHost.get(host);</span>

        // if we have no list for this host yet, create one
<span class="fc bfc" id="L118" title="All 2 branches covered.">        if (localSplits == null) {</span>
<span class="fc" id="L119">            localSplits = new LocatableInputSplitChooser();</span>

            // lock the list, to be sure that others have to wait for that host's local list
<span class="fc" id="L122">            synchronized (localSplits) {</span>
<span class="fc" id="L123">                LocatableInputSplitChooser prior = this.localPerHost.putIfAbsent(host, localSplits);</span>

                // if someone else beat us in the case to create this list, then we do not populate
                // this one, but
                // simply work with that other list
<span class="pc bpc" id="L128" title="1 of 2 branches missed.">                if (prior == null) {</span>
                    // we are the first, we populate

                    // first, copy the remaining splits to release the lock on the set early
                    // because that is shared among threads
                    LocatableInputSplitWithCount[] remaining;
<span class="fc" id="L134">                    synchronized (this.unassigned) {</span>
<span class="fc" id="L135">                        remaining =</span>
<span class="fc" id="L136">                                this.unassigned.toArray(</span>
<span class="fc" id="L137">                                        new LocatableInputSplitWithCount[this.unassigned.size()]);</span>
<span class="fc" id="L138">                    }</span>

<span class="fc bfc" id="L140" title="All 2 branches covered.">                    for (LocatableInputSplitWithCount isw : remaining) {</span>
<span class="fc bfc" id="L141" title="All 2 branches covered.">                        if (isLocal(host, isw.getSplit().getHostnames())) {</span>
                            // Split is local on host.
                            // Increment local count
<span class="fc" id="L144">                            isw.incrementLocalCount();</span>
                            // and add to local split list
<span class="fc" id="L146">                            localSplits.addInputSplit(isw);</span>
                        }
                    }

<span class="fc" id="L150">                } else {</span>
                    // someone else was faster
<span class="nc" id="L152">                    localSplits = prior;</span>
                }
<span class="fc" id="L154">            }</span>
        }

        // at this point, we have a list of local splits (possibly empty)
        // we need to make sure no one else operates in the current list (that protects against
        // list creation races) and that the unassigned set is consistent
        // NOTE: we need to obtain the locks in this order, strictly!!!
<span class="fc" id="L161">        synchronized (localSplits) {</span>
<span class="fc" id="L162">            synchronized (this.unassigned) {</span>
<span class="fc" id="L163">                LocatableInputSplitWithCount split =</span>
<span class="fc" id="L164">                        localSplits.getNextUnassignedMinLocalCountSplit(this.unassigned);</span>

<span class="fc bfc" id="L166" title="All 2 branches covered.">                if (split != null) {</span>
                    // found a valid split. Double check that it hasn't been assigned before.
<span class="pc bpc" id="L168" title="1 of 2 branches missed.">                    if (this.unassigned.remove(split)) {</span>
<span class="pc bpc" id="L169" title="1 of 2 branches missed.">                        if (LOG.isInfoEnabled()) {</span>
<span class="nc" id="L170">                            LOG.info(&quot;Assigning local split to host &quot; + host);</span>
                        }

<span class="fc" id="L173">                        localAssignments++;</span>
<span class="fc" id="L174">                        return split.getSplit();</span>
                    } else {
<span class="nc" id="L176">                        throw new IllegalStateException(</span>
                                &quot;Chosen InputSplit has already been assigned. This should not happen!&quot;);
                    }
                }
<span class="fc" id="L180">            }</span>
<span class="fc" id="L181">        }</span>

        // we did not find a local split, return a remote split
<span class="fc" id="L184">        synchronized (this.remoteSplitChooser) {</span>
<span class="fc" id="L185">            synchronized (this.unassigned) {</span>
<span class="fc" id="L186">                LocatableInputSplitWithCount split =</span>
<span class="fc" id="L187">                        this.remoteSplitChooser.getNextUnassignedMinLocalCountSplit(</span>
                                this.unassigned);

<span class="fc bfc" id="L190" title="All 2 branches covered.">                if (split != null) {</span>
                    // found a valid split. Double check that it hasn't been assigned yet.
<span class="pc bpc" id="L192" title="1 of 2 branches missed.">                    if (this.unassigned.remove(split)) {</span>
<span class="pc bpc" id="L193" title="1 of 2 branches missed.">                        if (LOG.isInfoEnabled()) {</span>
<span class="nc" id="L194">                            LOG.info(&quot;Assigning remote split to host &quot; + host);</span>
                        }

<span class="fc" id="L197">                        remoteAssignments++;</span>
<span class="fc" id="L198">                        return split.getSplit();</span>
                    } else {
<span class="nc" id="L200">                        throw new IllegalStateException(</span>
                                &quot;Chosen InputSplit has already been assigned. This should not happen!&quot;);
                    }
                } else {
                    // all splits consumed
<span class="fc" id="L205">                    return null;</span>
                }
            }
        }
    }

    @Override
    public void returnInputSplit(List&lt;InputSplit&gt; splits, int taskId) {
<span class="nc" id="L213">        synchronized (this.unassigned) {</span>
<span class="nc bnc" id="L214" title="All 2 branches missed.">            for (InputSplit split : splits) {</span>
<span class="nc" id="L215">                LocatableInputSplitWithCount lisw =</span>
                        new LocatableInputSplitWithCount((LocatableInputSplit) split);
<span class="nc" id="L217">                this.remoteSplitChooser.addInputSplit(lisw);</span>
<span class="nc" id="L218">                this.unassigned.add(lisw);</span>
<span class="nc" id="L219">            }</span>
<span class="nc" id="L220">        }</span>
<span class="nc" id="L221">    }</span>

    private static final boolean isLocal(String flinkHost, String[] hosts) {
<span class="pc bpc" id="L224" title="2 of 4 branches missed.">        if (flinkHost == null || hosts == null) {</span>
<span class="nc" id="L225">            return false;</span>
        }
<span class="fc bfc" id="L227" title="All 2 branches covered.">        for (String h : hosts) {</span>
<span class="pc bpc" id="L228" title="1 of 4 branches missed.">            if (h != null &amp;&amp; NetUtils.getHostnameFromFQDN(h.toLowerCase()).equals(flinkHost)) {</span>
<span class="fc" id="L229">                return true;</span>
            }
        }

<span class="fc" id="L233">        return false;</span>
    }

    public int getNumberOfLocalAssignments() {
<span class="fc" id="L237">        return localAssignments;</span>
    }

    public int getNumberOfRemoteAssignments() {
<span class="fc" id="L241">        return remoteAssignments;</span>
    }

    /**
     * Wraps a LocatableInputSplit and adds a count for the number of observed hosts that can access
     * the split locally.
     */
    private static class LocatableInputSplitWithCount {

        private final LocatableInputSplit split;
        private int localCount;

<span class="fc" id="L253">        public LocatableInputSplitWithCount(LocatableInputSplit split) {</span>
<span class="fc" id="L254">            this.split = split;</span>
<span class="fc" id="L255">            this.localCount = 0;</span>
<span class="fc" id="L256">        }</span>

        public void incrementLocalCount() {
<span class="fc" id="L259">            this.localCount++;</span>
<span class="fc" id="L260">        }</span>

        public int getLocalCount() {
<span class="fc" id="L263">            return this.localCount;</span>
        }

        public LocatableInputSplit getSplit() {
<span class="fc" id="L267">            return this.split;</span>
        }
    }

    /**
     * Holds a list of LocatableInputSplits and returns the split with the lowest local count. The
     * rational is that splits which are local on few hosts should be preferred over others which
     * have more degrees of freedom for local assignment.
     *
     * &lt;p&gt;Internally, the splits are stored in a linked list. Sorting the list is not a good
     * solution, as local counts are updated whenever a previously unseen host requests a split.
     * Instead, we track the minimum local count and iteratively look for splits with that minimum
     * count.
     */
    private static class LocatableInputSplitChooser {

        // list of input splits
        private final LinkedList&lt;LocatableInputSplitWithCount&gt; splits;

        // the current minimum local count. We look for splits with this local count.
<span class="fc" id="L287">        private int minLocalCount = -1;</span>
        // the second smallest count observed so far.
<span class="fc" id="L289">        private int nextMinLocalCount = -1;</span>
        // number of elements we need to inspect for the minimum local count.
<span class="fc" id="L291">        private int elementCycleCount = 0;</span>

<span class="fc" id="L293">        public LocatableInputSplitChooser() {</span>
<span class="fc" id="L294">            this.splits = new LinkedList&lt;LocatableInputSplitWithCount&gt;();</span>
<span class="fc" id="L295">        }</span>

<span class="fc" id="L297">        public LocatableInputSplitChooser(Collection&lt;LocatableInputSplitWithCount&gt; splits) {</span>
<span class="fc" id="L298">            this.splits = new LinkedList&lt;LocatableInputSplitWithCount&gt;();</span>
<span class="fc bfc" id="L299" title="All 2 branches covered.">            for (LocatableInputSplitWithCount isw : splits) {</span>
<span class="fc" id="L300">                this.addInputSplit(isw);</span>
<span class="fc" id="L301">            }</span>
<span class="fc" id="L302">        }</span>

        /**
         * Adds a single input split
         *
         * @param split The input split to add
         */
        public void addInputSplit(LocatableInputSplitWithCount split) {
<span class="fc" id="L310">            int localCount = split.getLocalCount();</span>

<span class="fc bfc" id="L312" title="All 2 branches covered.">            if (minLocalCount == -1) {</span>
                // first split to add
<span class="fc" id="L314">                this.minLocalCount = localCount;</span>
<span class="fc" id="L315">                this.elementCycleCount = 1;</span>
<span class="fc" id="L316">                this.splits.offerFirst(split);</span>
<span class="fc bfc" id="L317" title="All 2 branches covered.">            } else if (localCount &lt; minLocalCount) {</span>
                // split with new min local count
<span class="fc" id="L319">                this.nextMinLocalCount = this.minLocalCount;</span>
<span class="fc" id="L320">                this.minLocalCount = localCount;</span>
                // all other splits have more local host than this one
<span class="fc" id="L322">                this.elementCycleCount = 1;</span>
<span class="fc" id="L323">                splits.offerFirst(split);</span>
<span class="fc bfc" id="L324" title="All 2 branches covered.">            } else if (localCount == minLocalCount) {</span>
<span class="fc" id="L325">                this.elementCycleCount++;</span>
<span class="fc" id="L326">                this.splits.offerFirst(split);</span>
            } else {
<span class="fc bfc" id="L328" title="All 2 branches covered.">                if (localCount &lt; nextMinLocalCount) {</span>
<span class="fc" id="L329">                    nextMinLocalCount = localCount;</span>
                }
<span class="fc" id="L331">                splits.offerLast(split);</span>
            }
<span class="fc" id="L333">        }</span>

        /**
         * Retrieves a LocatableInputSplit with minimum local count. InputSplits which have already
         * been assigned (i.e., which are not contained in the provided set) are filtered out. The
         * returned input split is NOT removed from the provided set.
         *
         * @param unassignedSplits Set of unassigned input splits.
         * @return An input split with minimum local count or null if all splits have been assigned.
         */
        public LocatableInputSplitWithCount getNextUnassignedMinLocalCountSplit(
                Set&lt;LocatableInputSplitWithCount&gt; unassignedSplits) {

<span class="fc bfc" id="L346" title="All 2 branches covered.">            if (splits.size() == 0) {</span>
<span class="fc" id="L347">                return null;</span>
            }

            do {
<span class="fc" id="L351">                elementCycleCount--;</span>
                // take first split of the list
<span class="fc" id="L353">                LocatableInputSplitWithCount split = splits.pollFirst();</span>
<span class="fc bfc" id="L354" title="All 2 branches covered.">                if (unassignedSplits.contains(split)) {</span>
<span class="fc" id="L355">                    int localCount = split.getLocalCount();</span>
                    // still unassigned, check local count
<span class="fc bfc" id="L357" title="All 2 branches covered.">                    if (localCount &gt; minLocalCount) {</span>
                        // re-insert at end of the list and continue to look for split with smaller
                        // local count
<span class="fc" id="L360">                        splits.offerLast(split);</span>
                        // check and update second smallest local count
<span class="fc bfc" id="L362" title="All 4 branches covered.">                        if (nextMinLocalCount == -1 || split.getLocalCount() &lt; nextMinLocalCount) {</span>
<span class="fc" id="L363">                            nextMinLocalCount = split.getLocalCount();</span>
                        }
<span class="fc" id="L365">                        split = null;</span>
                    }
<span class="fc" id="L367">                } else {</span>
                    // split was already assigned
<span class="fc" id="L369">                    split = null;</span>
                }
<span class="fc bfc" id="L371" title="All 2 branches covered.">                if (elementCycleCount == 0) {</span>
                    // one full cycle, but no split with min local count found
                    // update minLocalCnt and element cycle count for next pass over the splits
<span class="fc" id="L374">                    minLocalCount = nextMinLocalCount;</span>
<span class="fc" id="L375">                    nextMinLocalCount = -1;</span>
<span class="fc" id="L376">                    elementCycleCount = splits.size();</span>
                }
<span class="fc bfc" id="L378" title="All 2 branches covered.">                if (split != null) {</span>
                    // found a split to assign
<span class="fc" id="L380">                    return split;</span>
                }
<span class="fc bfc" id="L382" title="All 2 branches covered.">            } while (elementCycleCount &gt; 0);</span>

            // no split left
<span class="fc" id="L385">            return null;</span>
        }
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.7.202105040129</span></div></body></html>