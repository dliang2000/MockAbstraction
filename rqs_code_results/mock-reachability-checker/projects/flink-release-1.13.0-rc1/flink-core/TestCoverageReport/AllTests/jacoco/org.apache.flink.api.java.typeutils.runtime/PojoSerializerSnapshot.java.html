<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>PojoSerializerSnapshot.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Flink : Core</a> &gt; <a href="index.source.html" class="el_package">org.apache.flink.api.java.typeutils.runtime</a> &gt; <span class="el_source">PojoSerializerSnapshot.java</span></div><h1>PojoSerializerSnapshot.java</h1><pre class="source lang-java linenums">/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * &quot;License&quot;); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.apache.flink.api.java.typeutils.runtime;

import org.apache.flink.annotation.Internal;
import org.apache.flink.api.common.ExecutionConfig;
import org.apache.flink.api.common.typeutils.CompositeTypeSerializerUtil;
import org.apache.flink.api.common.typeutils.CompositeTypeSerializerUtil.IntermediateCompatibilityResult;
import org.apache.flink.api.common.typeutils.TypeSerializer;
import org.apache.flink.api.common.typeutils.TypeSerializerSchemaCompatibility;
import org.apache.flink.api.common.typeutils.TypeSerializerSnapshot;
import org.apache.flink.api.java.tuple.Tuple2;
import org.apache.flink.core.memory.DataInputView;
import org.apache.flink.core.memory.DataOutputView;
import org.apache.flink.util.LinkedOptionalMap;

import java.io.IOException;
import java.lang.reflect.Field;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.Iterator;
import java.util.LinkedHashMap;
import java.util.Map;
import java.util.Set;

import static org.apache.flink.util.Preconditions.checkArgument;
import static org.apache.flink.util.Preconditions.checkState;

/** Snapshot class for the {@link PojoSerializer}. */
@Internal
public class PojoSerializerSnapshot&lt;T&gt; implements TypeSerializerSnapshot&lt;T&gt; {

    /**
     * We start from version {@code 2}. {@code 1} is retained for {@link
     * PojoSerializer.PojoSerializerConfigSnapshot}.
     */
    private static final int VERSION = 2;

    /** Contains the actual content for the serializer snapshot. */
    private PojoSerializerSnapshotData&lt;T&gt; snapshotData;

    /** Constructor for reading the snapshot. */
<span class="fc" id="L60">    public PojoSerializerSnapshot() {}</span>

    /**
     * Constructor for writing the snapshot.
     *
     * @param pojoClass the Pojo type class.
     * @param fields array of fields. Fields may be {@code null} if the originating {@link
     *     PojoSerializer} is a restored one with already missing fields, and was never replaced by
     *     a new {@link PojoSerializer}.
     * @param fieldSerializers array of field serializers.
     * @param registeredSubclassSerializers map of registered subclasses to their corresponding
     *     serializers.
     * @param nonRegisteredSubclassSerializers map of non-registered subclasses to their
     *     corresponding serializers.
     */
    PojoSerializerSnapshot(
            Class&lt;T&gt; pojoClass,
            Field[] fields,
            TypeSerializer&lt;?&gt;[] fieldSerializers,
            LinkedHashMap&lt;Class&lt;?&gt;, TypeSerializer&lt;?&gt;&gt; registeredSubclassSerializers,
<span class="fc" id="L80">            Map&lt;Class&lt;?&gt;, TypeSerializer&lt;?&gt;&gt; nonRegisteredSubclassSerializers) {</span>

<span class="fc" id="L82">        this.snapshotData =</span>
<span class="fc" id="L83">                PojoSerializerSnapshotData.createFrom(</span>
                        pojoClass,
                        fields,
                        fieldSerializers,
                        registeredSubclassSerializers,
                        nonRegisteredSubclassSerializers);
<span class="fc" id="L89">    }</span>

    /**
     * Constructor for backwards compatibility paths with the {@link
     * PojoSerializer.PojoSerializerConfigSnapshot}. This is used in {@link
     * PojoSerializer.PojoSerializerConfigSnapshot#resolveSchemaCompatibility(TypeSerializer)} to
     * delegate the compatibility check to this snapshot class.
     */
    PojoSerializerSnapshot(
            Class&lt;T&gt; pojoClass,
            Field[] fields,
            TypeSerializerSnapshot&lt;?&gt;[] existingFieldSerializerSnapshots,
            LinkedHashMap&lt;Class&lt;?&gt;, TypeSerializerSnapshot&lt;?&gt;&gt;
                    existingRegisteredSubclassSerializerSnapshots,
            Map&lt;Class&lt;?&gt;, TypeSerializerSnapshot&lt;?&gt;&gt;
<span class="fc" id="L104">                    existingNonRegisteredSubclassSerializerSnapshots) {</span>

<span class="fc" id="L106">        this.snapshotData =</span>
<span class="fc" id="L107">                PojoSerializerSnapshotData.createFrom(</span>
                        pojoClass,
                        fields,
                        existingFieldSerializerSnapshots,
                        existingRegisteredSubclassSerializerSnapshots,
                        existingNonRegisteredSubclassSerializerSnapshots);
<span class="fc" id="L113">    }</span>

    @Override
    public int getCurrentVersion() {
<span class="fc" id="L117">        return VERSION;</span>
    }

    @Override
    public void writeSnapshot(DataOutputView out) throws IOException {
<span class="fc" id="L122">        snapshotData.writeSnapshotData(out);</span>
<span class="fc" id="L123">    }</span>

    @Override
    public void readSnapshot(int readVersion, DataInputView in, ClassLoader userCodeClassLoader)
            throws IOException {
<span class="pc bpc" id="L128" title="1 of 2 branches missed.">        checkArgument(readVersion == 2, &quot;unrecognized read version %s&quot;, readVersion);</span>
<span class="fc" id="L129">        snapshotData = PojoSerializerSnapshotData.createFrom(in, userCodeClassLoader);</span>
<span class="fc" id="L130">    }</span>

    @Override
    @SuppressWarnings(&quot;unchecked&quot;)
    public TypeSerializer&lt;T&gt; restoreSerializer() {
<span class="fc" id="L135">        final int numFields = snapshotData.getFieldSerializerSnapshots().size();</span>

<span class="fc" id="L137">        final ArrayList&lt;Field&gt; restoredFields = new ArrayList&lt;&gt;(numFields);</span>
<span class="fc" id="L138">        final ArrayList&lt;TypeSerializer&lt;?&gt;&gt; restoredFieldSerializers = new ArrayList&lt;&gt;(numFields);</span>
<span class="fc" id="L139">        snapshotData</span>
<span class="fc" id="L140">                .getFieldSerializerSnapshots()</span>
<span class="fc" id="L141">                .forEach(</span>
                        (fieldName, field, fieldSerializerSnapshot) -&gt; {
<span class="fc" id="L143">                            restoredFields.add(field);</span>
<span class="pc bpc" id="L144" title="1 of 2 branches missed.">                            checkState(</span>
                                    fieldSerializerSnapshot != null,
                                    &quot;field serializer snapshots should be present.&quot;);
<span class="fc" id="L147">                            restoredFieldSerializers.add(</span>
<span class="fc" id="L148">                                    fieldSerializerSnapshot.restoreSerializer());</span>
<span class="fc" id="L149">                        });</span>

<span class="fc" id="L151">        final LinkedHashMap&lt;Class&lt;?&gt;, TypeSerializer&lt;?&gt;&gt; registeredSubclassSerializers =</span>
<span class="fc" id="L152">                restoreSerializers(</span>
<span class="fc" id="L153">                        snapshotData.getRegisteredSubclassSerializerSnapshots().unwrapOptionals());</span>
        final Tuple2&lt;LinkedHashMap&lt;Class&lt;?&gt;, Integer&gt;, TypeSerializer&lt;Object&gt;[]&gt;
<span class="fc" id="L155">                decomposedSubclassSerializerRegistry =</span>
<span class="fc" id="L156">                        decomposeSubclassSerializerRegistry(registeredSubclassSerializers);</span>

<span class="fc" id="L158">        final LinkedHashMap&lt;Class&lt;?&gt;, TypeSerializer&lt;?&gt;&gt; nonRegisteredSubclassSerializers =</span>
<span class="fc" id="L159">                restoreSerializers(</span>
                        snapshotData
<span class="fc" id="L161">                                .getNonRegisteredSubclassSerializerSnapshots()</span>
<span class="fc" id="L162">                                .unwrapOptionals());</span>

<span class="fc" id="L164">        return new PojoSerializer&lt;&gt;(</span>
<span class="fc" id="L165">                snapshotData.getPojoClass(),</span>
<span class="fc" id="L166">                restoredFields.toArray(new Field[numFields]),</span>
<span class="fc" id="L167">                restoredFieldSerializers.toArray(new TypeSerializer[numFields]),</span>
                decomposedSubclassSerializerRegistry.f0,
                decomposedSubclassSerializerRegistry.f1,
                nonRegisteredSubclassSerializers,
                new ExecutionConfig());
    }

    @Override
    public TypeSerializerSchemaCompatibility&lt;T&gt; resolveSchemaCompatibility(
            TypeSerializer&lt;T&gt; newSerializer) {
<span class="pc bpc" id="L177" title="1 of 2 branches missed.">        if (newSerializer.getClass() != PojoSerializer.class) {</span>
<span class="nc" id="L178">            return TypeSerializerSchemaCompatibility.incompatible();</span>
        }

<span class="fc" id="L181">        final PojoSerializer&lt;T&gt; newPojoSerializer = (PojoSerializer&lt;T&gt;) newSerializer;</span>

<span class="fc" id="L183">        final Class&lt;T&gt; previousPojoClass = snapshotData.getPojoClass();</span>
<span class="fc" id="L184">        final LinkedOptionalMap&lt;Field, TypeSerializerSnapshot&lt;?&gt;&gt; fieldSerializerSnapshots =</span>
<span class="fc" id="L185">                snapshotData.getFieldSerializerSnapshots();</span>
        final LinkedOptionalMap&lt;Class&lt;?&gt;, TypeSerializerSnapshot&lt;?&gt;&gt;
<span class="fc" id="L187">                registeredSubclassSerializerSnapshots =</span>
<span class="fc" id="L188">                        snapshotData.getRegisteredSubclassSerializerSnapshots();</span>
        final LinkedOptionalMap&lt;Class&lt;?&gt;, TypeSerializerSnapshot&lt;?&gt;&gt;
<span class="fc" id="L190">                nonRegisteredSubclassSerializerSnapshots =</span>
<span class="fc" id="L191">                        snapshotData.getNonRegisteredSubclassSerializerSnapshots();</span>

<span class="fc bfc" id="L193" title="All 2 branches covered.">        if (previousPojoClass != newPojoSerializer.getPojoClass()) {</span>
<span class="fc" id="L194">            return TypeSerializerSchemaCompatibility.incompatible();</span>
        }

<span class="pc bpc" id="L197" title="1 of 2 branches missed.">        if (registeredSubclassSerializerSnapshots.hasAbsentKeysOrValues()) {</span>
<span class="nc" id="L198">            return TypeSerializerSchemaCompatibility.incompatible();</span>
        }

<span class="pc bpc" id="L201" title="1 of 2 branches missed.">        if (nonRegisteredSubclassSerializerSnapshots.hasAbsentKeysOrValues()) {</span>
<span class="nc" id="L202">            return TypeSerializerSchemaCompatibility.incompatible();</span>
        }

<span class="fc" id="L205">        final IntermediateCompatibilityResult&lt;T&gt; preExistingFieldSerializersCompatibility =</span>
<span class="fc" id="L206">                getCompatibilityOfPreExistingFields(newPojoSerializer, fieldSerializerSnapshots);</span>

<span class="fc bfc" id="L208" title="All 2 branches covered.">        if (preExistingFieldSerializersCompatibility.isIncompatible()) {</span>
<span class="fc" id="L209">            return TypeSerializerSchemaCompatibility.incompatible();</span>
        }

<span class="fc" id="L212">        final IntermediateCompatibilityResult&lt;T&gt; preExistingRegistrationsCompatibility =</span>
<span class="fc" id="L213">                getCompatibilityOfPreExistingRegisteredSubclasses(</span>
                        newPojoSerializer, registeredSubclassSerializerSnapshots);

<span class="fc bfc" id="L216" title="All 2 branches covered.">        if (preExistingRegistrationsCompatibility.isIncompatible()) {</span>
<span class="fc" id="L217">            return TypeSerializerSchemaCompatibility.incompatible();</span>
        }

<span class="fc bfc" id="L220" title="All 2 branches covered.">        if (newPojoSerializerIsCompatibleAfterMigration(</span>
                newPojoSerializer,
                preExistingFieldSerializersCompatibility,
                preExistingRegistrationsCompatibility,
                fieldSerializerSnapshots)) {

<span class="fc" id="L226">            return TypeSerializerSchemaCompatibility.compatibleAfterMigration();</span>
        }

<span class="fc bfc" id="L229" title="All 2 branches covered.">        if (newPojoSerializerIsCompatibleWithReconfiguredSerializer(</span>
                newPojoSerializer,
                preExistingFieldSerializersCompatibility,
                preExistingRegistrationsCompatibility,
                registeredSubclassSerializerSnapshots,
                nonRegisteredSubclassSerializerSnapshots)) {

<span class="fc" id="L236">            return TypeSerializerSchemaCompatibility.compatibleWithReconfiguredSerializer(</span>
<span class="fc" id="L237">                    constructReconfiguredPojoSerializer(</span>
                            newPojoSerializer,
                            preExistingFieldSerializersCompatibility,
                            registeredSubclassSerializerSnapshots,
                            preExistingRegistrationsCompatibility,
                            nonRegisteredSubclassSerializerSnapshots));
        }

<span class="fc" id="L245">        return TypeSerializerSchemaCompatibility.compatibleAsIs();</span>
    }

    // ---------------------------------------------------------------------------------------------
    //  Utility methods
    // ---------------------------------------------------------------------------------------------

    /**
     * Transforms a {@link LinkedHashMap} with {@link TypeSerializerSnapshot}s as the value to
     * {@link TypeSerializer} as the value by restoring the snapshot.
     */
    private static &lt;K&gt; LinkedHashMap&lt;K, TypeSerializer&lt;?&gt;&gt; restoreSerializers(
            LinkedHashMap&lt;K, TypeSerializerSnapshot&lt;?&gt;&gt; snapshotsMap) {
<span class="fc" id="L258">        final LinkedHashMap&lt;K, TypeSerializer&lt;?&gt;&gt; restoredSerializersMap =</span>
<span class="fc" id="L259">                new LinkedHashMap&lt;&gt;(snapshotsMap.size());</span>
<span class="fc" id="L260">        snapshotsMap.forEach(</span>
<span class="fc" id="L261">                (key, snapshot) -&gt; restoredSerializersMap.put(key, snapshot.restoreSerializer()));</span>
<span class="fc" id="L262">        return restoredSerializersMap;</span>
    }

    /**
     * Transforms the subclass serializer registry structure, {@code LinkedHashMap&lt;Class&lt;?&gt;,
     * TypeSerializer&lt;?&gt;&gt;} to 2 separate structures: a map containing with registered classes as key
     * and their corresponding ids (order in the original map) as value, as well as a separate array
     * of the corresponding subclass serializers.
     */
    @SuppressWarnings(&quot;unchecked&quot;)
    private static Tuple2&lt;LinkedHashMap&lt;Class&lt;?&gt;, Integer&gt;, TypeSerializer&lt;Object&gt;[]&gt;
            decomposeSubclassSerializerRegistry(
                    LinkedHashMap&lt;Class&lt;?&gt;, TypeSerializer&lt;?&gt;&gt; subclassSerializerRegistry) {

<span class="fc" id="L276">        final LinkedHashMap&lt;Class&lt;?&gt;, Integer&gt; subclassIds =</span>
<span class="fc" id="L277">                new LinkedHashMap&lt;&gt;(subclassSerializerRegistry.size());</span>
<span class="fc" id="L278">        final TypeSerializer[] subclassSerializers =</span>
<span class="fc" id="L279">                new TypeSerializer[subclassSerializerRegistry.size()];</span>

<span class="fc" id="L281">        subclassSerializerRegistry.forEach(</span>
                (registeredSubclassClass, serializer) -&gt; {
<span class="fc" id="L283">                    int id = subclassIds.size();</span>
<span class="fc" id="L284">                    subclassIds.put(registeredSubclassClass, id);</span>
<span class="fc" id="L285">                    subclassSerializers[id] = serializer;</span>
<span class="fc" id="L286">                });</span>

<span class="fc" id="L288">        return Tuple2.of(subclassIds, subclassSerializers);</span>
    }

    /**
     * Finds which Pojo fields exists both in the new {@link PojoSerializer} as well as in the
     * previous one (represented by this snapshot), and returns an {@link
     * IntermediateCompatibilityResult} of the serializers of those preexisting fields.
     */
    private static &lt;T&gt; IntermediateCompatibilityResult&lt;T&gt; getCompatibilityOfPreExistingFields(
            PojoSerializer&lt;T&gt; newPojoSerializer,
            LinkedOptionalMap&lt;Field, TypeSerializerSnapshot&lt;?&gt;&gt; fieldSerializerSnapshots) {

        // the present entries dictates the preexisting fields, because removed fields would be
        // represented as absent keys in the optional map.
        final Set&lt;LinkedOptionalMap.KeyValue&lt;Field, TypeSerializerSnapshot&lt;?&gt;&gt;&gt;
<span class="fc" id="L303">                presentFieldSnapshots = fieldSerializerSnapshots.getPresentEntries();</span>

<span class="fc" id="L305">        final ArrayList&lt;TypeSerializerSnapshot&lt;?&gt;&gt; associatedFieldSerializerSnapshots =</span>
<span class="fc" id="L306">                new ArrayList&lt;&gt;(presentFieldSnapshots.size());</span>
<span class="fc" id="L307">        final ArrayList&lt;TypeSerializer&lt;?&gt;&gt; associatedNewFieldSerializers =</span>
<span class="fc" id="L308">                new ArrayList&lt;&gt;(presentFieldSnapshots.size());</span>

<span class="fc" id="L310">        final Map&lt;Field, TypeSerializer&lt;?&gt;&gt; newFieldSerializersIndex =</span>
<span class="fc" id="L311">                buildNewFieldSerializersIndex(newPojoSerializer);</span>
        for (LinkedOptionalMap.KeyValue&lt;Field, TypeSerializerSnapshot&lt;?&gt;&gt; presentFieldEntry :
<span class="fc bfc" id="L313" title="All 2 branches covered.">                presentFieldSnapshots) {</span>
<span class="fc" id="L314">            TypeSerializer&lt;?&gt; associatedNewFieldSerializer =</span>
<span class="fc" id="L315">                    newFieldSerializersIndex.get(presentFieldEntry.getKey());</span>
<span class="pc bpc" id="L316" title="1 of 2 branches missed.">            checkState(</span>
                    associatedNewFieldSerializer != null,
                    &quot;a present field should have its associated new field serializer available.&quot;);

<span class="fc" id="L320">            associatedFieldSerializerSnapshots.add(presentFieldEntry.getValue());</span>
<span class="fc" id="L321">            associatedNewFieldSerializers.add(associatedNewFieldSerializer);</span>
<span class="fc" id="L322">        }</span>

<span class="fc" id="L324">        return CompositeTypeSerializerUtil.constructIntermediateCompatibilityResult(</span>
<span class="fc" id="L325">                associatedNewFieldSerializers.toArray(</span>
<span class="fc" id="L326">                        new TypeSerializer&lt;?&gt;[associatedNewFieldSerializers.size()]),</span>
<span class="fc" id="L327">                associatedFieldSerializerSnapshots.toArray(</span>
<span class="fc" id="L328">                        new TypeSerializerSnapshot&lt;?&gt;[associatedFieldSerializerSnapshots.size()]));</span>
    }

    /**
     * Builds an index of fields to their corresponding serializers for the new {@link
     * PojoSerializer} for faster field serializer lookups.
     */
    private static &lt;T&gt; Map&lt;Field, TypeSerializer&lt;?&gt;&gt; buildNewFieldSerializersIndex(
            PojoSerializer&lt;T&gt; newPojoSerializer) {
<span class="fc" id="L337">        final Field[] newFields = newPojoSerializer.getFields();</span>
<span class="fc" id="L338">        final TypeSerializer&lt;?&gt;[] newFieldSerializers = newPojoSerializer.getFieldSerializers();</span>

<span class="pc bpc" id="L340" title="1 of 2 branches missed.">        checkState(newFields.length == newFieldSerializers.length);</span>

<span class="fc" id="L342">        int numFields = newFields.length;</span>
<span class="fc" id="L343">        final Map&lt;Field, TypeSerializer&lt;?&gt;&gt; index = new HashMap&lt;&gt;(numFields);</span>
<span class="fc bfc" id="L344" title="All 2 branches covered.">        for (int i = 0; i &lt; numFields; i++) {</span>
<span class="fc" id="L345">            index.put(newFields[i], newFieldSerializers[i]);</span>
        }

<span class="fc" id="L348">        return index;</span>
    }

    /**
     * Finds which registered subclasses exists both in the new {@link PojoSerializer} as well as in
     * the previous one (represented by this snapshot), and returns an {@link
     * IntermediateCompatibilityResult} of the serializers of this preexisting registered
     * subclasses.
     */
    private static &lt;T&gt;
            IntermediateCompatibilityResult&lt;T&gt; getCompatibilityOfPreExistingRegisteredSubclasses(
                    PojoSerializer&lt;T&gt; newPojoSerializer,
                    LinkedOptionalMap&lt;Class&lt;?&gt;, TypeSerializerSnapshot&lt;?&gt;&gt;
                            registeredSubclassSerializerSnapshots) {

<span class="fc" id="L363">        final LinkedHashMap&lt;Class&lt;?&gt;, TypeSerializerSnapshot&lt;?&gt;&gt; unwrappedSerializerSnapshots =</span>
<span class="fc" id="L364">                registeredSubclassSerializerSnapshots.unwrapOptionals();</span>

<span class="fc" id="L366">        final ArrayList&lt;TypeSerializerSnapshot&lt;?&gt;&gt; associatedSubclassSerializerSnapshots =</span>
                new ArrayList&lt;&gt;();
<span class="fc" id="L368">        final ArrayList&lt;TypeSerializer&lt;?&gt;&gt; associatedNewSubclassSerializers = new ArrayList&lt;&gt;();</span>

<span class="fc" id="L370">        final LinkedHashMap&lt;Class&lt;?&gt;, TypeSerializer&lt;?&gt;&gt; newSubclassSerializerRegistry =</span>
<span class="fc" id="L371">                newPojoSerializer.getBundledSubclassSerializerRegistry();</span>

        for (Map.Entry&lt;Class&lt;?&gt;, TypeSerializerSnapshot&lt;?&gt;&gt; entry :
<span class="fc bfc" id="L374" title="All 2 branches covered.">                unwrappedSerializerSnapshots.entrySet()) {</span>
<span class="fc" id="L375">            TypeSerializer&lt;?&gt; newRegisteredSerializer =</span>
<span class="fc" id="L376">                    newSubclassSerializerRegistry.get(entry.getKey());</span>
<span class="fc bfc" id="L377" title="All 2 branches covered.">            if (newRegisteredSerializer != null) {</span>
<span class="fc" id="L378">                associatedSubclassSerializerSnapshots.add(entry.getValue());</span>
<span class="fc" id="L379">                associatedNewSubclassSerializers.add(newRegisteredSerializer);</span>
            }
<span class="fc" id="L381">        }</span>

<span class="fc" id="L383">        return CompositeTypeSerializerUtil.constructIntermediateCompatibilityResult(</span>
<span class="fc" id="L384">                associatedNewSubclassSerializers.toArray(</span>
<span class="fc" id="L385">                        new TypeSerializer&lt;?&gt;[associatedNewSubclassSerializers.size()]),</span>
<span class="fc" id="L386">                associatedSubclassSerializerSnapshots.toArray(</span>
                        new TypeSerializerSnapshot&lt;?&gt;
<span class="fc" id="L388">                                [associatedSubclassSerializerSnapshots.size()]));</span>
    }

    /** Checks if the new {@link PojoSerializer} is compatible after migration. */
    private static &lt;T&gt; boolean newPojoSerializerIsCompatibleAfterMigration(
            PojoSerializer&lt;T&gt; newPojoSerializer,
            IntermediateCompatibilityResult&lt;T&gt; fieldSerializerCompatibility,
            IntermediateCompatibilityResult&lt;T&gt; preExistingRegistrationsCompatibility,
            LinkedOptionalMap&lt;Field, TypeSerializerSnapshot&lt;?&gt;&gt; fieldSerializerSnapshots) {
<span class="fc bfc" id="L397" title="All 2 branches covered.">        return newPojoHasNewOrRemovedFields(fieldSerializerSnapshots, newPojoSerializer)</span>
<span class="fc bfc" id="L398" title="All 2 branches covered.">                || fieldSerializerCompatibility.isCompatibleAfterMigration()</span>
<span class="fc bfc" id="L399" title="All 2 branches covered.">                || preExistingRegistrationsCompatibility.isCompatibleAfterMigration();</span>
    }

    /** Checks if the new {@link PojoSerializer} is compatible with a reconfigured instance. */
    private static &lt;T&gt; boolean newPojoSerializerIsCompatibleWithReconfiguredSerializer(
            PojoSerializer&lt;T&gt; newPojoSerializer,
            IntermediateCompatibilityResult&lt;T&gt; fieldSerializerCompatibility,
            IntermediateCompatibilityResult&lt;T&gt; preExistingRegistrationsCompatibility,
            LinkedOptionalMap&lt;Class&lt;?&gt;, TypeSerializerSnapshot&lt;?&gt;&gt;
                    registeredSubclassSerializerSnapshots,
            LinkedOptionalMap&lt;Class&lt;?&gt;, TypeSerializerSnapshot&lt;?&gt;&gt;
                    nonRegisteredSubclassSerializerSnapshots) {
<span class="fc bfc" id="L411" title="All 2 branches covered.">        return newPojoHasDifferentSubclassRegistrationOrder(</span>
                        registeredSubclassSerializerSnapshots, newPojoSerializer)
<span class="fc bfc" id="L413" title="All 2 branches covered.">                || previousSerializerHasNonRegisteredSubclasses(</span>
                        nonRegisteredSubclassSerializerSnapshots)
<span class="fc bfc" id="L415" title="All 2 branches covered.">                || fieldSerializerCompatibility.isCompatibleWithReconfiguredSerializer()</span>
<span class="pc bpc" id="L416" title="1 of 2 branches missed.">                || preExistingRegistrationsCompatibility.isCompatibleWithReconfiguredSerializer();</span>
    }

    /**
     * Checks whether the new {@link PojoSerializer} has new or removed fields compared to the
     * previous one.
     */
    private static boolean newPojoHasNewOrRemovedFields(
            LinkedOptionalMap&lt;Field, TypeSerializerSnapshot&lt;?&gt;&gt; fieldSerializerSnapshots,
            PojoSerializer&lt;?&gt; newPojoSerializer) {
<span class="fc" id="L426">        int numRemovedFields = fieldSerializerSnapshots.absentKeysOrValues().size();</span>
<span class="fc" id="L427">        int numPreexistingFields = fieldSerializerSnapshots.size() - numRemovedFields;</span>

<span class="fc bfc" id="L429" title="All 2 branches covered.">        boolean hasRemovedFields = numRemovedFields &gt; 0;</span>
<span class="fc bfc" id="L430" title="All 2 branches covered.">        boolean hasNewFields = newPojoSerializer.getFields().length - numPreexistingFields &gt; 0;</span>
<span class="fc bfc" id="L431" title="All 4 branches covered.">        return hasRemovedFields || hasNewFields;</span>
    }

    /**
     * Checks whether the new {@link PojoSerializer} has a different subclass registration order
     * compared to the previous one.
     */
    private static boolean newPojoHasDifferentSubclassRegistrationOrder(
            LinkedOptionalMap&lt;Class&lt;?&gt;, TypeSerializerSnapshot&lt;?&gt;&gt;
                    registeredSubclassSerializerSnapshots,
            PojoSerializer&lt;?&gt; newPojoSerializer) {
<span class="fc" id="L442">        Set&lt;Class&lt;?&gt;&gt; previousRegistrationOrder =</span>
<span class="fc" id="L443">                registeredSubclassSerializerSnapshots.unwrapOptionals().keySet();</span>
<span class="fc" id="L444">        Set&lt;Class&lt;?&gt;&gt; newRegistrationOrder = newPojoSerializer.getRegisteredClasses().keySet();</span>
<span class="fc bfc" id="L445" title="All 2 branches covered.">        return !isPreviousRegistrationPrefixOfNewRegistration(</span>
                previousRegistrationOrder, newRegistrationOrder);
    }

    private static boolean isPreviousRegistrationPrefixOfNewRegistration(
            Set&lt;Class&lt;?&gt;&gt; previousRegistrationOrder, Set&lt;Class&lt;?&gt;&gt; newRegistrationOrder) {
<span class="fc" id="L451">        Iterator&lt;Class&lt;?&gt;&gt; newRegistrationItr = newRegistrationOrder.iterator();</span>

<span class="fc bfc" id="L453" title="All 2 branches covered.">        for (Class&lt;?&gt; previousRegisteredClass : previousRegistrationOrder) {</span>
<span class="pc bpc" id="L454" title="1 of 2 branches missed.">            if (!newRegistrationItr.hasNext()) {</span>
<span class="nc" id="L455">                return false;</span>
            }
<span class="fc" id="L457">            Class&lt;?&gt; newRegisteredClass = newRegistrationItr.next();</span>
<span class="fc bfc" id="L458" title="All 2 branches covered.">            if (!previousRegisteredClass.equals(newRegisteredClass)) {</span>
<span class="fc" id="L459">                return false;</span>
            }
<span class="fc" id="L461">        }</span>
<span class="fc" id="L462">        return true;</span>
    }

    /**
     * Checks whether the previous serializer, represented by this snapshot, has non-registered
     * subclasses.
     */
    private static boolean previousSerializerHasNonRegisteredSubclasses(
            LinkedOptionalMap&lt;Class&lt;?&gt;, TypeSerializerSnapshot&lt;?&gt;&gt;
                    nonRegisteredSubclassSerializerSnapshots) {
<span class="fc bfc" id="L472" title="All 2 branches covered.">        return nonRegisteredSubclassSerializerSnapshots.size() &gt; 0;</span>
    }

    /**
     * Creates a reconfigured version of the {@link PojoSerializer}.
     *
     * @param originalNewPojoSerializer the original new {@link PojoSerializer} to create a
     *     reconfigured version of.
     * @param fieldSerializerCompatibility compatibility of preexisting fields' serializers.
     * @param registeredSerializerSnapshots snapshot of previous registered subclasses' serializers.
     * @param preExistingRegistrationsCompatibility compatibility of preexisting subclasses'
     *     serializers.
     * @param nonRegisteredSubclassSerializerSnapshots snapshot of previous non-registered
     *     subclasses' serializers.
     * @return a reconfigured version of the original new {@link PojoSerializer}.
     */
    private static &lt;T&gt; PojoSerializer&lt;T&gt; constructReconfiguredPojoSerializer(
            PojoSerializer&lt;T&gt; originalNewPojoSerializer,
            IntermediateCompatibilityResult&lt;T&gt; fieldSerializerCompatibility,
            LinkedOptionalMap&lt;Class&lt;?&gt;, TypeSerializerSnapshot&lt;?&gt;&gt; registeredSerializerSnapshots,
            IntermediateCompatibilityResult&lt;T&gt; preExistingRegistrationsCompatibility,
            LinkedOptionalMap&lt;Class&lt;?&gt;, TypeSerializerSnapshot&lt;?&gt;&gt;
                    nonRegisteredSubclassSerializerSnapshots) {

        @SuppressWarnings(&quot;unchecked&quot;)
<span class="fc" id="L497">        final TypeSerializer&lt;Object&gt;[] reconfiguredFieldSerializers =</span>
<span class="fc" id="L498">                constructReconfiguredFieldSerializers(fieldSerializerCompatibility);</span>

        Tuple2&lt;LinkedHashMap&lt;Class&lt;?&gt;, Integer&gt;, TypeSerializer&lt;Object&gt;[]&gt;
<span class="fc" id="L501">                reconfiguredSubclassRegistry =</span>
<span class="fc" id="L502">                        constructReconfiguredSubclassRegistry(</span>
<span class="fc" id="L503">                                originalNewPojoSerializer.getBundledSubclassSerializerRegistry(),</span>
                                registeredSerializerSnapshots,
                                preExistingRegistrationsCompatibility);

<span class="fc" id="L507">        return new PojoSerializer&lt;&gt;(</span>
<span class="fc" id="L508">                originalNewPojoSerializer.getPojoClass(),</span>
<span class="fc" id="L509">                originalNewPojoSerializer.getFields(),</span>
                reconfiguredFieldSerializers,
                reconfiguredSubclassRegistry.f0,
                reconfiguredSubclassRegistry.f1,
<span class="fc" id="L513">                restoreSerializers(nonRegisteredSubclassSerializerSnapshots.unwrapOptionals()),</span>
<span class="fc" id="L514">                originalNewPojoSerializer.getExecutionConfig());</span>
    }

    private static TypeSerializer[] constructReconfiguredFieldSerializers(
            IntermediateCompatibilityResult&lt;?&gt; fieldSerializerCompatibility) {
<span class="fc" id="L519">        checkArgument(</span>
<span class="pc bpc" id="L520" title="1 of 2 branches missed.">                !fieldSerializerCompatibility.isIncompatible()</span>
<span class="pc bpc" id="L521" title="1 of 2 branches missed.">                        &amp;&amp; !fieldSerializerCompatibility.isCompatibleAfterMigration());</span>
<span class="fc" id="L522">        return fieldSerializerCompatibility.getNestedSerializers();</span>
    }

    private static Tuple2&lt;LinkedHashMap&lt;Class&lt;?&gt;, Integer&gt;, TypeSerializer&lt;Object&gt;[]&gt;
            constructReconfiguredSubclassRegistry(
                    LinkedHashMap&lt;Class&lt;?&gt;, TypeSerializer&lt;?&gt;&gt; newSubclassRegistrations,
                    LinkedOptionalMap&lt;Class&lt;?&gt;, TypeSerializerSnapshot&lt;?&gt;&gt;
                            registeredSerializerSnapshots,
                    IntermediateCompatibilityResult&lt;?&gt; preExistingRegistrationsCompatibility) {

<span class="fc" id="L532">        checkArgument(</span>
<span class="pc bpc" id="L533" title="1 of 2 branches missed.">                !preExistingRegistrationsCompatibility.isIncompatible()</span>
<span class="pc bpc" id="L534" title="1 of 2 branches missed.">                        &amp;&amp; !preExistingRegistrationsCompatibility.isCompatibleAfterMigration());</span>

<span class="fc" id="L536">        LinkedHashMap&lt;Class&lt;?&gt;, TypeSerializer&lt;?&gt;&gt; reconfiguredSubclassSerializerRegistry =</span>
<span class="fc" id="L537">                restoreSerializers(registeredSerializerSnapshots.unwrapOptionals());</span>

<span class="fc" id="L539">        Iterator&lt;TypeSerializer&lt;?&gt;&gt; serializersForPreexistingRegistrations =</span>
<span class="fc" id="L540">                Arrays.asList(preExistingRegistrationsCompatibility.getNestedSerializers())</span>
<span class="fc" id="L541">                        .iterator();</span>

        // first, replace all restored serializers of subclasses that co-exist in
        // the previous and new registrations, with the compatibility-checked serializers
        for (Map.Entry&lt;Class&lt;?&gt;, TypeSerializer&lt;?&gt;&gt; oldRegistration :
<span class="fc bfc" id="L546" title="All 2 branches covered.">                reconfiguredSubclassSerializerRegistry.entrySet()) {</span>
<span class="fc bfc" id="L547" title="All 2 branches covered.">            if (newSubclassRegistrations.containsKey(oldRegistration.getKey())) {</span>
<span class="fc" id="L548">                oldRegistration.setValue(serializersForPreexistingRegistrations.next());</span>
            }
<span class="fc" id="L550">        }</span>

        // then, for all new registration that did not exist before, append it to the registry
        // simply with their
        // new serializers
        for (Map.Entry&lt;Class&lt;?&gt;, TypeSerializer&lt;?&gt;&gt; newRegistration :
<span class="fc bfc" id="L556" title="All 2 branches covered.">                newSubclassRegistrations.entrySet()) {</span>
<span class="fc" id="L557">            TypeSerializer&lt;?&gt; oldRegistration =</span>
<span class="fc" id="L558">                    reconfiguredSubclassSerializerRegistry.get(newRegistration.getKey());</span>
<span class="fc bfc" id="L559" title="All 2 branches covered.">            if (oldRegistration == null) {</span>
<span class="fc" id="L560">                reconfiguredSubclassSerializerRegistry.put(</span>
<span class="fc" id="L561">                        newRegistration.getKey(), newRegistration.getValue());</span>
            }
<span class="fc" id="L563">        }</span>

<span class="fc" id="L565">        return decomposeSubclassSerializerRegistry(reconfiguredSubclassSerializerRegistry);</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.7.202105040129</span></div></body></html>