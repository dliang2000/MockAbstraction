<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>Path.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Flink : Core</a> &gt; <a href="index.source.html" class="el_package">org.apache.flink.core.fs</a> &gt; <span class="el_source">Path.java</span></div><h1>Path.java</h1><pre class="source lang-java linenums">/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * &quot;License&quot;); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/* This file is based on source code from the Hadoop Project (http://hadoop.apache.org/), licensed by the Apache
 * Software Foundation (ASF) under the Apache License, Version 2.0. See the NOTICE file distributed with this work for
 * additional information regarding copyright ownership. */

package org.apache.flink.core.fs;

import org.apache.flink.annotation.Public;
import org.apache.flink.core.io.IOReadableWritable;
import org.apache.flink.core.memory.DataInputView;
import org.apache.flink.core.memory.DataOutputView;
import org.apache.flink.util.StringUtils;

import java.io.File;
import java.io.IOException;
import java.io.Serializable;
import java.net.URI;
import java.net.URISyntaxException;
import java.util.regex.Pattern;

/**
 * Names a file or directory in a {@link FileSystem}. Path strings use slash as the directory
 * separator. A path string is absolute if it begins with a slash.
 *
 * &lt;p&gt;Tailing slashes are removed from the path.
 */
@Public
public class Path implements IOReadableWritable, Serializable {

    private static final long serialVersionUID = 1L;

    /** The directory separator, a slash. */
    public static final String SEPARATOR = &quot;/&quot;;

    /** The directory separator, a slash (character). */
    public static final char SEPARATOR_CHAR = '/';

    /** Character denoting the current directory. */
    public static final String CUR_DIR = &quot;.&quot;;

    /** A pre-compiled regex/state-machine to match the windows drive pattern. */
<span class="fc" id="L59">    private static final Pattern WINDOWS_ROOT_DIR_REGEX = Pattern.compile(&quot;/\\p{Alpha}+:/&quot;);</span>

    /** The internal representation of the path, a hierarchical URI. */
    private URI uri;

    /** Constructs a new (empty) path object (used to reconstruct path object after RPC call). */
<span class="nc" id="L65">    public Path() {}</span>

    /**
     * Constructs a path object from a given URI.
     *
     * @param uri the URI to construct the path object from
     */
<span class="fc" id="L72">    public Path(URI uri) {</span>
<span class="fc" id="L73">        this.uri = uri;</span>
<span class="fc" id="L74">    }</span>

    /**
     * Resolve a child path against a parent path.
     *
     * @param parent the parent path
     * @param child the child path
     */
    public Path(String parent, String child) {
<span class="fc" id="L83">        this(new Path(parent), new Path(child));</span>
<span class="fc" id="L84">    }</span>

    /**
     * Resolve a child path against a parent path.
     *
     * @param parent the parent path
     * @param child the child path
     */
    public Path(Path parent, String child) {
<span class="fc" id="L93">        this(parent, new Path(child));</span>
<span class="fc" id="L94">    }</span>

    /**
     * Resolve a child path against a parent path.
     *
     * @param parent the parent path
     * @param child the child path
     */
    public Path(String parent, Path child) {
<span class="nc" id="L103">        this(new Path(parent), child);</span>
<span class="nc" id="L104">    }</span>

    /**
     * Resolve a child path against a parent path.
     *
     * @param parent the parent path
     * @param child the child path
     */
<span class="fc" id="L112">    public Path(Path parent, Path child) {</span>
        // Add a slash to parent's path so resolution is compatible with URI's
<span class="fc" id="L114">        URI parentUri = parent.uri;</span>
<span class="fc" id="L115">        final String parentPath = parentUri.getPath();</span>
<span class="pc bpc" id="L116" title="2 of 4 branches missed.">        if (!(parentPath.equals(&quot;/&quot;) || parentPath.equals(&quot;&quot;))) {</span>
            try {
<span class="fc" id="L118">                parentUri =</span>
                        new URI(
<span class="fc" id="L120">                                parentUri.getScheme(),</span>
<span class="fc" id="L121">                                parentUri.getAuthority(),</span>
<span class="fc" id="L122">                                parentUri.getPath() + &quot;/&quot;,</span>
                                null,
                                null);
<span class="nc" id="L125">            } catch (URISyntaxException e) {</span>
<span class="nc" id="L126">                throw new IllegalArgumentException(e);</span>
<span class="fc" id="L127">            }</span>
        }

<span class="pc bpc" id="L130" title="1 of 2 branches missed.">        if (child.uri.getPath().startsWith(Path.SEPARATOR)) {</span>
<span class="nc" id="L131">            child =</span>
                    new Path(
<span class="nc" id="L133">                            child.uri.getScheme(),</span>
<span class="nc" id="L134">                            child.uri.getAuthority(),</span>
<span class="nc" id="L135">                            child.uri.getPath().substring(1));</span>
        }

<span class="fc" id="L138">        final URI resolved = parentUri.resolve(child.uri);</span>
<span class="fc" id="L139">        initialize(resolved.getScheme(), resolved.getAuthority(), resolved.getPath());</span>
<span class="fc" id="L140">    }</span>

    /**
     * Checks if the provided path string is either null or has zero length and throws a {@link
     * IllegalArgumentException} if any of the two conditions apply.
     *
     * @param path the path string to be checked
     * @return The checked path.
     */
    private String checkPathArg(String path) {
        // disallow construction of a Path from an empty string
<span class="fc bfc" id="L151" title="All 2 branches covered.">        if (path == null) {</span>
<span class="fc" id="L152">            throw new IllegalArgumentException(&quot;Can not create a Path from a null string&quot;);</span>
        }
<span class="fc bfc" id="L154" title="All 2 branches covered.">        if (path.length() == 0) {</span>
<span class="fc" id="L155">            throw new IllegalArgumentException(&quot;Can not create a Path from an empty string&quot;);</span>
        }
<span class="fc" id="L157">        return path;</span>
    }

    /**
     * Construct a path from a String. Path strings are URIs, but with unescaped elements and some
     * additional normalization.
     *
     * @param pathString the string to construct a path from
     */
<span class="fc" id="L166">    public Path(String pathString) {</span>
<span class="fc" id="L167">        pathString = checkPathArg(pathString);</span>

        // We can't use 'new URI(String)' directly, since it assumes things are
        // escaped, which we don't require of Paths.

        // add a slash in front of paths with Windows drive letters
<span class="fc bfc" id="L173" title="All 2 branches covered.">        if (hasWindowsDrive(pathString, false)) {</span>
<span class="fc" id="L174">            pathString = &quot;/&quot; + pathString;</span>
        }

        // parse uri components
<span class="fc" id="L178">        String scheme = null;</span>
<span class="fc" id="L179">        String authority = null;</span>

<span class="fc" id="L181">        int start = 0;</span>

        // parse uri scheme, if any
<span class="fc" id="L184">        final int colon = pathString.indexOf(':');</span>
<span class="fc" id="L185">        final int slash = pathString.indexOf('/');</span>
<span class="pc bpc" id="L186" title="1 of 6 branches missed.">        if ((colon != -1) &amp;&amp; ((slash == -1) || (colon &lt; slash))) { // has a</span>
            // scheme
<span class="fc" id="L188">            scheme = pathString.substring(0, colon);</span>
<span class="fc" id="L189">            start = colon + 1;</span>
        }

        // parse uri authority, if any
<span class="fc bfc" id="L193" title="All 2 branches covered.">        if (pathString.startsWith(&quot;//&quot;, start)</span>
<span class="pc bpc" id="L194" title="1 of 2 branches missed.">                &amp;&amp; (pathString.length() - start &gt; 2)) { // has authority</span>
<span class="fc" id="L195">            final int nextSlash = pathString.indexOf('/', start + 2);</span>
<span class="fc bfc" id="L196" title="All 2 branches covered.">            final int authEnd = nextSlash &gt; 0 ? nextSlash : pathString.length();</span>
<span class="fc" id="L197">            authority = pathString.substring(start + 2, authEnd);</span>
<span class="fc" id="L198">            start = authEnd;</span>
        }

        // uri path is the rest of the string -- query &amp; fragment not supported
<span class="fc" id="L202">        final String path = pathString.substring(start, pathString.length());</span>

<span class="fc" id="L204">        initialize(scheme, authority, path);</span>
<span class="fc" id="L205">    }</span>

    /**
     * Construct a Path from a scheme, an authority and a path string.
     *
     * @param scheme the scheme string
     * @param authority the authority string
     * @param path the path string
     */
<span class="fc" id="L214">    public Path(String scheme, String authority, String path) {</span>
<span class="fc" id="L215">        path = checkPathArg(path);</span>
<span class="fc" id="L216">        initialize(scheme, authority, path);</span>
<span class="fc" id="L217">    }</span>

    /**
     * Initializes a path object given the scheme, authority and path string.
     *
     * @param scheme the scheme string.
     * @param authority the authority string.
     * @param path the path string.
     */
    private void initialize(String scheme, String authority, String path) {
        try {
<span class="fc" id="L228">            this.uri = new URI(scheme, authority, normalizePath(path), null, null).normalize();</span>
<span class="nc" id="L229">        } catch (URISyntaxException e) {</span>
<span class="nc" id="L230">            throw new IllegalArgumentException(e);</span>
<span class="fc" id="L231">        }</span>
<span class="fc" id="L232">    }</span>

    /**
     * Normalizes a path string.
     *
     * @param path the path string to normalize
     * @return the normalized path string
     */
    private String normalizePath(String path) {
        // remove consecutive slashes &amp; backslashes
<span class="fc" id="L242">        path = path.replace(&quot;\\&quot;, &quot;/&quot;);</span>
<span class="fc" id="L243">        path = path.replaceAll(&quot;/+&quot;, &quot;/&quot;);</span>

        // remove tailing separator
<span class="fc bfc" id="L246" title="All 2 branches covered.">        if (path.endsWith(SEPARATOR)</span>
<span class="fc bfc" id="L247" title="All 2 branches covered.">                &amp;&amp; !path.equals(SEPARATOR)</span>
                &amp;&amp; // UNIX root path
<span class="fc bfc" id="L249" title="All 2 branches covered.">                !WINDOWS_ROOT_DIR_REGEX.matcher(path).matches()) { // Windows root path)</span>

            // remove tailing slash
<span class="fc" id="L252">            path = path.substring(0, path.length() - SEPARATOR.length());</span>
        }

<span class="fc" id="L255">        return path;</span>
    }

    /**
     * Converts the path object to a {@link URI}.
     *
     * @return the {@link URI} object converted from the path object
     */
    public URI toUri() {
<span class="fc" id="L264">        return uri;</span>
    }

    /**
     * Returns the FileSystem that owns this Path.
     *
     * @return the FileSystem that owns this Path
     * @throws IOException thrown if the file system could not be retrieved
     */
    public FileSystem getFileSystem() throws IOException {
<span class="fc" id="L274">        return FileSystem.get(this.toUri());</span>
    }

    /**
     * Checks if the directory of this path is absolute.
     *
     * @return &lt;code&gt;true&lt;/code&gt; if the directory of this path is absolute, &lt;code&gt;false&lt;/code&gt;
     *     otherwise
     */
    public boolean isAbsolute() {
<span class="fc bfc" id="L284" title="All 2 branches covered.">        final int start = hasWindowsDrive(uri.getPath(), true) ? 3 : 0;</span>
<span class="fc" id="L285">        return uri.getPath().startsWith(SEPARATOR, start);</span>
    }

    /**
     * Returns the final component of this path, i.e., everything that follows the last separator.
     *
     * @return the final component of the path
     */
    public String getName() {
<span class="fc" id="L294">        final String path = uri.getPath();</span>
<span class="fc" id="L295">        final int slash = path.lastIndexOf(SEPARATOR);</span>
<span class="fc" id="L296">        return path.substring(slash + 1);</span>
    }

    /**
     * Return full path.
     *
     * @return full path
     */
    public String getPath() {
<span class="fc" id="L305">        return uri.getPath();</span>
    }

    /**
     * Returns the parent of a path, i.e., everything that precedes the last separator or &lt;code&gt;null
     * &lt;/code&gt; if at root.
     *
     * @return the parent of a path or &lt;code&gt;null&lt;/code&gt; if at root.
     */
    public Path getParent() {
<span class="fc" id="L315">        final String path = uri.getPath();</span>
<span class="fc" id="L316">        final int lastSlash = path.lastIndexOf('/');</span>
<span class="fc bfc" id="L317" title="All 2 branches covered.">        final int start = hasWindowsDrive(path, true) ? 3 : 0;</span>
<span class="pc bpc" id="L318" title="1 of 4 branches missed.">        if ((path.length() == start)</span>
                || // empty path
<span class="fc bfc" id="L320" title="All 2 branches covered.">                (lastSlash == start &amp;&amp; path.length() == start + 1)) { // at root</span>
<span class="fc" id="L321">            return null;</span>
        }
        String parent;
<span class="fc bfc" id="L324" title="All 2 branches covered.">        if (lastSlash == -1) {</span>
<span class="fc" id="L325">            parent = CUR_DIR;</span>
        } else {
<span class="fc bfc" id="L327" title="All 2 branches covered.">            final int end = hasWindowsDrive(path, true) ? 3 : 0;</span>
<span class="fc bfc" id="L328" title="All 2 branches covered.">            parent = path.substring(0, lastSlash == end ? end + 1 : lastSlash);</span>
        }
<span class="fc" id="L330">        return new Path(uri.getScheme(), uri.getAuthority(), parent);</span>
    }

    /**
     * Adds a suffix to the final name in the path.
     *
     * @param suffix The suffix to be added
     * @return the new path including the suffix
     */
    public Path suffix(String suffix) {
<span class="fc" id="L340">        return new Path(getParent(), getName() + suffix);</span>
    }

    @Override
    public String toString() {
        // we can't use uri.toString(), which escapes everything, because we want
        // illegal characters unescaped in the string, for glob processing, etc.
<span class="fc" id="L347">        final StringBuilder buffer = new StringBuilder();</span>
<span class="fc bfc" id="L348" title="All 2 branches covered.">        if (uri.getScheme() != null) {</span>
<span class="fc" id="L349">            buffer.append(uri.getScheme());</span>
<span class="fc" id="L350">            buffer.append(&quot;:&quot;);</span>
        }
<span class="pc bpc" id="L352" title="1 of 2 branches missed.">        if (uri.getAuthority() != null) {</span>
<span class="nc" id="L353">            buffer.append(&quot;//&quot;);</span>
<span class="nc" id="L354">            buffer.append(uri.getAuthority());</span>
        }
<span class="pc bpc" id="L356" title="1 of 2 branches missed.">        if (uri.getPath() != null) {</span>
<span class="fc" id="L357">            String path = uri.getPath();</span>
<span class="pc bpc" id="L358" title="1 of 2 branches missed.">            if (path.indexOf('/') == 0</span>
<span class="pc bpc" id="L359" title="1 of 2 branches missed.">                    &amp;&amp; hasWindowsDrive(path, true)</span>
                    &amp;&amp; // has windows drive
<span class="nc bnc" id="L361" title="All 2 branches missed.">                    uri.getScheme() == null</span>
                    &amp;&amp; // but no scheme
<span class="nc bnc" id="L363" title="All 2 branches missed.">                    uri.getAuthority() == null) { // or authority</span>
<span class="nc" id="L364">                path = path.substring(1); // remove slash before drive</span>
            }
<span class="fc" id="L366">            buffer.append(path);</span>
        }
<span class="fc" id="L368">        return buffer.toString();</span>
    }

    @Override
    public boolean equals(Object o) {
<span class="pc bpc" id="L373" title="1 of 2 branches missed.">        if (!(o instanceof Path)) {</span>
<span class="nc" id="L374">            return false;</span>
        }
<span class="fc" id="L376">        Path that = (Path) o;</span>
<span class="fc" id="L377">        return this.uri.equals(that.uri);</span>
    }

    @Override
    public int hashCode() {
<span class="fc" id="L382">        return uri.hashCode();</span>
    }

    public int compareTo(Object o) {
<span class="nc" id="L386">        Path that = (Path) o;</span>
<span class="nc" id="L387">        return this.uri.compareTo(that.uri);</span>
    }

    /**
     * Returns the number of elements in this path.
     *
     * @return the number of elements in this path
     */
    public int depth() {
<span class="fc" id="L396">        String path = uri.getPath();</span>
<span class="fc" id="L397">        int depth = 0;</span>
<span class="pc bpc" id="L398" title="1 of 4 branches missed.">        int slash = path.length() == 1 &amp;&amp; path.charAt(0) == '/' ? -1 : 0;</span>
<span class="fc bfc" id="L399" title="All 2 branches covered.">        while (slash != -1) {</span>
<span class="fc" id="L400">            depth++;</span>
<span class="fc" id="L401">            slash = path.indexOf(SEPARATOR, slash + 1);</span>
        }
<span class="fc" id="L403">        return depth;</span>
    }

    /**
     * Returns a qualified path object.
     *
     * @param fs the FileSystem that should be used to obtain the current working directory
     * @return the qualified path object
     */
    public Path makeQualified(FileSystem fs) {
<span class="fc" id="L413">        Path path = this;</span>
<span class="fc bfc" id="L414" title="All 2 branches covered.">        if (!isAbsolute()) {</span>
<span class="fc" id="L415">            path = new Path(fs.getWorkingDirectory(), this);</span>
        }

<span class="fc" id="L418">        final URI pathUri = path.toUri();</span>
<span class="fc" id="L419">        final URI fsUri = fs.getUri();</span>

<span class="fc" id="L421">        String scheme = pathUri.getScheme();</span>
<span class="fc" id="L422">        String authority = pathUri.getAuthority();</span>

<span class="pc bpc" id="L424" title="2 of 6 branches missed.">        if (scheme != null &amp;&amp; (authority != null || fsUri.getAuthority() == null)) {</span>
<span class="fc" id="L425">            return path;</span>
        }

<span class="pc bpc" id="L428" title="1 of 2 branches missed.">        if (scheme == null) {</span>
<span class="fc" id="L429">            scheme = fsUri.getScheme();</span>
        }

<span class="pc bpc" id="L432" title="1 of 2 branches missed.">        if (authority == null) {</span>
<span class="fc" id="L433">            authority = fsUri.getAuthority();</span>
<span class="pc bpc" id="L434" title="1 of 2 branches missed.">            if (authority == null) {</span>
<span class="fc" id="L435">                authority = &quot;&quot;;</span>
            }
        }

<span class="fc" id="L439">        return new Path(scheme + &quot;:&quot; + &quot;//&quot; + authority + pathUri.getPath());</span>
    }

    // ------------------------------------------------------------------------
    //  Legacy Serialization
    // ------------------------------------------------------------------------

    @Override
    public void read(DataInputView in) throws IOException {
<span class="nc" id="L448">        final boolean isNotNull = in.readBoolean();</span>
<span class="nc bnc" id="L449" title="All 2 branches missed.">        if (isNotNull) {</span>
<span class="nc" id="L450">            final String scheme = StringUtils.readNullableString(in);</span>
<span class="nc" id="L451">            final String userInfo = StringUtils.readNullableString(in);</span>
<span class="nc" id="L452">            final String host = StringUtils.readNullableString(in);</span>
<span class="nc" id="L453">            final int port = in.readInt();</span>
<span class="nc" id="L454">            final String path = StringUtils.readNullableString(in);</span>
<span class="nc" id="L455">            final String query = StringUtils.readNullableString(in);</span>
<span class="nc" id="L456">            final String fragment = StringUtils.readNullableString(in);</span>

            try {
<span class="nc" id="L459">                uri = new URI(scheme, userInfo, host, port, path, query, fragment);</span>
<span class="nc" id="L460">            } catch (URISyntaxException e) {</span>
<span class="nc" id="L461">                throw new IOException(&quot;Error reconstructing URI&quot;, e);</span>
<span class="nc" id="L462">            }</span>
        }
<span class="nc" id="L464">    }</span>

    @Override
    public void write(DataOutputView out) throws IOException {
<span class="nc bnc" id="L468" title="All 2 branches missed.">        if (uri == null) {</span>
<span class="nc" id="L469">            out.writeBoolean(false);</span>
        } else {
<span class="nc" id="L471">            out.writeBoolean(true);</span>
<span class="nc" id="L472">            StringUtils.writeNullableString(uri.getScheme(), out);</span>
<span class="nc" id="L473">            StringUtils.writeNullableString(uri.getUserInfo(), out);</span>
<span class="nc" id="L474">            StringUtils.writeNullableString(uri.getHost(), out);</span>
<span class="nc" id="L475">            out.writeInt(uri.getPort());</span>
<span class="nc" id="L476">            StringUtils.writeNullableString(uri.getPath(), out);</span>
<span class="nc" id="L477">            StringUtils.writeNullableString(uri.getQuery(), out);</span>
<span class="nc" id="L478">            StringUtils.writeNullableString(uri.getFragment(), out);</span>
        }
<span class="nc" id="L480">    }</span>

    // ------------------------------------------------------------------------
    //  Utilities
    // ------------------------------------------------------------------------

    /**
     * Checks if the provided path string contains a windows drive letter.
     *
     * @return True, if the path string contains a windows drive letter, false otherwise.
     */
    public boolean hasWindowsDrive() {
<span class="fc" id="L492">        return hasWindowsDrive(uri.getPath(), true);</span>
    }

    /**
     * Checks if the provided path string contains a windows drive letter.
     *
     * @param path the path to check
     * @param slashed true to indicate the first character of the string is a slash, false otherwise
     * @return &lt;code&gt;true&lt;/code&gt; if the path string contains a windows drive letter, false otherwise
     */
    private boolean hasWindowsDrive(String path, boolean slashed) {
<span class="fc bfc" id="L503" title="All 2 branches covered.">        final int start = slashed ? 1 : 0;</span>
<span class="fc bfc" id="L504" title="All 4 branches covered.">        return path.length() &gt;= start + 2</span>
<span class="fc bfc" id="L505" title="All 2 branches covered.">                &amp;&amp; (!slashed || path.charAt(0) == '/')</span>
<span class="fc bfc" id="L506" title="All 2 branches covered.">                &amp;&amp; path.charAt(start + 1) == ':'</span>
<span class="pc bpc" id="L507" title="1 of 4 branches missed.">                &amp;&amp; ((path.charAt(start) &gt;= 'A' &amp;&amp; path.charAt(start) &lt;= 'Z')</span>
<span class="pc bpc" id="L508" title="2 of 4 branches missed.">                        || (path.charAt(start) &gt;= 'a' &amp;&amp; path.charAt(start) &lt;= 'z'));</span>
    }

    // ------------------------------------------------------------------------
    //  Utilities
    // ------------------------------------------------------------------------

    /**
     * Creates a path for the given local file.
     *
     * &lt;p&gt;This method is useful to make sure the path creation for local files works seamlessly
     * across different operating systems. Especially Windows has slightly different rules for
     * slashes between schema and a local file path, making it sometimes tricky to produce
     * cross-platform URIs for local files.
     *
     * @param file The file that the path should represent.
     * @return A path representing the local file URI of the given file.
     */
    public static Path fromLocalFile(File file) {
<span class="fc" id="L527">        return new Path(file.toURI());</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.7.202105040129</span></div></body></html>