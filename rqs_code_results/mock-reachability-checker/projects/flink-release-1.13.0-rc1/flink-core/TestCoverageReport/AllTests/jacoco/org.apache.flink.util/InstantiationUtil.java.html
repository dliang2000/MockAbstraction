<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>InstantiationUtil.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Flink : Core</a> &gt; <a href="index.source.html" class="el_package">org.apache.flink.util</a> &gt; <span class="el_source">InstantiationUtil.java</span></div><h1>InstantiationUtil.java</h1><pre class="source lang-java linenums">/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * &quot;License&quot;); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.apache.flink.util;

import org.apache.flink.annotation.Internal;
import org.apache.flink.api.common.typeutils.TypeSerializer;
import org.apache.flink.api.common.typeutils.TypeSerializerSerializationUtil;
import org.apache.flink.api.common.typeutils.base.MapSerializer;
import org.apache.flink.api.java.typeutils.runtime.KryoRegistrationSerializerConfigSnapshot;
import org.apache.flink.configuration.Configuration;
import org.apache.flink.core.io.IOReadableWritable;
import org.apache.flink.core.memory.DataInputView;
import org.apache.flink.core.memory.DataInputViewStreamWrapper;
import org.apache.flink.core.memory.DataOutputViewStreamWrapper;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.io.ObjectStreamClass;
import java.io.OutputStream;
import java.io.Serializable;
import java.lang.reflect.Constructor;
import java.lang.reflect.Modifier;
import java.lang.reflect.Proxy;
import java.util.Collections;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Map;
import java.util.Set;

/** Utility class to create instances from class objects and checking failure reasons. */
@Internal
public final class InstantiationUtil {

<span class="fc" id="L57">    private static final Logger LOG = LoggerFactory.getLogger(InstantiationUtil.class);</span>

    /** A custom ObjectInputStream that can load classes using a specific ClassLoader. */
    public static class ClassLoaderObjectInputStream extends ObjectInputStream {

        protected final ClassLoader classLoader;

        public ClassLoaderObjectInputStream(InputStream in, ClassLoader classLoader)
                throws IOException {
<span class="fc" id="L66">            super(in);</span>
<span class="fc" id="L67">            this.classLoader = classLoader;</span>
<span class="fc" id="L68">        }</span>

        @Override
        protected Class&lt;?&gt; resolveClass(ObjectStreamClass desc)
                throws IOException, ClassNotFoundException {
<span class="pc bpc" id="L73" title="1 of 2 branches missed.">            if (classLoader != null) {</span>
<span class="fc" id="L74">                String name = desc.getName();</span>
                try {
<span class="fc" id="L76">                    return Class.forName(name, false, classLoader);</span>
<span class="fc" id="L77">                } catch (ClassNotFoundException ex) {</span>
                    // check if class is a primitive class
<span class="fc" id="L79">                    Class&lt;?&gt; cl = primitiveClasses.get(name);</span>
<span class="pc bpc" id="L80" title="1 of 2 branches missed.">                    if (cl != null) {</span>
                        // return primitive class
<span class="nc" id="L82">                        return cl;</span>
                    } else {
                        // throw ClassNotFoundException
<span class="fc" id="L85">                        throw ex;</span>
                    }
                }
            }

<span class="nc" id="L90">            return super.resolveClass(desc);</span>
        }

        @Override
        protected Class&lt;?&gt; resolveProxyClass(String[] interfaces)
                throws IOException, ClassNotFoundException {
<span class="pc bpc" id="L96" title="1 of 2 branches missed.">            if (classLoader != null) {</span>
<span class="fc" id="L97">                ClassLoader nonPublicLoader = null;</span>
<span class="fc" id="L98">                boolean hasNonPublicInterface = false;</span>

                // define proxy in class loader of non-public interface(s), if any
<span class="fc" id="L101">                Class&lt;?&gt;[] classObjs = new Class&lt;?&gt;[interfaces.length];</span>
<span class="fc bfc" id="L102" title="All 2 branches covered.">                for (int i = 0; i &lt; interfaces.length; i++) {</span>
<span class="fc" id="L103">                    Class&lt;?&gt; cl = Class.forName(interfaces[i], false, classLoader);</span>
<span class="pc bpc" id="L104" title="1 of 2 branches missed.">                    if ((cl.getModifiers() &amp; Modifier.PUBLIC) == 0) {</span>
<span class="pc bpc" id="L105" title="1 of 2 branches missed.">                        if (hasNonPublicInterface) {</span>
<span class="nc bnc" id="L106" title="All 2 branches missed.">                            if (nonPublicLoader != cl.getClassLoader()) {</span>
<span class="nc" id="L107">                                throw new IllegalAccessError(</span>
                                        &quot;conflicting non-public interface class loaders&quot;);
                            }
                        } else {
<span class="fc" id="L111">                            nonPublicLoader = cl.getClassLoader();</span>
<span class="fc" id="L112">                            hasNonPublicInterface = true;</span>
                        }
                    }
<span class="fc" id="L115">                    classObjs[i] = cl;</span>
                }
                try {
<span class="pc bpc" id="L118" title="1 of 2 branches missed.">                    return Proxy.getProxyClass(</span>
                            hasNonPublicInterface ? nonPublicLoader : classLoader, classObjs);
<span class="nc" id="L120">                } catch (IllegalArgumentException e) {</span>
<span class="nc" id="L121">                    throw new ClassNotFoundException(null, e);</span>
                }
            }

<span class="nc" id="L125">            return super.resolveProxyClass(interfaces);</span>
        }

        // ------------------------------------------------

<span class="fc" id="L130">        private static final HashMap&lt;String, Class&lt;?&gt;&gt; primitiveClasses = new HashMap&lt;&gt;(9);</span>

        static {
<span class="fc" id="L133">            primitiveClasses.put(&quot;boolean&quot;, boolean.class);</span>
<span class="fc" id="L134">            primitiveClasses.put(&quot;byte&quot;, byte.class);</span>
<span class="fc" id="L135">            primitiveClasses.put(&quot;char&quot;, char.class);</span>
<span class="fc" id="L136">            primitiveClasses.put(&quot;short&quot;, short.class);</span>
<span class="fc" id="L137">            primitiveClasses.put(&quot;int&quot;, int.class);</span>
<span class="fc" id="L138">            primitiveClasses.put(&quot;long&quot;, long.class);</span>
<span class="fc" id="L139">            primitiveClasses.put(&quot;float&quot;, float.class);</span>
<span class="fc" id="L140">            primitiveClasses.put(&quot;double&quot;, double.class);</span>
<span class="fc" id="L141">            primitiveClasses.put(&quot;void&quot;, void.class);</span>
<span class="fc" id="L142">        }</span>
    }

    /**
     * This is maintained as a temporary workaround for FLINK-6869.
     *
     * &lt;p&gt;Before 1.3, the Scala serializers did not specify the serialVersionUID. Although since 1.3
     * they are properly specified, we still have to ignore them for now as their previous
     * serialVersionUIDs will vary depending on the Scala version.
     *
     * &lt;p&gt;This can be removed once 1.2 is no longer supported.
     */
<span class="fc" id="L154">    private static final Set&lt;String&gt; scalaSerializerClassnames = new HashSet&lt;&gt;();</span>

    static {
<span class="fc" id="L157">        scalaSerializerClassnames.add(&quot;org.apache.flink.api.scala.typeutils.TraversableSerializer&quot;);</span>
<span class="fc" id="L158">        scalaSerializerClassnames.add(&quot;org.apache.flink.api.scala.typeutils.CaseClassSerializer&quot;);</span>
<span class="fc" id="L159">        scalaSerializerClassnames.add(&quot;org.apache.flink.api.scala.typeutils.EitherSerializer&quot;);</span>
<span class="fc" id="L160">        scalaSerializerClassnames.add(&quot;org.apache.flink.api.scala.typeutils.EnumValueSerializer&quot;);</span>
<span class="fc" id="L161">        scalaSerializerClassnames.add(&quot;org.apache.flink.api.scala.typeutils.OptionSerializer&quot;);</span>
<span class="fc" id="L162">        scalaSerializerClassnames.add(&quot;org.apache.flink.api.scala.typeutils.TrySerializer&quot;);</span>
<span class="fc" id="L163">        scalaSerializerClassnames.add(&quot;org.apache.flink.api.scala.typeutils.UnitSerializer&quot;);</span>
    }

    /**
     * The serialVersionUID might change between Scala versions and since those classes are part of
     * the tuple serializer config snapshots we need to ignore them.
     *
     * @see &lt;a href=&quot;https://issues.apache.org/jira/browse/FLINK-8451&quot;&gt;FLINK-8451&lt;/a&gt;
     */
<span class="fc" id="L172">    private static final Set&lt;String&gt; scalaTypes = new HashSet&lt;&gt;();</span>

    static {
<span class="fc" id="L175">        scalaTypes.add(&quot;scala.Tuple1&quot;);</span>
<span class="fc" id="L176">        scalaTypes.add(&quot;scala.Tuple2&quot;);</span>
<span class="fc" id="L177">        scalaTypes.add(&quot;scala.Tuple3&quot;);</span>
<span class="fc" id="L178">        scalaTypes.add(&quot;scala.Tuple4&quot;);</span>
<span class="fc" id="L179">        scalaTypes.add(&quot;scala.Tuple5&quot;);</span>
<span class="fc" id="L180">        scalaTypes.add(&quot;scala.Tuple6&quot;);</span>
<span class="fc" id="L181">        scalaTypes.add(&quot;scala.Tuple7&quot;);</span>
<span class="fc" id="L182">        scalaTypes.add(&quot;scala.Tuple8&quot;);</span>
<span class="fc" id="L183">        scalaTypes.add(&quot;scala.Tuple9&quot;);</span>
<span class="fc" id="L184">        scalaTypes.add(&quot;scala.Tuple10&quot;);</span>
<span class="fc" id="L185">        scalaTypes.add(&quot;scala.Tuple11&quot;);</span>
<span class="fc" id="L186">        scalaTypes.add(&quot;scala.Tuple12&quot;);</span>
<span class="fc" id="L187">        scalaTypes.add(&quot;scala.Tuple13&quot;);</span>
<span class="fc" id="L188">        scalaTypes.add(&quot;scala.Tuple14&quot;);</span>
<span class="fc" id="L189">        scalaTypes.add(&quot;scala.Tuple15&quot;);</span>
<span class="fc" id="L190">        scalaTypes.add(&quot;scala.Tuple16&quot;);</span>
<span class="fc" id="L191">        scalaTypes.add(&quot;scala.Tuple17&quot;);</span>
<span class="fc" id="L192">        scalaTypes.add(&quot;scala.Tuple18&quot;);</span>
<span class="fc" id="L193">        scalaTypes.add(&quot;scala.Tuple19&quot;);</span>
<span class="fc" id="L194">        scalaTypes.add(&quot;scala.Tuple20&quot;);</span>
<span class="fc" id="L195">        scalaTypes.add(&quot;scala.Tuple21&quot;);</span>
<span class="fc" id="L196">        scalaTypes.add(&quot;scala.Tuple22&quot;);</span>
<span class="fc" id="L197">        scalaTypes.add(&quot;scala.Tuple1$mcJ$sp&quot;);</span>
<span class="fc" id="L198">        scalaTypes.add(&quot;scala.Tuple1$mcI$sp&quot;);</span>
<span class="fc" id="L199">        scalaTypes.add(&quot;scala.Tuple1$mcD$sp&quot;);</span>
<span class="fc" id="L200">        scalaTypes.add(&quot;scala.Tuple2$mcJJ$sp&quot;);</span>
<span class="fc" id="L201">        scalaTypes.add(&quot;scala.Tuple2$mcJI$sp&quot;);</span>
<span class="fc" id="L202">        scalaTypes.add(&quot;scala.Tuple2$mcJD$sp&quot;);</span>
<span class="fc" id="L203">        scalaTypes.add(&quot;scala.Tuple2$mcIJ$sp&quot;);</span>
<span class="fc" id="L204">        scalaTypes.add(&quot;scala.Tuple2$mcII$sp&quot;);</span>
<span class="fc" id="L205">        scalaTypes.add(&quot;scala.Tuple2$mcID$sp&quot;);</span>
<span class="fc" id="L206">        scalaTypes.add(&quot;scala.Tuple2$mcDJ$sp&quot;);</span>
<span class="fc" id="L207">        scalaTypes.add(&quot;scala.Tuple2$mcDI$sp&quot;);</span>
<span class="fc" id="L208">        scalaTypes.add(&quot;scala.Tuple2$mcDD$sp&quot;);</span>
<span class="fc" id="L209">        scalaTypes.add(&quot;scala.Enumeration$ValueSet&quot;);</span>
<span class="fc" id="L210">    }</span>

    /**
     * An {@link ObjectInputStream} that ignores serialVersionUID mismatches when deserializing
     * objects of anonymous classes or our Scala serializer classes and also replaces occurences of
     * GenericData.Array (from Avro) by a dummy class so that the KryoSerializer can still be
     * deserialized without Avro being on the classpath.
     *
     * &lt;p&gt;The {@link TypeSerializerSerializationUtil.TypeSerializerSerializationProxy} uses this
     * specific object input stream to read serializers, so that mismatching serialVersionUIDs of
     * anonymous classes / Scala serializers are ignored. This is a required workaround to maintain
     * backwards compatibility for our pre-1.3 Scala serializers. See FLINK-6869 for details.
     *
     * @see &lt;a href=&quot;https://issues.apache.org/jira/browse/FLINK-6869&quot;&gt;FLINK-6869&lt;/a&gt;
     */
    public static class FailureTolerantObjectInputStream
            extends InstantiationUtil.ClassLoaderObjectInputStream {

        public FailureTolerantObjectInputStream(InputStream in, ClassLoader cl) throws IOException {
<span class="fc" id="L229">            super(in, cl);</span>
<span class="fc" id="L230">        }</span>

        @Override
        protected ObjectStreamClass readClassDescriptor()
                throws IOException, ClassNotFoundException {
<span class="fc" id="L235">            ObjectStreamClass streamClassDescriptor = super.readClassDescriptor();</span>

            try {
<span class="fc" id="L238">                Class.forName(streamClassDescriptor.getName(), false, classLoader);</span>
<span class="fc" id="L239">            } catch (ClassNotFoundException e) {</span>

<span class="fc" id="L241">                final ObjectStreamClass equivalentSerializer =</span>
<span class="fc" id="L242">                        MigrationUtil.getEquivalentSerializer(streamClassDescriptor.getName());</span>

<span class="fc bfc" id="L244" title="All 2 branches covered.">                if (equivalentSerializer != null) {</span>
<span class="fc" id="L245">                    return equivalentSerializer;</span>
                }
<span class="fc" id="L247">            }</span>

<span class="fc" id="L249">            final Class localClass = resolveClass(streamClassDescriptor);</span>
<span class="fc" id="L250">            final String name = localClass.getName();</span>
<span class="pc bpc" id="L251" title="1 of 2 branches missed.">            if (scalaSerializerClassnames.contains(name)</span>
<span class="pc bpc" id="L252" title="1 of 2 branches missed.">                    || scalaTypes.contains(name)</span>
<span class="fc bfc" id="L253" title="All 2 branches covered.">                    || isAnonymousClass(localClass)</span>
<span class="pc bpc" id="L254" title="1 of 2 branches missed.">                    || isOldAvroSerializer(name, streamClassDescriptor.getSerialVersionUID())) {</span>
<span class="fc" id="L255">                final ObjectStreamClass localClassDescriptor = ObjectStreamClass.lookup(localClass);</span>
<span class="pc bpc" id="L256" title="1 of 2 branches missed.">                if (localClassDescriptor != null</span>
<span class="fc" id="L257">                        &amp;&amp; localClassDescriptor.getSerialVersionUID()</span>
<span class="pc bpc" id="L258" title="1 of 2 branches missed.">                                != streamClassDescriptor.getSerialVersionUID()) {</span>
<span class="fc" id="L259">                    LOG.warn(</span>
                            &quot;Ignoring serialVersionUID mismatch for class {}; was {}, now {}.&quot;,
<span class="fc" id="L261">                            streamClassDescriptor.getName(),</span>
<span class="fc" id="L262">                            streamClassDescriptor.getSerialVersionUID(),</span>
<span class="fc" id="L263">                            localClassDescriptor.getSerialVersionUID());</span>

<span class="fc" id="L265">                    streamClassDescriptor = localClassDescriptor;</span>
                }
            }

<span class="fc" id="L269">            return streamClassDescriptor;</span>
        }
    }

    private static boolean isAnonymousClass(Class clazz) {
<span class="fc" id="L274">        final String name = clazz.getName();</span>

        // isAnonymousClass does not work for anonymous Scala classes; additionally check by class
        // name
<span class="pc bpc" id="L278" title="3 of 6 branches missed.">        if (name.contains(&quot;$anon$&quot;) || name.contains(&quot;$anonfun&quot;) || name.contains(&quot;$macro$&quot;)) {</span>
<span class="nc" id="L279">            return true;</span>
        }

        // calling isAnonymousClass or getSimpleName can throw InternalError for certain Scala
        // types, see https://issues.scala-lang.org/browse/SI-2034
        // until we move to JDK 9, this try-catch is necessary
        try {
<span class="fc" id="L286">            return clazz.isAnonymousClass();</span>
<span class="nc" id="L287">        } catch (InternalError e) {</span>
<span class="nc" id="L288">            return false;</span>
        }
    }

    private static boolean isOldAvroSerializer(String name, long serialVersionUID) {
        // please see FLINK-11436 for details on why we need to ignore serial version UID here for
        // the AvroSerializer
<span class="fc bfc" id="L295" title="All 2 branches covered.">        return (serialVersionUID == 1)</span>
<span class="pc bpc" id="L296" title="1 of 2 branches missed.">                &amp;&amp; &quot;org.apache.flink.formats.avro.typeutils.AvroSerializer&quot;.equals(name);</span>
    }

    /**
     * A mapping between the full path of a deprecated serializer and its equivalent. These mappings
     * are hardcoded and fixed.
     *
     * &lt;p&gt;IMPORTANT: mappings can be removed after 1 release as there will be a &quot;migration path&quot;. As
     * an example, a serializer is removed in 1.5-SNAPSHOT, then the mapping should be added for
     * 1.5, and it can be removed in 1.6, as the path would be Flink-{&lt; 1.5} -&gt; Flink-1.5 -&gt;
     * Flink-{&gt;= 1.6}.
     */
<span class="fc" id="L308">    private enum MigrationUtil {</span>

        // To add a new mapping just pick a name and add an entry as the following:

<span class="fc" id="L312">        GENERIC_DATA_ARRAY_SERIALIZER(</span>
                &quot;org.apache.avro.generic.GenericData$Array&quot;,
<span class="fc" id="L314">                ObjectStreamClass.lookup(</span>
                        KryoRegistrationSerializerConfigSnapshot.DummyRegisteredClass.class)),
<span class="fc" id="L316">        HASH_MAP_SERIALIZER(</span>
                &quot;org.apache.flink.runtime.state.HashMapSerializer&quot;,
<span class="fc" id="L318">                ObjectStreamClass.lookup(MapSerializer.class)); // added in 1.5</span>

        /**
         * An internal unmodifiable map containing the mappings between deprecated and new
         * serializers.
         */
<span class="fc" id="L324">        private static final Map&lt;String, ObjectStreamClass&gt; EQUIVALENCE_MAP =</span>
<span class="fc" id="L325">                Collections.unmodifiableMap(initMap());</span>

        /** The full name of the class of the old serializer. */
        private final String oldSerializerName;

        /** The serialization descriptor of the class of the new serializer. */
        private final ObjectStreamClass newSerializerStreamClass;

<span class="fc" id="L333">        MigrationUtil(String oldSerializerName, ObjectStreamClass newSerializerStreamClass) {</span>
<span class="fc" id="L334">            this.oldSerializerName = oldSerializerName;</span>
<span class="fc" id="L335">            this.newSerializerStreamClass = newSerializerStreamClass;</span>
<span class="fc" id="L336">        }</span>

        private static Map&lt;String, ObjectStreamClass&gt; initMap() {
<span class="fc" id="L339">            final Map&lt;String, ObjectStreamClass&gt; init = new HashMap&lt;&gt;(4);</span>
<span class="fc bfc" id="L340" title="All 2 branches covered.">            for (MigrationUtil m : MigrationUtil.values()) {</span>
<span class="fc" id="L341">                init.put(m.oldSerializerName, m.newSerializerStreamClass);</span>
            }
<span class="fc" id="L343">            return init;</span>
        }

        private static ObjectStreamClass getEquivalentSerializer(String classDescriptorName) {
<span class="fc" id="L347">            return EQUIVALENCE_MAP.get(classDescriptorName);</span>
        }
    }

    /**
     * Creates a new instance of the given class name and type using the provided {@link
     * ClassLoader}.
     *
     * @param className of the class to load
     * @param targetType type of the instantiated class
     * @param classLoader to use for loading the class
     * @param &lt;T&gt; type of the instantiated class
     * @return Instance of the given class name
     * @throws FlinkException if the class could not be found
     */
    public static &lt;T&gt; T instantiate(
            final String className, final Class&lt;T&gt; targetType, final ClassLoader classLoader)
            throws FlinkException {
        final Class&lt;? extends T&gt; clazz;
        try {
<span class="nc" id="L367">            clazz = Class.forName(className, false, classLoader).asSubclass(targetType);</span>
<span class="nc" id="L368">        } catch (ClassNotFoundException e) {</span>
<span class="nc" id="L369">            throw new FlinkException(</span>
<span class="nc" id="L370">                    String.format(</span>
                            &quot;Could not instantiate class '%s' of type '%s'. Please make sure that this class is on your class path.&quot;,
<span class="nc" id="L372">                            className, targetType.getName()),</span>
                    e);
<span class="nc" id="L374">        }</span>

<span class="nc" id="L376">        return instantiate(clazz);</span>
    }

    /**
     * Creates a new instance of the given class.
     *
     * @param &lt;T&gt; The generic type of the class.
     * @param clazz The class to instantiate.
     * @param castTo Optional parameter, specifying the class that the given class must be a
     *     subclass off. This argument is added to prevent class cast exceptions occurring later.
     * @return An instance of the given class.
     * @throws RuntimeException Thrown, if the class could not be instantiated. The exception
     *     contains a detailed message about the reason why the instantiation failed.
     */
    public static &lt;T&gt; T instantiate(Class&lt;T&gt; clazz, Class&lt;? super T&gt; castTo) {
<span class="pc bpc" id="L391" title="1 of 2 branches missed.">        if (clazz == null) {</span>
<span class="nc" id="L392">            throw new NullPointerException();</span>
        }

        // check if the class is a subclass, if the check is required
<span class="pc bpc" id="L396" title="1 of 4 branches missed.">        if (castTo != null &amp;&amp; !castTo.isAssignableFrom(clazz)) {</span>
<span class="nc" id="L397">            throw new RuntimeException(</span>
                    &quot;The class '&quot;
<span class="nc" id="L399">                            + clazz.getName()</span>
                            + &quot;' is not a subclass of '&quot;
<span class="nc" id="L401">                            + castTo.getName()</span>
                            + &quot;' as is required.&quot;);
        }

<span class="fc" id="L405">        return instantiate(clazz);</span>
    }

    /**
     * Creates a new instance of the given class.
     *
     * @param &lt;T&gt; The generic type of the class.
     * @param clazz The class to instantiate.
     * @return An instance of the given class.
     * @throws RuntimeException Thrown, if the class could not be instantiated. The exception
     *     contains a detailed message about the reason why the instantiation failed.
     */
    public static &lt;T&gt; T instantiate(Class&lt;T&gt; clazz) {
<span class="pc bpc" id="L418" title="1 of 2 branches missed.">        if (clazz == null) {</span>
<span class="nc" id="L419">            throw new NullPointerException();</span>
        }

        // try to instantiate the class
        try {
<span class="fc" id="L424">            return clazz.newInstance();</span>
<span class="nc" id="L425">        } catch (InstantiationException | IllegalAccessException iex) {</span>
            // check for the common problem causes
<span class="nc" id="L427">            checkForInstantiation(clazz);</span>

            // here we are, if non of the common causes was the problem. then the error was
            // most likely an exception in the constructor or field initialization
<span class="nc" id="L431">            throw new RuntimeException(</span>
                    &quot;Could not instantiate type '&quot;
<span class="nc" id="L433">                            + clazz.getName()</span>
                            + &quot;' due to an unspecified exception: &quot;
<span class="nc" id="L435">                            + iex.getMessage(),</span>
                    iex);
<span class="nc" id="L437">        } catch (Throwable t) {</span>
<span class="nc" id="L438">            String message = t.getMessage();</span>
<span class="nc" id="L439">            throw new RuntimeException(</span>
                    &quot;Could not instantiate type '&quot;
<span class="nc bnc" id="L441" title="All 2 branches missed.">                            + clazz.getName()</span>
                            + &quot;' Most likely the constructor (or a member variable initialization) threw an exception&quot;
                            + (message == null ? &quot;.&quot; : &quot;: &quot; + message),
                    t);
        }
    }

    /**
     * Checks, whether the given class has a public nullary constructor.
     *
     * @param clazz The class to check.
     * @return True, if the class has a public nullary constructor, false if not.
     */
    public static boolean hasPublicNullaryConstructor(Class&lt;?&gt; clazz) {
<span class="fc" id="L455">        Constructor&lt;?&gt;[] constructors = clazz.getConstructors();</span>
<span class="pc bpc" id="L456" title="1 of 2 branches missed.">        for (Constructor&lt;?&gt; constructor : constructors) {</span>
<span class="pc bpc" id="L457" title="1 of 2 branches missed.">            if (constructor.getParameterTypes().length == 0</span>
<span class="pc bpc" id="L458" title="1 of 2 branches missed.">                    &amp;&amp; Modifier.isPublic(constructor.getModifiers())) {</span>
<span class="fc" id="L459">                return true;</span>
            }
        }
<span class="nc" id="L462">        return false;</span>
    }

    /**
     * Checks, whether the given class is public.
     *
     * @param clazz The class to check.
     * @return True, if the class is public, false if not.
     */
    public static boolean isPublic(Class&lt;?&gt; clazz) {
<span class="fc" id="L472">        return Modifier.isPublic(clazz.getModifiers());</span>
    }

    /**
     * Checks, whether the class is a proper class, i.e. not abstract or an interface, and not a
     * primitive type.
     *
     * @param clazz The class to check.
     * @return True, if the class is a proper class, false otherwise.
     */
    public static boolean isProperClass(Class&lt;?&gt; clazz) {
<span class="fc" id="L483">        int mods = clazz.getModifiers();</span>
<span class="fc bfc" id="L484" title="All 2 branches covered.">        return !(Modifier.isAbstract(mods)</span>
<span class="pc bpc" id="L485" title="1 of 2 branches missed.">                || Modifier.isInterface(mods)</span>
<span class="pc bpc" id="L486" title="1 of 2 branches missed.">                || Modifier.isNative(mods));</span>
    }

    /**
     * Checks, whether the class is an inner class that is not statically accessible. That is
     * especially true for anonymous inner classes.
     *
     * @param clazz The class to check.
     * @return True, if the class is a non-statically accessible inner class.
     */
    public static boolean isNonStaticInnerClass(Class&lt;?&gt; clazz) {
<span class="nc bnc" id="L497" title="All 2 branches missed.">        return clazz.getEnclosingClass() != null</span>
<span class="nc bnc" id="L498" title="All 4 branches missed.">                &amp;&amp; (clazz.getDeclaringClass() == null || !Modifier.isStatic(clazz.getModifiers()));</span>
    }

    /**
     * Performs a standard check whether the class can be instantiated by {@code
     * Class#newInstance()}.
     *
     * @param clazz The class to check.
     * @throws RuntimeException Thrown, if the class cannot be instantiated by {@code
     *     Class#newInstance()}.
     */
    public static void checkForInstantiation(Class&lt;?&gt; clazz) {
<span class="fc" id="L510">        final String errorMessage = checkForInstantiationError(clazz);</span>

<span class="pc bpc" id="L512" title="1 of 2 branches missed.">        if (errorMessage != null) {</span>
<span class="fc" id="L513">            throw new RuntimeException(</span>
<span class="fc" id="L514">                    &quot;The class '&quot; + clazz.getName() + &quot;' is not instantiable: &quot; + errorMessage);</span>
        }
<span class="nc" id="L516">    }</span>

    public static String checkForInstantiationError(Class&lt;?&gt; clazz) {
<span class="pc bpc" id="L519" title="1 of 2 branches missed.">        if (!isPublic(clazz)) {</span>
<span class="fc" id="L520">            return &quot;The class is not public.&quot;;</span>
<span class="nc bnc" id="L521" title="All 2 branches missed.">        } else if (clazz.isArray()) {</span>
<span class="nc" id="L522">            return &quot;The class is an array. An array cannot be simply instantiated, as with a parameterless constructor.&quot;;</span>
<span class="nc bnc" id="L523" title="All 2 branches missed.">        } else if (!isProperClass(clazz)) {</span>
<span class="nc" id="L524">            return &quot;The class is not a proper class. It is either abstract, an interface, or a primitive type.&quot;;</span>
<span class="nc bnc" id="L525" title="All 2 branches missed.">        } else if (isNonStaticInnerClass(clazz)) {</span>
<span class="nc" id="L526">            return &quot;The class is an inner class, but not statically accessible.&quot;;</span>
<span class="nc bnc" id="L527" title="All 2 branches missed.">        } else if (!hasPublicNullaryConstructor(clazz)) {</span>
<span class="nc" id="L528">            return &quot;The class has no (implicit) public nullary constructor, i.e. a constructor without arguments.&quot;;</span>
        } else {
<span class="nc" id="L530">            return null;</span>
        }
    }

    public static &lt;T&gt; T readObjectFromConfig(Configuration config, String key, ClassLoader cl)
            throws IOException, ClassNotFoundException {
<span class="nc" id="L536">        byte[] bytes = config.getBytes(key, null);</span>
<span class="nc bnc" id="L537" title="All 2 branches missed.">        if (bytes == null) {</span>
<span class="nc" id="L538">            return null;</span>
        }

<span class="nc" id="L541">        return deserializeObject(bytes, cl);</span>
    }

    public static void writeObjectToConfig(Object o, Configuration config, String key)
            throws IOException {
<span class="fc" id="L546">        byte[] bytes = serializeObject(o);</span>
<span class="fc" id="L547">        config.setBytes(key, bytes);</span>
<span class="fc" id="L548">    }</span>

    public static &lt;T&gt; byte[] serializeToByteArray(TypeSerializer&lt;T&gt; serializer, T record)
            throws IOException {
<span class="pc bpc" id="L552" title="1 of 2 branches missed.">        if (record == null) {</span>
<span class="nc" id="L553">            throw new NullPointerException(&quot;Record to serialize to byte array must not be null.&quot;);</span>
        }

<span class="fc" id="L556">        ByteArrayOutputStream bos = new ByteArrayOutputStream(64);</span>
<span class="fc" id="L557">        DataOutputViewStreamWrapper outputViewWrapper = new DataOutputViewStreamWrapper(bos);</span>
<span class="fc" id="L558">        serializer.serialize(record, outputViewWrapper);</span>
<span class="fc" id="L559">        return bos.toByteArray();</span>
    }

    public static &lt;T&gt; T deserializeFromByteArray(TypeSerializer&lt;T&gt; serializer, byte[] buf)
            throws IOException {
<span class="pc bpc" id="L564" title="1 of 2 branches missed.">        if (buf == null) {</span>
<span class="nc" id="L565">            throw new NullPointerException(&quot;Byte array to deserialize from must not be null.&quot;);</span>
        }

<span class="fc" id="L568">        DataInputViewStreamWrapper inputViewWrapper =</span>
                new DataInputViewStreamWrapper(new ByteArrayInputStream(buf));
<span class="fc" id="L570">        return serializer.deserialize(inputViewWrapper);</span>
    }

    public static &lt;T&gt; T deserializeFromByteArray(TypeSerializer&lt;T&gt; serializer, T reuse, byte[] buf)
            throws IOException {
<span class="nc bnc" id="L575" title="All 2 branches missed.">        if (buf == null) {</span>
<span class="nc" id="L576">            throw new NullPointerException(&quot;Byte array to deserialize from must not be null.&quot;);</span>
        }

<span class="nc" id="L579">        DataInputViewStreamWrapper inputViewWrapper =</span>
                new DataInputViewStreamWrapper(new ByteArrayInputStream(buf));
<span class="nc" id="L581">        return serializer.deserialize(reuse, inputViewWrapper);</span>
    }

    @SuppressWarnings(&quot;unchecked&quot;)
    public static &lt;T&gt; T deserializeObject(byte[] bytes, ClassLoader cl)
            throws IOException, ClassNotFoundException {
<span class="fc" id="L587">        return deserializeObject(bytes, cl, false);</span>
    }

    @SuppressWarnings(&quot;unchecked&quot;)
    public static &lt;T&gt; T deserializeObject(InputStream in, ClassLoader cl)
            throws IOException, ClassNotFoundException {
<span class="fc" id="L593">        return deserializeObject(in, cl, false);</span>
    }

    @SuppressWarnings(&quot;unchecked&quot;)
    public static &lt;T&gt; T deserializeObject(byte[] bytes, ClassLoader cl, boolean isFailureTolerant)
            throws IOException, ClassNotFoundException {

<span class="fc" id="L600">        return deserializeObject(new ByteArrayInputStream(bytes), cl, isFailureTolerant);</span>
    }

    @SuppressWarnings(&quot;unchecked&quot;)
    public static &lt;T&gt; T deserializeObject(InputStream in, ClassLoader cl, boolean isFailureTolerant)
            throws IOException, ClassNotFoundException {

<span class="fc" id="L607">        final ClassLoader old = Thread.currentThread().getContextClassLoader();</span>
        // not using resource try to avoid AutoClosable's close() on the given stream
        try {
<span class="pc bpc" id="L610" title="1 of 2 branches missed.">            ObjectInputStream oois =</span>
                    isFailureTolerant
                            ? new InstantiationUtil.FailureTolerantObjectInputStream(in, cl)
                            : new InstantiationUtil.ClassLoaderObjectInputStream(in, cl);
<span class="fc" id="L614">            Thread.currentThread().setContextClassLoader(cl);</span>
<span class="fc" id="L615">            return (T) oois.readObject();</span>
        } finally {
<span class="fc" id="L617">            Thread.currentThread().setContextClassLoader(old);</span>
        }
    }

    public static byte[] serializeObject(Object o) throws IOException {
<span class="fc" id="L622">        try (ByteArrayOutputStream baos = new ByteArrayOutputStream();</span>
<span class="fc" id="L623">                ObjectOutputStream oos = new ObjectOutputStream(baos)) {</span>
<span class="fc" id="L624">            oos.writeObject(o);</span>
<span class="fc" id="L625">            oos.flush();</span>
<span class="fc" id="L626">            return baos.toByteArray();</span>
        }
    }

    public static void serializeObject(OutputStream out, Object o) throws IOException {
<span class="pc bpc" id="L631" title="1 of 2 branches missed.">        ObjectOutputStream oos =</span>
                out instanceof ObjectOutputStream
                        ? (ObjectOutputStream) out
                        : new ObjectOutputStream(out);
<span class="fc" id="L635">        oos.writeObject(o);</span>
<span class="fc" id="L636">    }</span>

    public static boolean isSerializable(Object o) {
        try {
<span class="nc" id="L640">            serializeObject(o);</span>
<span class="nc" id="L641">        } catch (IOException e) {</span>
<span class="nc" id="L642">            return false;</span>
<span class="nc" id="L643">        }</span>

<span class="nc" id="L645">        return true;</span>
    }

    /**
     * Clones the given serializable object using Java serialization.
     *
     * @param obj Object to clone
     * @param &lt;T&gt; Type of the object to clone
     * @return The cloned object
     * @throws IOException Thrown if the serialization or deserialization process fails.
     * @throws ClassNotFoundException Thrown if any of the classes referenced by the object cannot
     *     be resolved during deserialization.
     */
    public static &lt;T extends Serializable&gt; T clone(T obj)
            throws IOException, ClassNotFoundException {
<span class="nc bnc" id="L660" title="All 2 branches missed.">        if (obj == null) {</span>
<span class="nc" id="L661">            return null;</span>
        } else {
<span class="nc" id="L663">            return clone(obj, obj.getClass().getClassLoader());</span>
        }
    }

    /**
     * Clones the given serializable object using Java serialization, using the given classloader to
     * resolve the cloned classes.
     *
     * @param obj Object to clone
     * @param classLoader The classloader to resolve the classes during deserialization.
     * @param &lt;T&gt; Type of the object to clone
     * @return Cloned object
     * @throws IOException Thrown if the serialization or deserialization process fails.
     * @throws ClassNotFoundException Thrown if any of the classes referenced by the object cannot
     *     be resolved during deserialization.
     */
    public static &lt;T extends Serializable&gt; T clone(T obj, ClassLoader classLoader)
            throws IOException, ClassNotFoundException {
<span class="pc bpc" id="L681" title="1 of 2 branches missed.">        if (obj == null) {</span>
<span class="nc" id="L682">            return null;</span>
        } else {
<span class="fc" id="L684">            final byte[] serializedObject = serializeObject(obj);</span>
<span class="fc" id="L685">            return deserializeObject(serializedObject, classLoader);</span>
        }
    }

    /**
     * Clones the given writable using the {@link IOReadableWritable serialization}.
     *
     * @param original Object to clone
     * @param &lt;T&gt; Type of the object to clone
     * @return Cloned object
     * @throws IOException Thrown is the serialization fails.
     */
    public static &lt;T extends IOReadableWritable&gt; T createCopyWritable(T original)
            throws IOException {
<span class="pc bpc" id="L699" title="1 of 2 branches missed.">        if (original == null) {</span>
<span class="nc" id="L700">            return null;</span>
        }

<span class="fc" id="L703">        final ByteArrayOutputStream baos = new ByteArrayOutputStream();</span>
<span class="fc" id="L704">        try (DataOutputViewStreamWrapper out = new DataOutputViewStreamWrapper(baos)) {</span>
<span class="fc" id="L705">            original.write(out);</span>
        }

<span class="fc" id="L708">        final ByteArrayInputStream bais = new ByteArrayInputStream(baos.toByteArray());</span>
<span class="fc" id="L709">        try (DataInputViewStreamWrapper in = new DataInputViewStreamWrapper(bais)) {</span>

            @SuppressWarnings(&quot;unchecked&quot;)
<span class="fc" id="L712">            T copy = (T) instantiate(original.getClass());</span>
<span class="fc" id="L713">            copy.read(in);</span>
<span class="fc" id="L714">            return copy;</span>
        }
    }

    /**
     * Loads a class by name from the given input stream and reflectively instantiates it.
     *
     * &lt;p&gt;This method will use {@link DataInputView#readUTF()} to read the class name, and then
     * attempt to load the class from the given ClassLoader.
     *
     * @param in The stream to read the class name from.
     * @param cl The class loader to resolve the class.
     * @throws IOException Thrown, if the class name could not be read, the class could not be
     *     found.
     */
    public static &lt;T&gt; Class&lt;T&gt; resolveClassByName(DataInputView in, ClassLoader cl)
            throws IOException {
<span class="fc" id="L731">        return resolveClassByName(in, cl, Object.class);</span>
    }

    /**
     * Loads a class by name from the given input stream and reflectively instantiates it.
     *
     * &lt;p&gt;This method will use {@link DataInputView#readUTF()} to read the class name, and then
     * attempt to load the class from the given ClassLoader.
     *
     * &lt;p&gt;The resolved class is checked to be equal to or a subtype of the given supertype class.
     *
     * @param in The stream to read the class name from.
     * @param cl The class loader to resolve the class.
     * @param supertype A class that the resolved class must extend.
     * @throws IOException Thrown, if the class name could not be read, the class could not be
     *     found, or the class is not a subtype of the given supertype class.
     */
    public static &lt;T&gt; Class&lt;T&gt; resolveClassByName(
            DataInputView in, ClassLoader cl, Class&lt;? super T&gt; supertype) throws IOException {

<span class="fc" id="L751">        final String className = in.readUTF();</span>
        final Class&lt;?&gt; rawClazz;
        try {
<span class="fc" id="L754">            rawClazz = Class.forName(className, false, cl);</span>
<span class="fc" id="L755">        } catch (ClassNotFoundException e) {</span>
<span class="fc" id="L756">            throw new IOException(&quot;Could not find class '&quot; + className + &quot;' in classpath.&quot;, e);</span>
<span class="fc" id="L757">        }</span>

<span class="pc bpc" id="L759" title="1 of 2 branches missed.">        if (!supertype.isAssignableFrom(rawClazz)) {</span>
<span class="nc" id="L760">            throw new IOException(</span>
<span class="nc" id="L761">                    &quot;The class &quot; + className + &quot; is not a subclass of &quot; + supertype.getName());</span>
        }

        @SuppressWarnings(&quot;unchecked&quot;)
<span class="fc" id="L765">        Class&lt;T&gt; clazz = (Class&lt;T&gt;) rawClazz;</span>
<span class="fc" id="L766">        return clazz;</span>
    }

    // --------------------------------------------------------------------------------------------

    /** Private constructor to prevent instantiation. */
<span class="nc" id="L772">    private InstantiationUtil() {</span>
<span class="nc" id="L773">        throw new RuntimeException();</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.7.202105040129</span></div></body></html>