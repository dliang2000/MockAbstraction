<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>ValueSerializer.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Flink : Core</a> &gt; <a href="index.source.html" class="el_package">org.apache.flink.api.java.typeutils.runtime</a> &gt; <span class="el_source">ValueSerializer.java</span></div><h1>ValueSerializer.java</h1><pre class="source lang-java linenums">/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * &quot;License&quot;); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.apache.flink.api.java.typeutils.runtime;

import org.apache.flink.annotation.Internal;
import org.apache.flink.api.common.typeutils.GenericTypeSerializerSnapshot;
import org.apache.flink.api.common.typeutils.TypeSerializer;
import org.apache.flink.api.common.typeutils.TypeSerializerSchemaCompatibility;
import org.apache.flink.api.common.typeutils.TypeSerializerSnapshot;
import org.apache.flink.core.memory.DataInputView;
import org.apache.flink.core.memory.DataOutputView;
import org.apache.flink.types.Value;
import org.apache.flink.util.InstantiationUtil;

import com.esotericsoftware.kryo.Kryo;
import org.objenesis.strategy.StdInstantiatorStrategy;

import java.io.IOException;
import java.io.ObjectInputStream;
import java.util.LinkedHashMap;

import static org.apache.flink.util.Preconditions.checkNotNull;

/**
 * Serializer for {@link Value} types. Uses the value's serialization methods, and uses Kryo for
 * deep object copies.
 *
 * @param &lt;T&gt; The type serialized.
 */
@Internal
public final class ValueSerializer&lt;T extends Value&gt; extends TypeSerializer&lt;T&gt; {

    private static final long serialVersionUID = 1L;

    private final Class&lt;T&gt; type;

    /**
     * Map of class tag (using classname as tag) to their Kryo registration.
     *
     * &lt;p&gt;This map serves as a preview of the final registration result of the Kryo instance, taking
     * into account registration overwrites.
     *
     * &lt;p&gt;Currently, we only have one single registration for the value type. Nevertheless, we keep
     * this information here for future compatibility.
     */
    private LinkedHashMap&lt;String, KryoRegistration&gt; kryoRegistrations;

    private transient Kryo kryo;

    private transient T copyInstance;

    // --------------------------------------------------------------------------------------------

<span class="fc" id="L70">    public ValueSerializer(Class&lt;T&gt; type) {</span>
<span class="fc" id="L71">        this.type = checkNotNull(type);</span>
<span class="fc" id="L72">        this.kryoRegistrations = asKryoRegistrations(type);</span>
<span class="fc" id="L73">    }</span>

    // --------------------------------------------------------------------------------------------

    @Override
    public boolean isImmutableType() {
<span class="nc" id="L79">        return false;</span>
    }

    @Override
    public ValueSerializer&lt;T&gt; duplicate() {
<span class="fc" id="L84">        return new ValueSerializer&lt;T&gt;(type);</span>
    }

    @Override
    public T createInstance() {
<span class="fc" id="L89">        return InstantiationUtil.instantiate(this.type);</span>
    }

    @Override
    public T copy(T from) {
<span class="fc" id="L94">        checkKryoInitialized();</span>

<span class="fc" id="L96">        return KryoUtils.copy(from, kryo, this);</span>
    }

    @Override
    public T copy(T from, T reuse) {
<span class="fc" id="L101">        checkKryoInitialized();</span>

<span class="fc" id="L103">        return KryoUtils.copy(from, reuse, kryo, this);</span>
    }

    @Override
    public int getLength() {
<span class="fc" id="L108">        return -1;</span>
    }

    @Override
    public void serialize(T value, DataOutputView target) throws IOException {
<span class="fc" id="L113">        value.write(target);</span>
<span class="fc" id="L114">    }</span>

    @Override
    public T deserialize(DataInputView source) throws IOException {
<span class="fc" id="L118">        return deserialize(createInstance(), source);</span>
    }

    @Override
    public T deserialize(T reuse, DataInputView source) throws IOException {
<span class="fc" id="L123">        reuse.read(source);</span>
<span class="fc" id="L124">        return reuse;</span>
    }

    @Override
    public void copy(DataInputView source, DataOutputView target) throws IOException {
<span class="fc bfc" id="L129" title="All 2 branches covered.">        if (this.copyInstance == null) {</span>
<span class="fc" id="L130">            this.copyInstance = InstantiationUtil.instantiate(type);</span>
        }

<span class="fc" id="L133">        this.copyInstance.read(source);</span>
<span class="fc" id="L134">        this.copyInstance.write(target);</span>
<span class="fc" id="L135">    }</span>

    private void checkKryoInitialized() {
<span class="fc bfc" id="L138" title="All 2 branches covered.">        if (this.kryo == null) {</span>
<span class="fc" id="L139">            this.kryo = new Kryo();</span>

<span class="fc" id="L141">            Kryo.DefaultInstantiatorStrategy instantiatorStrategy =</span>
                    new Kryo.DefaultInstantiatorStrategy();
<span class="fc" id="L143">            instantiatorStrategy.setFallbackInstantiatorStrategy(new StdInstantiatorStrategy());</span>
<span class="fc" id="L144">            kryo.setInstantiatorStrategy(instantiatorStrategy);</span>

<span class="fc" id="L146">            this.kryo.setAsmEnabled(true);</span>

<span class="fc" id="L148">            KryoUtils.applyRegistrations(this.kryo, kryoRegistrations.values());</span>
        }
<span class="fc" id="L150">    }</span>

    // --------------------------------------------------------------------------------------------

    @Override
    public int hashCode() {
<span class="nc" id="L156">        return this.type.hashCode();</span>
    }

    @Override
    public boolean equals(Object obj) {
<span class="pc bpc" id="L161" title="1 of 2 branches missed.">        if (obj instanceof ValueSerializer) {</span>
<span class="fc" id="L162">            ValueSerializer&lt;?&gt; other = (ValueSerializer&lt;?&gt;) obj;</span>

<span class="pc bpc" id="L164" title="1 of 2 branches missed.">            return type == other.type;</span>
        } else {
<span class="nc" id="L166">            return false;</span>
        }
    }

    private Class&lt;T&gt; getValueType() {
<span class="nc" id="L171">        return type;</span>
    }

    // --------------------------------------------------------------------------------------------
    // Serializer configuration snapshotting &amp; compatibility
    // --------------------------------------------------------------------------------------------

    @Override
    public TypeSerializerSnapshot&lt;T&gt; snapshotConfiguration() {
<span class="fc" id="L180">        return new ValueSerializerSnapshot&lt;&gt;(type);</span>
    }

    @Deprecated
    public static class ValueSerializerConfigSnapshot&lt;T extends Value&gt;
            extends KryoRegistrationSerializerConfigSnapshot&lt;T&gt; {

        public static final long serialVersionUID = 2277251654485371327L;

        private static final int VERSION = 1;

        /** This empty nullary constructor is required for deserializing the configuration. */
<span class="nc" id="L192">        public ValueSerializerConfigSnapshot() {}</span>

        public ValueSerializerConfigSnapshot(Class&lt;T&gt; valueTypeClass) {
<span class="nc" id="L195">            super(valueTypeClass, asKryoRegistrations(valueTypeClass));</span>
<span class="nc" id="L196">        }</span>

        @Override
        public int getVersion() {
<span class="nc" id="L200">            return VERSION;</span>
        }

        @Override
        public TypeSerializerSchemaCompatibility&lt;T&gt; resolveSchemaCompatibility(
                TypeSerializer&lt;T&gt; newSerializer) {
<span class="nc" id="L206">            return new ValueSerializerSnapshot&lt;&gt;(getTypeClass())</span>
<span class="nc" id="L207">                    .resolveSchemaCompatibility(newSerializer);</span>
        }
    }

    /** {@link ValueSerializer} snapshot class. */
    public static final class ValueSerializerSnapshot&lt;T extends Value&gt;
            extends GenericTypeSerializerSnapshot&lt;T, ValueSerializer&gt; {

        @SuppressWarnings(&quot;unused&quot;)
<span class="fc" id="L216">        public ValueSerializerSnapshot() {}</span>

        ValueSerializerSnapshot(Class&lt;T&gt; typeClass) {
<span class="fc" id="L219">            super(typeClass);</span>
<span class="fc" id="L220">        }</span>

        @Override
        protected TypeSerializer&lt;T&gt; createSerializer(Class&lt;T&gt; typeClass) {
<span class="fc" id="L224">            return new ValueSerializer&lt;&gt;(typeClass);</span>
        }

        @SuppressWarnings(&quot;unchecked&quot;)
        @Override
        protected Class&lt;T&gt; getTypeClass(ValueSerializer serializer) {
<span class="fc" id="L230">            return serializer.type;</span>
        }

        @Override
        protected Class&lt;?&gt; serializerClass() {
<span class="fc" id="L235">            return ValueSerializer.class;</span>
        }
    }

    // --------------------------------------------------------------------------------------------

    private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {
<span class="fc" id="L242">        in.defaultReadObject();</span>

        // kryoRegistrations may be null if this value serializer is deserialized from an old
        // version
<span class="pc bpc" id="L246" title="1 of 2 branches missed.">        if (kryoRegistrations == null) {</span>
<span class="nc" id="L247">            this.kryoRegistrations = asKryoRegistrations(type);</span>
        }
<span class="fc" id="L249">    }</span>

    private static LinkedHashMap&lt;String, KryoRegistration&gt; asKryoRegistrations(Class&lt;?&gt; type) {
<span class="fc" id="L252">        checkNotNull(type);</span>

<span class="fc" id="L254">        LinkedHashMap&lt;String, KryoRegistration&gt; registration = new LinkedHashMap&lt;&gt;(1);</span>
<span class="fc" id="L255">        registration.put(type.getClass().getName(), new KryoRegistration(type));</span>

<span class="fc" id="L257">        return registration;</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.7.202105040129</span></div></body></html>