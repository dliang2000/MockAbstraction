<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>Types.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Flink : Core</a> &gt; <a href="index.source.html" class="el_package">org.apache.flink.api.common.typeinfo</a> &gt; <span class="el_source">Types.java</span></div><h1>Types.java</h1><pre class="source lang-java linenums">/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * &quot;License&quot;); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.apache.flink.api.common.typeinfo;

import org.apache.flink.annotation.PublicEvolving;
import org.apache.flink.api.common.functions.InvalidTypesException;
import org.apache.flink.api.java.tuple.Tuple;
import org.apache.flink.api.java.typeutils.EitherTypeInfo;
import org.apache.flink.api.java.typeutils.EnumTypeInfo;
import org.apache.flink.api.java.typeutils.GenericTypeInfo;
import org.apache.flink.api.java.typeutils.ListTypeInfo;
import org.apache.flink.api.java.typeutils.MapTypeInfo;
import org.apache.flink.api.java.typeutils.ObjectArrayTypeInfo;
import org.apache.flink.api.java.typeutils.PojoField;
import org.apache.flink.api.java.typeutils.PojoTypeInfo;
import org.apache.flink.api.java.typeutils.RowTypeInfo;
import org.apache.flink.api.java.typeutils.TupleTypeInfo;
import org.apache.flink.api.java.typeutils.TypeExtractor;
import org.apache.flink.api.java.typeutils.ValueTypeInfo;
import org.apache.flink.types.Either;
import org.apache.flink.types.Row;
import org.apache.flink.types.Value;

import java.lang.reflect.Field;
import java.math.BigDecimal;
import java.math.BigInteger;
import java.sql.Date;
import java.sql.Time;
import java.sql.Timestamp;
import java.time.Instant;
import java.time.LocalDate;
import java.time.LocalDateTime;
import java.time.LocalTime;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

/**
 * This class gives access to the type information of the most common types for which Flink has
 * built-in serializers and comparators.
 *
 * &lt;p&gt;In many cases, Flink tries to analyze generic signatures of functions to determine return
 * types automatically. This class is intended for cases where type information has to be supplied
 * manually or cases where automatic type inference results in an inefficient type.
 *
 * &lt;p&gt;Please note that the Scala API and Table API have dedicated Types classes. (See &lt;code&gt;
 * org.apache.flink.api.scala.Types&lt;/code&gt; and &lt;code&gt;org.apache.flink.table.api.Types&lt;/code&gt;)
 *
 * &lt;p&gt;A more convenient alternative might be a {@link TypeHint}.
 *
 * @see TypeInformation#of(Class) specify type information based on a class that will be analyzed
 * @see TypeInformation#of(TypeHint) specify type information based on a {@link TypeHint}
 */
@PublicEvolving
<span class="nc" id="L72">public class Types {</span>

    /** Returns type information for {@link java.lang.Void}. Does not support a null value. */
<span class="fc" id="L75">    public static final TypeInformation&lt;Void&gt; VOID = BasicTypeInfo.VOID_TYPE_INFO;</span>

    /** Returns type information for {@link java.lang.String}. Supports a null value. */
<span class="fc" id="L78">    public static final TypeInformation&lt;String&gt; STRING = BasicTypeInfo.STRING_TYPE_INFO;</span>

    /**
     * Returns type information for both a primitive &lt;code&gt;byte&lt;/code&gt; and {@link java.lang.Byte}.
     * Does not support a null value.
     */
<span class="fc" id="L84">    public static final TypeInformation&lt;Byte&gt; BYTE = BasicTypeInfo.BYTE_TYPE_INFO;</span>

    /**
     * Returns type information for both a primitive &lt;code&gt;boolean&lt;/code&gt; and {@link
     * java.lang.Boolean}. Does not support a null value.
     */
<span class="fc" id="L90">    public static final TypeInformation&lt;Boolean&gt; BOOLEAN = BasicTypeInfo.BOOLEAN_TYPE_INFO;</span>

    /**
     * Returns type information for both a primitive &lt;code&gt;short&lt;/code&gt; and {@link java.lang.Short}.
     * Does not support a null value.
     */
<span class="fc" id="L96">    public static final TypeInformation&lt;Short&gt; SHORT = BasicTypeInfo.SHORT_TYPE_INFO;</span>

    /**
     * Returns type information for both a primitive &lt;code&gt;int&lt;/code&gt; and {@link java.lang.Integer}.
     * Does not support a null value.
     */
<span class="fc" id="L102">    public static final TypeInformation&lt;Integer&gt; INT = BasicTypeInfo.INT_TYPE_INFO;</span>

    /**
     * Returns type information for both a primitive &lt;code&gt;long&lt;/code&gt; and {@link java.lang.Long}.
     * Does not support a null value.
     */
<span class="fc" id="L108">    public static final TypeInformation&lt;Long&gt; LONG = BasicTypeInfo.LONG_TYPE_INFO;</span>

    /**
     * Returns type information for both a primitive &lt;code&gt;float&lt;/code&gt; and {@link java.lang.Float}.
     * Does not support a null value.
     */
<span class="fc" id="L114">    public static final TypeInformation&lt;Float&gt; FLOAT = BasicTypeInfo.FLOAT_TYPE_INFO;</span>

    /**
     * Returns type information for both a primitive &lt;code&gt;double&lt;/code&gt; and {@link
     * java.lang.Double}. Does not support a null value.
     */
<span class="fc" id="L120">    public static final TypeInformation&lt;Double&gt; DOUBLE = BasicTypeInfo.DOUBLE_TYPE_INFO;</span>

    /**
     * Returns type information for both a primitive &lt;code&gt;char&lt;/code&gt; and {@link
     * java.lang.Character}. Does not support a null value.
     */
<span class="fc" id="L126">    public static final TypeInformation&lt;Character&gt; CHAR = BasicTypeInfo.CHAR_TYPE_INFO;</span>

    /** Returns type information for {@link java.math.BigDecimal}. Supports a null value. */
<span class="fc" id="L129">    public static final TypeInformation&lt;BigDecimal&gt; BIG_DEC = BasicTypeInfo.BIG_DEC_TYPE_INFO;</span>

    /** Returns type information for {@link java.math.BigInteger}. Supports a null value. */
<span class="fc" id="L132">    public static final TypeInformation&lt;BigInteger&gt; BIG_INT = BasicTypeInfo.BIG_INT_TYPE_INFO;</span>

    /** Returns type information for {@link java.sql.Date}. Supports a null value. */
<span class="fc" id="L135">    public static final TypeInformation&lt;Date&gt; SQL_DATE = SqlTimeTypeInfo.DATE;</span>

    /** Returns type information for {@link java.sql.Time}. Supports a null value. */
<span class="fc" id="L138">    public static final TypeInformation&lt;Time&gt; SQL_TIME = SqlTimeTypeInfo.TIME;</span>

    /** Returns type information for {@link java.sql.Timestamp}. Supports a null value. */
<span class="fc" id="L141">    public static final TypeInformation&lt;Timestamp&gt; SQL_TIMESTAMP = SqlTimeTypeInfo.TIMESTAMP;</span>

    /** Returns type information for {@link java.time.LocalDate}. Supports a null value. */
<span class="fc" id="L144">    public static final TypeInformation&lt;LocalDate&gt; LOCAL_DATE = LocalTimeTypeInfo.LOCAL_DATE;</span>

    /** Returns type information for {@link java.time.LocalTime}. Supports a null value. */
<span class="fc" id="L147">    public static final TypeInformation&lt;LocalTime&gt; LOCAL_TIME = LocalTimeTypeInfo.LOCAL_TIME;</span>

    /** Returns type information for {@link java.time.LocalDateTime}. Supports a null value. */
<span class="fc" id="L150">    public static final TypeInformation&lt;LocalDateTime&gt; LOCAL_DATE_TIME =</span>
            LocalTimeTypeInfo.LOCAL_DATE_TIME;

    /** Returns type information for {@link java.time.Instant}. Supports a null value. */
<span class="fc" id="L154">    public static final TypeInformation&lt;Instant&gt; INSTANT = BasicTypeInfo.INSTANT_TYPE_INFO;</span>

    // CHECKSTYLE.OFF: MethodName

    /**
     * Returns type information for {@link org.apache.flink.types.Row} with fields of the given
     * types. A row itself must not be null.
     *
     * &lt;p&gt;A row is a fixed-length, null-aware composite type for storing multiple values in a
     * deterministic field order. Every field can be null regardless of the field's type. The type
     * of row fields cannot be automatically inferred; therefore, it is required to provide type
     * information whenever a row is produced.
     *
     * &lt;p&gt;The schema of rows can have up to &lt;code&gt;Integer.MAX_VALUE&lt;/code&gt; fields, however, all row
     * instances must strictly adhere to the schema defined by the type info.
     *
     * &lt;p&gt;This method generates type information with fields of the given types; the fields have the
     * default names (f0, f1, f2 ..).
     *
     * @param types The types of the row fields, e.g., Types.STRING, Types.INT
     */
    public static TypeInformation&lt;Row&gt; ROW(TypeInformation&lt;?&gt;... types) {
<span class="nc" id="L176">        return new RowTypeInfo(types);</span>
    }

    /**
     * Returns type information for {@link org.apache.flink.types.Row} with fields of the given
     * types and with given names. A row must not be null.
     *
     * &lt;p&gt;A row is a fixed-length, null-aware composite type for storing multiple values in a
     * deterministic field order. Every field can be null independent of the field's type. The type
     * of row fields cannot be automatically inferred; therefore, it is required to provide type
     * information whenever a row is used.
     *
     * &lt;p&gt;The schema of rows can have up to &lt;code&gt;Integer.MAX_VALUE&lt;/code&gt; fields, however, all row
     * instances must strictly adhere to the schema defined by the type info.
     *
     * &lt;p&gt;Example use: {@code ROW_NAMED(new String[]{&quot;name&quot;, &quot;number&quot;}, Types.STRING, Types.INT)}.
     *
     * @param fieldNames array of field names
     * @param types array of field types
     */
    public static TypeInformation&lt;Row&gt; ROW_NAMED(String[] fieldNames, TypeInformation&lt;?&gt;... types) {
<span class="fc" id="L197">        return new RowTypeInfo(types, fieldNames);</span>
    }

    /**
     * Returns type information for subclasses of Flink's {@link
     * org.apache.flink.api.java.tuple.Tuple} (namely {@link org.apache.flink.api.java.tuple.Tuple0}
     * till {@link org.apache.flink.api.java.tuple.Tuple25}) with fields of the given types. A tuple
     * must not be null.
     *
     * &lt;p&gt;A tuple is a fixed-length composite type for storing multiple values in a deterministic
     * field order. Fields of a tuple are typed. Tuples are the most efficient composite type; a
     * tuple does not support null-valued fields unless the type of the field supports nullability.
     *
     * @param types The types of the tuple fields, e.g., Types.STRING, Types.INT
     */
    public static &lt;T extends Tuple&gt; TypeInformation&lt;T&gt; TUPLE(TypeInformation&lt;?&gt;... types) {
<span class="nc" id="L213">        return new TupleTypeInfo&lt;&gt;(types);</span>
    }

    /**
     * Returns type information for typed subclasses of Flink's {@link
     * org.apache.flink.api.java.tuple.Tuple}. Typed subclassed are classes that extend {@link
     * org.apache.flink.api.java.tuple.Tuple0} till {@link org.apache.flink.api.java.tuple.Tuple25}
     * to provide types for all fields and might add additional getters and setters for better
     * readability. Additional member fields must not be added. A tuple must not be null.
     *
     * &lt;p&gt;A tuple is a fixed-length composite type for storing multiple values in a deterministic
     * field order. Fields of a tuple are typed. Tuples are the most efficient composite type; a
     * tuple does not support null-valued fields unless the type of the field supports nullability.
     *
     * &lt;p&gt;The generic types for all fields of the tuple can be defined in a hierarchy of subclasses.
     *
     * &lt;p&gt;If Flink's type analyzer is unable to extract a tuple type information with type
     * information for all fields, an {@link
     * org.apache.flink.api.common.functions.InvalidTypesException} is thrown.
     *
     * &lt;p&gt;Example use:
     *
     * &lt;pre&gt;{@code
     *   class MyTuple extends Tuple2&lt;Integer, String&gt; {
     *
     *     public int getId() { return f0; }
     *
     *     public String getName() { return f1; }
     *   }
     * }
     *
     * Types.TUPLE(MyTuple.class)
     * &lt;/pre&gt;
     *
     * @param tupleSubclass A subclass of {@link org.apache.flink.api.java.tuple.Tuple0} till {@link
     *     org.apache.flink.api.java.tuple.Tuple25} that defines all field types and does not add
     *     any additional fields
     */
    public static &lt;T extends Tuple&gt; TypeInformation&lt;T&gt; TUPLE(Class&lt;T&gt; tupleSubclass) {
<span class="nc" id="L252">        final TypeInformation&lt;T&gt; ti = TypeExtractor.createTypeInfo(tupleSubclass);</span>
<span class="nc bnc" id="L253" title="All 2 branches missed.">        if (ti instanceof TupleTypeInfo) {</span>
<span class="nc" id="L254">            return ti;</span>
        }
<span class="nc" id="L256">        throw new InvalidTypesException(&quot;Tuple type expected but was: &quot; + ti);</span>
    }

    /**
     * Returns type information for a POJO (Plain Old Java Object).
     *
     * &lt;p&gt;A POJO class is public and standalone (no non-static inner class). It has a public
     * no-argument constructor. All non-static, non-transient fields in the class (and all
     * superclasses) are either public (and non-final) or have a public getter and a setter method
     * that follows the Java beans naming conventions for getters and setters.
     *
     * &lt;p&gt;A POJO is a fixed-length and null-aware composite type. Every field can be null
     * independent of the field's type.
     *
     * &lt;p&gt;The generic types for all fields of the POJO can be defined in a hierarchy of subclasses.
     *
     * &lt;p&gt;If Flink's type analyzer is unable to extract a valid POJO type information with type
     * information for all fields, an {@link
     * org.apache.flink.api.common.functions.InvalidTypesException} is thrown. Alternatively, you
     * can use {@link Types#POJO(Class, Map)} to specify all fields manually.
     *
     * @param pojoClass POJO class to be analyzed by Flink
     */
    public static &lt;T&gt; TypeInformation&lt;T&gt; POJO(Class&lt;T&gt; pojoClass) {
<span class="nc" id="L280">        final TypeInformation&lt;T&gt; ti = TypeExtractor.createTypeInfo(pojoClass);</span>
<span class="nc bnc" id="L281" title="All 2 branches missed.">        if (ti instanceof PojoTypeInfo) {</span>
<span class="nc" id="L282">            return ti;</span>
        }
<span class="nc" id="L284">        throw new InvalidTypesException(&quot;POJO type expected but was: &quot; + ti);</span>
    }

    /**
     * Returns type information for a POJO (Plain Old Java Object) and allows to specify all fields
     * manually.
     *
     * &lt;p&gt;A POJO class is public and standalone (no non-static inner class). It has a public
     * no-argument constructor. All non-static, non-transient fields in the class (and all
     * superclasses) are either public (and non-final) or have a public getter and a setter method
     * that follows the Java beans naming conventions for getters and setters.
     *
     * &lt;p&gt;A POJO is a fixed-length, null-aware composite type with non-deterministic field order.
     * Every field can be null independent of the field's type.
     *
     * &lt;p&gt;The generic types for all fields of the POJO can be defined in a hierarchy of subclasses.
     *
     * &lt;p&gt;If Flink's type analyzer is unable to extract a POJO field, an {@link
     * org.apache.flink.api.common.functions.InvalidTypesException} is thrown.
     *
     * &lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt; In most cases the type information of fields can be determined
     * automatically, we recommend to use {@link Types#POJO(Class)}.
     *
     * @param pojoClass POJO class
     * @param fields map of fields that map a name to type information. The map key is the name of
     *     the field and the value is its type.
     */
    public static &lt;T&gt; TypeInformation&lt;T&gt; POJO(
            Class&lt;T&gt; pojoClass, Map&lt;String, TypeInformation&lt;?&gt;&gt; fields) {
<span class="fc" id="L313">        final List&lt;PojoField&gt; pojoFields = new ArrayList&lt;&gt;(fields.size());</span>
<span class="fc bfc" id="L314" title="All 2 branches covered.">        for (Map.Entry&lt;String, TypeInformation&lt;?&gt;&gt; field : fields.entrySet()) {</span>
<span class="fc" id="L315">            final Field f = TypeExtractor.getDeclaredField(pojoClass, field.getKey());</span>
<span class="pc bpc" id="L316" title="1 of 2 branches missed.">            if (f == null) {</span>
<span class="nc" id="L317">                throw new InvalidTypesException(</span>
<span class="nc" id="L318">                        &quot;Field '&quot; + field.getKey() + &quot;'could not be accessed.&quot;);</span>
            }
<span class="fc" id="L320">            pojoFields.add(new PojoField(f, field.getValue()));</span>
<span class="fc" id="L321">        }</span>

<span class="fc" id="L323">        return new PojoTypeInfo&lt;&gt;(pojoClass, pojoFields);</span>
    }

    /**
     * Returns generic type information for any Java object. The serialization logic will use the
     * general purpose serializer Kryo.
     *
     * &lt;p&gt;Generic types are black-boxes for Flink, but allow any object and null values in fields.
     *
     * &lt;p&gt;By default, serialization of this type is not very efficient. Please read the
     * documentation about how to improve efficiency (namely by pre-registering classes).
     *
     * @param genericClass any Java class
     */
    public static &lt;T&gt; TypeInformation&lt;T&gt; GENERIC(Class&lt;T&gt; genericClass) {
<span class="nc" id="L338">        return new GenericTypeInfo&lt;&gt;(genericClass);</span>
    }

    /**
     * Returns type information for Java arrays of primitive type (such as &lt;code&gt;byte[]&lt;/code&gt;). The
     * array must not be null.
     *
     * @param elementType element type of the array (e.g. Types.BOOLEAN, Types.INT, Types.DOUBLE)
     */
    public static TypeInformation&lt;?&gt; PRIMITIVE_ARRAY(TypeInformation&lt;?&gt; elementType) {
<span class="nc bnc" id="L348" title="All 2 branches missed.">        if (elementType == BOOLEAN) {</span>
<span class="nc" id="L349">            return PrimitiveArrayTypeInfo.BOOLEAN_PRIMITIVE_ARRAY_TYPE_INFO;</span>
<span class="nc bnc" id="L350" title="All 2 branches missed.">        } else if (elementType == BYTE) {</span>
<span class="nc" id="L351">            return PrimitiveArrayTypeInfo.BYTE_PRIMITIVE_ARRAY_TYPE_INFO;</span>
<span class="nc bnc" id="L352" title="All 2 branches missed.">        } else if (elementType == SHORT) {</span>
<span class="nc" id="L353">            return PrimitiveArrayTypeInfo.SHORT_PRIMITIVE_ARRAY_TYPE_INFO;</span>
<span class="nc bnc" id="L354" title="All 2 branches missed.">        } else if (elementType == INT) {</span>
<span class="nc" id="L355">            return PrimitiveArrayTypeInfo.INT_PRIMITIVE_ARRAY_TYPE_INFO;</span>
<span class="nc bnc" id="L356" title="All 2 branches missed.">        } else if (elementType == LONG) {</span>
<span class="nc" id="L357">            return PrimitiveArrayTypeInfo.LONG_PRIMITIVE_ARRAY_TYPE_INFO;</span>
<span class="nc bnc" id="L358" title="All 2 branches missed.">        } else if (elementType == FLOAT) {</span>
<span class="nc" id="L359">            return PrimitiveArrayTypeInfo.FLOAT_PRIMITIVE_ARRAY_TYPE_INFO;</span>
<span class="nc bnc" id="L360" title="All 2 branches missed.">        } else if (elementType == DOUBLE) {</span>
<span class="nc" id="L361">            return PrimitiveArrayTypeInfo.DOUBLE_PRIMITIVE_ARRAY_TYPE_INFO;</span>
<span class="nc bnc" id="L362" title="All 2 branches missed.">        } else if (elementType == CHAR) {</span>
<span class="nc" id="L363">            return PrimitiveArrayTypeInfo.CHAR_PRIMITIVE_ARRAY_TYPE_INFO;</span>
        }
<span class="nc" id="L365">        throw new IllegalArgumentException(&quot;Invalid element type for a primitive array.&quot;);</span>
    }

    /**
     * Returns type information for Java arrays of object types (such as &lt;code&gt;String[]&lt;/code&gt;,
     * &lt;code&gt;Integer[]&lt;/code&gt;). The array itself must not be null. Null values for elements are
     * supported.
     *
     * @param elementType element type of the array
     */
    @SuppressWarnings(&quot;unchecked&quot;)
    public static &lt;E&gt; TypeInformation&lt;E[]&gt; OBJECT_ARRAY(TypeInformation&lt;E&gt; elementType) {
<span class="nc bnc" id="L377" title="All 2 branches missed.">        if (elementType == Types.STRING) {</span>
<span class="nc" id="L378">            return (TypeInformation) BasicArrayTypeInfo.STRING_ARRAY_TYPE_INFO;</span>
        }
<span class="nc" id="L380">        return ObjectArrayTypeInfo.getInfoFor(elementType);</span>
    }

    /**
     * Returns type information for Flink value types (classes that implement {@link
     * org.apache.flink.types.Value}). Built-in value types do not support null values (except for
     * {@link org.apache.flink.types.StringValue}).
     *
     * &lt;p&gt;Value types describe their serialization and deserialization manually. Instead of going
     * through a general purpose serialization framework. A value type is reasonable when general
     * purpose serialization would be highly inefficient. The wrapped value can be altered, allowing
     * programmers to reuse objects and take pressure off the garbage collector.
     *
     * &lt;p&gt;Flink provides built-in value types for all Java primitive types (such as {@link
     * org.apache.flink.types.BooleanValue}, {@link org.apache.flink.types.IntValue}) as well as
     * {@link org.apache.flink.types.StringValue}, {@link org.apache.flink.types.NullValue}, {@link
     * org.apache.flink.types.ListValue}, and {@link org.apache.flink.types.MapValue}.
     *
     * @param valueType class that implements {@link org.apache.flink.types.Value}
     */
    public static &lt;V extends Value&gt; TypeInformation&lt;V&gt; VALUE(Class&lt;V&gt; valueType) {
<span class="nc" id="L401">        return new ValueTypeInfo&lt;&gt;(valueType);</span>
    }

    /**
     * Returns type information for a Java {@link java.util.Map}. A map must not be null. Null
     * values in keys are not supported. An entry's value can be null.
     *
     * &lt;p&gt;By default, maps are untyped and treated as a generic type in Flink; therefore, it is
     * useful to pass type information whenever a map is used.
     *
     * &lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt; Flink does not preserve the concrete {@link Map} type. It converts
     * a map into {@link HashMap} when copying or deserializing.
     *
     * @param keyType type information for the map's keys
     * @param valueType type information for the map's values
     */
    public static &lt;K, V&gt; TypeInformation&lt;Map&lt;K, V&gt;&gt; MAP(
            TypeInformation&lt;K&gt; keyType, TypeInformation&lt;V&gt; valueType) {
<span class="nc" id="L419">        return new MapTypeInfo&lt;&gt;(keyType, valueType);</span>
    }

    /**
     * Returns type information for a Java {@link java.util.List}. A list must not be null. Null
     * values in elements are not supported.
     *
     * &lt;p&gt;By default, lists are untyped and treated as a generic type in Flink; therefore, it is
     * useful to pass type information whenever a list is used.
     *
     * &lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt; Flink does not preserve the concrete {@link List} type. It converts
     * a list into {@link ArrayList} when copying or deserializing.
     *
     * @param elementType type information for the list's elements
     */
    public static &lt;E&gt; TypeInformation&lt;List&lt;E&gt;&gt; LIST(TypeInformation&lt;E&gt; elementType) {
<span class="nc" id="L435">        return new ListTypeInfo&lt;&gt;(elementType);</span>
    }

    /**
     * Returns type information for Java enumerations. Null values are not supported.
     *
     * @param enumType enumeration class extending {@link java.lang.Enum}
     */
    public static &lt;E extends Enum&lt;E&gt;&gt; TypeInformation&lt;E&gt; ENUM(Class&lt;E&gt; enumType) {
<span class="nc" id="L444">        return new EnumTypeInfo&lt;&gt;(enumType);</span>
    }

    /**
     * Returns type information for Flink's {@link org.apache.flink.types.Either} type. Null values
     * are not supported.
     *
     * &lt;p&gt;Either type can be used for a value of two possible types.
     *
     * &lt;p&gt;Example use: &lt;code&gt;Types.EITHER(Types.VOID, Types.INT)&lt;/code&gt;
     *
     * @param leftType type information of left side / {@link org.apache.flink.types.Either.Left}
     * @param rightType type information of right side / {@link org.apache.flink.types.Either.Right}
     */
    public static &lt;L, R&gt; TypeInformation&lt;Either&lt;L, R&gt;&gt; EITHER(
            TypeInformation&lt;L&gt; leftType, TypeInformation&lt;R&gt; rightType) {
<span class="nc" id="L460">        return new EitherTypeInfo&lt;&gt;(leftType, rightType);</span>
    }

    // CHECKSTYLE.ON: MethodName
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.7.202105040129</span></div></body></html>