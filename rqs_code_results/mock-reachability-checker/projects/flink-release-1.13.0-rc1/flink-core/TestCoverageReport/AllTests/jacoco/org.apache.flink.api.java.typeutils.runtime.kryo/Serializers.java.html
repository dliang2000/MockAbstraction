<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>Serializers.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Flink : Core</a> &gt; <a href="index.source.html" class="el_package">org.apache.flink.api.java.typeutils.runtime.kryo</a> &gt; <span class="el_source">Serializers.java</span></div><h1>Serializers.java</h1><pre class="source lang-java linenums">/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * &quot;License&quot;); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.apache.flink.api.java.typeutils.runtime.kryo;

import org.apache.flink.annotation.Internal;
import org.apache.flink.api.common.ExecutionConfig;
import org.apache.flink.api.common.typeinfo.TypeInformation;
import org.apache.flink.api.common.typeutils.CompositeType;
import org.apache.flink.api.java.typeutils.AvroUtils;
import org.apache.flink.api.java.typeutils.GenericTypeInfo;
import org.apache.flink.api.java.typeutils.ObjectArrayTypeInfo;
import org.apache.flink.api.java.typeutils.TypeExtractionUtils;

import com.esotericsoftware.kryo.Kryo;
import com.esotericsoftware.kryo.Serializer;
import com.esotericsoftware.kryo.io.Input;
import com.esotericsoftware.kryo.io.Output;
import com.esotericsoftware.kryo.serializers.CollectionSerializer;

import java.io.Serializable;
import java.lang.reflect.Field;
import java.lang.reflect.GenericArrayType;
import java.lang.reflect.Modifier;
import java.lang.reflect.ParameterizedType;
import java.lang.reflect.Type;
import java.util.ArrayList;
import java.util.Collection;
import java.util.List;
import java.util.Set;

/**
 * Class containing utilities for the serializers of the Flink Runtime.
 *
 * &lt;p&gt;Most of the serializers are automatically added to the system.
 *
 * &lt;p&gt;Note that users can also implement the {@link com.esotericsoftware.kryo.KryoSerializable}
 * interface to provide custom serialization for their classes. Also, there is a Java Annotation for
 * adding a default serializer (@DefaultSerializer) to classes.
 */
@Internal
<span class="nc" id="L57">public class Serializers {</span>

    public static void recursivelyRegisterType(
            TypeInformation&lt;?&gt; typeInfo, ExecutionConfig config, Set&lt;Class&lt;?&gt;&gt; alreadySeen) {
<span class="pc bpc" id="L61" title="1 of 2 branches missed.">        if (typeInfo instanceof GenericTypeInfo) {</span>
<span class="fc" id="L62">            GenericTypeInfo&lt;?&gt; genericTypeInfo = (GenericTypeInfo&lt;?&gt;) typeInfo;</span>
<span class="fc" id="L63">            Serializers.recursivelyRegisterType(</span>
<span class="fc" id="L64">                    genericTypeInfo.getTypeClass(), config, alreadySeen);</span>
<span class="pc bnc" id="L65" title="All 2 branches missed.">        } else if (typeInfo instanceof CompositeType) {</span>
<span class="nc" id="L66">            List&lt;GenericTypeInfo&lt;?&gt;&gt; genericTypesInComposite = new ArrayList&lt;&gt;();</span>
<span class="nc" id="L67">            getContainedGenericTypes((CompositeType&lt;?&gt;) typeInfo, genericTypesInComposite);</span>
<span class="nc bnc" id="L68" title="All 2 branches missed.">            for (GenericTypeInfo&lt;?&gt; gt : genericTypesInComposite) {</span>
<span class="nc" id="L69">                Serializers.recursivelyRegisterType(gt.getTypeClass(), config, alreadySeen);</span>
<span class="nc" id="L70">            }</span>
<span class="nc bnc" id="L71" title="All 2 branches missed.">        } else if (typeInfo instanceof ObjectArrayTypeInfo) {</span>
<span class="nc" id="L72">            ObjectArrayTypeInfo&lt;?, ?&gt; objectArrayTypeInfo = (ObjectArrayTypeInfo&lt;?, ?&gt;) typeInfo;</span>
<span class="nc" id="L73">            recursivelyRegisterType(objectArrayTypeInfo.getComponentInfo(), config, alreadySeen);</span>
        }
<span class="fc" id="L75">    }</span>

    public static void recursivelyRegisterType(
            Class&lt;?&gt; type, ExecutionConfig config, Set&lt;Class&lt;?&gt;&gt; alreadySeen) {
        // don't register or remember primitives
<span class="pc bpc" id="L80" title="2 of 6 branches missed.">        if (type == null || type.isPrimitive() || type == Object.class) {</span>
<span class="fc" id="L81">            return;</span>
        }

        // prevent infinite recursion for recursive types
<span class="fc bfc" id="L85" title="All 2 branches covered.">        if (!alreadySeen.add(type)) {</span>
<span class="fc" id="L86">            return;</span>
        }

<span class="fc bfc" id="L89" title="All 2 branches covered.">        if (type.isArray()) {</span>
<span class="fc" id="L90">            recursivelyRegisterType(type.getComponentType(), config, alreadySeen);</span>
        } else {
<span class="fc" id="L92">            config.registerKryoType(type);</span>
            // add serializers for Avro type if necessary
<span class="fc" id="L94">            AvroUtils.getAvroUtils().addAvroSerializersIfRequired(config, type);</span>

<span class="fc" id="L96">            Field[] fields = type.getDeclaredFields();</span>
<span class="fc bfc" id="L97" title="All 2 branches covered.">            for (Field field : fields) {</span>
<span class="fc bfc" id="L98" title="All 2 branches covered.">                if (Modifier.isStatic(field.getModifiers())</span>
<span class="fc bfc" id="L99" title="All 2 branches covered.">                        || Modifier.isTransient(field.getModifiers())) {</span>
<span class="fc" id="L100">                    continue;</span>
                }
<span class="fc" id="L102">                Type fieldType = field.getGenericType();</span>
<span class="fc" id="L103">                recursivelyRegisterGenericType(fieldType, config, alreadySeen);</span>
            }
        }
<span class="fc" id="L106">    }</span>

    private static void recursivelyRegisterGenericType(
            Type fieldType, ExecutionConfig config, Set&lt;Class&lt;?&gt;&gt; alreadySeen) {
<span class="fc bfc" id="L110" title="All 2 branches covered.">        if (fieldType instanceof ParameterizedType) {</span>
            // field has generics
<span class="fc" id="L112">            ParameterizedType parameterizedFieldType = (ParameterizedType) fieldType;</span>

<span class="fc bfc" id="L114" title="All 2 branches covered.">            for (Type t : parameterizedFieldType.getActualTypeArguments()) {</span>
<span class="pc bpc" id="L115" title="1 of 2 branches missed.">                if (TypeExtractionUtils.isClassType(t)) {</span>
<span class="fc" id="L116">                    recursivelyRegisterType(</span>
<span class="fc" id="L117">                            TypeExtractionUtils.typeToClass(t), config, alreadySeen);</span>
                }
            }

<span class="fc" id="L121">            recursivelyRegisterGenericType(</span>
<span class="fc" id="L122">                    parameterizedFieldType.getRawType(), config, alreadySeen);</span>
<span class="pc bpc" id="L123" title="1 of 2 branches missed.">        } else if (fieldType instanceof GenericArrayType) {</span>
<span class="nc" id="L124">            GenericArrayType genericArrayType = (GenericArrayType) fieldType;</span>
<span class="nc" id="L125">            recursivelyRegisterGenericType(</span>
<span class="nc" id="L126">                    genericArrayType.getGenericComponentType(), config, alreadySeen);</span>
<span class="pc bpc" id="L127" title="1 of 2 branches missed.">        } else if (fieldType instanceof Class) {</span>
<span class="fc" id="L128">            Class&lt;?&gt; clazz = (Class&lt;?&gt;) fieldType;</span>
<span class="fc" id="L129">            recursivelyRegisterType(clazz, config, alreadySeen);</span>
        }
<span class="fc" id="L131">    }</span>

    /**
     * Returns all GenericTypeInfos contained in a composite type.
     *
     * @param typeInfo {@link CompositeType}
     */
    private static void getContainedGenericTypes(
            CompositeType&lt;?&gt; typeInfo, List&lt;GenericTypeInfo&lt;?&gt;&gt; target) {
<span class="nc bnc" id="L140" title="All 2 branches missed.">        for (int i = 0; i &lt; typeInfo.getArity(); i++) {</span>
<span class="nc" id="L141">            TypeInformation&lt;?&gt; type = typeInfo.getTypeAt(i);</span>
<span class="nc bnc" id="L142" title="All 2 branches missed.">            if (type instanceof CompositeType) {</span>
<span class="nc" id="L143">                getContainedGenericTypes((CompositeType&lt;?&gt;) type, target);</span>
<span class="nc bnc" id="L144" title="All 2 branches missed.">            } else if (type instanceof GenericTypeInfo) {</span>
<span class="nc bnc" id="L145" title="All 2 branches missed.">                if (!target.contains(type)) {</span>
<span class="nc" id="L146">                    target.add((GenericTypeInfo&lt;?&gt;) type);</span>
                }
            }
        }
<span class="nc" id="L150">    }</span>

    /**
     * This is used in case we don't have Avro on the classpath. Flink versions before 1.4 always
     * registered special Serializers for Kryo but starting with Flink 1.4 we don't have Avro on the
     * classpath by default anymore. We still have to retain the same registered Serializers for
     * backwards compatibility of savepoints.
     */
<span class="nc" id="L158">    public static class DummyAvroRegisteredClass {}</span>

    /**
     * This is used in case we don't have Avro on the classpath. Flink versions before 1.4 always
     * registered special Serializers for Kryo but starting with Flink 1.4 we don't have Avro on the
     * classpath by default anymore. We still have to retain the same registered Serializers for
     * backwards compatibility of savepoints.
     */
<span class="fc" id="L166">    public static class DummyAvroKryoSerializerClass&lt;T&gt; extends Serializer&lt;T&gt; {</span>
        @Override
        public void write(Kryo kryo, Output output, Object o) {
<span class="nc" id="L169">            throw new UnsupportedOperationException(&quot;Could not find required Avro dependency.&quot;);</span>
        }

        @Override
        public T read(Kryo kryo, Input input, Class&lt;T&gt; aClass) {
<span class="fc" id="L174">            throw new UnsupportedOperationException(&quot;Could not find required Avro dependency.&quot;);</span>
        }
    }

    // --------------------------------------------------------------------------------------------
    // Custom Serializers
    // --------------------------------------------------------------------------------------------

    /** Special serializer for Java's {@link ArrayList} used for Avro's GenericData.Array. */
    @SuppressWarnings(&quot;rawtypes&quot;)
    public static class SpecificInstanceCollectionSerializerForArrayList
            extends SpecificInstanceCollectionSerializer&lt;ArrayList&gt; {
        private static final long serialVersionUID = 1L;

        public SpecificInstanceCollectionSerializerForArrayList() {
<span class="nc" id="L189">            super(ArrayList.class);</span>
<span class="nc" id="L190">        }</span>
    }

    /**
     * Special serializer for Java collections enforcing certain instance types. Avro is serializing
     * collections with an &quot;GenericData.Array&quot; type. Kryo is not able to handle this type, so we use
     * ArrayLists.
     */
    @SuppressWarnings(&quot;rawtypes&quot;)
    public static class SpecificInstanceCollectionSerializer&lt;T extends Collection&gt;
            extends CollectionSerializer implements Serializable {
        private static final long serialVersionUID = 1L;

        private Class&lt;T&gt; type;

<span class="nc" id="L205">        public SpecificInstanceCollectionSerializer(Class&lt;T&gt; type) {</span>
<span class="nc" id="L206">            this.type = type;</span>
<span class="nc" id="L207">        }</span>

        @Override
        protected Collection create(Kryo kryo, Input input, Class&lt;Collection&gt; type) {
<span class="nc" id="L211">            return kryo.newInstance(this.type);</span>
        }

        @Override
        protected Collection createCopy(Kryo kryo, Collection original) {
<span class="nc" id="L216">            return kryo.newInstance(this.type);</span>
        }
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.7.202105040129</span></div></body></html>