<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>RowSerializer.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Flink : Core</a> &gt; <a href="index.source.html" class="el_package">org.apache.flink.api.java.typeutils.runtime</a> &gt; <span class="el_source">RowSerializer.java</span></div><h1>RowSerializer.java</h1><pre class="source lang-java linenums">/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * &quot;License&quot;); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.apache.flink.api.java.typeutils.runtime;

import org.apache.flink.annotation.Internal;
import org.apache.flink.api.common.typeutils.CompositeTypeSerializerConfigSnapshot;
import org.apache.flink.api.common.typeutils.CompositeTypeSerializerSnapshot;
import org.apache.flink.api.common.typeutils.CompositeTypeSerializerUtil;
import org.apache.flink.api.common.typeutils.TypeSerializer;
import org.apache.flink.api.common.typeutils.TypeSerializerSchemaCompatibility;
import org.apache.flink.api.common.typeutils.TypeSerializerSnapshot;
import org.apache.flink.api.java.typeutils.RowTypeInfo;
import org.apache.flink.core.memory.DataInputView;
import org.apache.flink.core.memory.DataOutputView;
import org.apache.flink.types.Row;
import org.apache.flink.types.RowKind;
import org.apache.flink.types.RowUtils;

import javax.annotation.Nullable;

import java.io.IOException;
import java.io.ObjectInputStream;
import java.util.Arrays;
import java.util.LinkedHashMap;
import java.util.Objects;
import java.util.Set;

import static org.apache.flink.api.java.typeutils.runtime.MaskUtils.readIntoAndCopyMask;
import static org.apache.flink.api.java.typeutils.runtime.MaskUtils.readIntoMask;
import static org.apache.flink.api.java.typeutils.runtime.MaskUtils.writeMask;
import static org.apache.flink.util.Preconditions.checkNotNull;

/**
 * Serializer for {@link Row}.
 *
 * &lt;p&gt;It uses the following serialization format:
 *
 * &lt;pre&gt;
 *     |bitmask|field|field|....
 * &lt;/pre&gt;
 *
 * The bitmask serves as a header that consists of {@link #ROW_KIND_OFFSET} bits for encoding the
 * {@link RowKind} and n bits for whether a field is null. For backwards compatibility, those bits
 * can be ignored if serializer runs in legacy mode:
 *
 * &lt;pre&gt;
 *     bitmask with row kind:  |RK RK F1 F2 ... FN|
 *     bitmask in legacy mode: |F1 F2 ... FN|
 * &lt;/pre&gt;
 *
 * &lt;p&gt;Field names are an optional part of this serializer. They allow to use rows in named-based
 * field mode. However, the support for name-based rows is limited. Usually, name-based mode should
 * not be used in state but only for in-flight data. For now, names are not part of serializer
 * snapshot or equals/hashCode (similar to {@link RowTypeInfo}).
 */
<span class="pc bpc" id="L72" title="1 of 2 branches missed.">@Internal</span>
public final class RowSerializer extends TypeSerializer&lt;Row&gt; {

    public static final int ROW_KIND_OFFSET = 2;

    // legacy, don't touch until we drop support for 1.9 savepoints
    private static final long serialVersionUID = 1L;

    private final boolean legacyModeEnabled;

    private final int legacyOffset;

    private final TypeSerializer&lt;Object&gt;[] fieldSerializers;

    private final int arity;

    private final @Nullable LinkedHashMap&lt;String, Integer&gt; positionByName;

    private transient boolean[] mask;

    private transient Row reuseRowPositionBased;

    public RowSerializer(TypeSerializer&lt;?&gt;[] fieldSerializers) {
<span class="nc" id="L95">        this(fieldSerializers, null, false);</span>
<span class="nc" id="L96">    }</span>

    public RowSerializer(
            TypeSerializer&lt;?&gt;[] fieldSerializers,
            @Nullable LinkedHashMap&lt;String, Integer&gt; positionByName) {
<span class="fc" id="L101">        this(fieldSerializers, positionByName, false);</span>
<span class="fc" id="L102">    }</span>

    @SuppressWarnings(&quot;unchecked&quot;)
    public RowSerializer(
            TypeSerializer&lt;?&gt;[] fieldSerializers,
            @Nullable LinkedHashMap&lt;String, Integer&gt; positionByName,
<span class="fc" id="L108">            boolean legacyModeEnabled) {</span>
<span class="fc" id="L109">        this.legacyModeEnabled = legacyModeEnabled;</span>
<span class="fc bfc" id="L110" title="All 2 branches covered.">        this.legacyOffset = legacyModeEnabled ? 0 : ROW_KIND_OFFSET;</span>
<span class="fc" id="L111">        this.fieldSerializers = (TypeSerializer&lt;Object&gt;[]) checkNotNull(fieldSerializers);</span>
<span class="fc" id="L112">        this.arity = fieldSerializers.length;</span>
<span class="fc" id="L113">        this.positionByName = positionByName;</span>
<span class="fc" id="L114">        this.mask = new boolean[legacyOffset + fieldSerializers.length];</span>
<span class="fc" id="L115">        this.reuseRowPositionBased = new Row(fieldSerializers.length);</span>
<span class="fc" id="L116">    }</span>

    @Override
    public boolean isImmutableType() {
<span class="nc" id="L120">        return false;</span>
    }

    @Override
    public TypeSerializer&lt;Row&gt; duplicate() {
<span class="fc" id="L125">        TypeSerializer&lt;?&gt;[] duplicateFieldSerializers = new TypeSerializer[fieldSerializers.length];</span>
<span class="fc bfc" id="L126" title="All 2 branches covered.">        for (int i = 0; i &lt; fieldSerializers.length; i++) {</span>
<span class="fc" id="L127">            duplicateFieldSerializers[i] = fieldSerializers[i].duplicate();</span>
        }
<span class="fc" id="L129">        return new RowSerializer(duplicateFieldSerializers, positionByName, legacyModeEnabled);</span>
    }

    @Override
    public Row createInstance() {
<span class="fc" id="L134">        return RowUtils.createRowWithNamedPositions(</span>
                RowKind.INSERT, new Object[fieldSerializers.length], positionByName);
    }

    @Override
    public Row copy(Row from) {
<span class="fc" id="L140">        final Set&lt;String&gt; fieldNames = from.getFieldNames(false);</span>
<span class="fc bfc" id="L141" title="All 2 branches covered.">        if (fieldNames == null) {</span>
<span class="fc" id="L142">            return copyPositionBased(from);</span>
        } else {
<span class="fc" id="L144">            return copyNameBased(from, fieldNames);</span>
        }
    }

    private Row copyPositionBased(Row from) {
<span class="fc" id="L149">        final int length = fieldSerializers.length;</span>
<span class="pc bpc" id="L150" title="1 of 2 branches missed.">        if (from.getArity() != length) {</span>
<span class="nc" id="L151">            throw new RuntimeException(</span>
                    &quot;Row arity of from (&quot;
<span class="nc" id="L153">                            + from.getArity()</span>
                            + &quot;) does not match &quot;
                            + &quot;this serializer's field length (&quot;
                            + length
                            + &quot;).&quot;);
        }
<span class="fc" id="L159">        final Object[] fieldByPosition = new Object[length];</span>
<span class="fc bfc" id="L160" title="All 2 branches covered.">        for (int i = 0; i &lt; length; i++) {</span>
<span class="fc" id="L161">            final Object fromField = from.getField(i);</span>
<span class="fc bfc" id="L162" title="All 2 branches covered.">            if (fromField != null) {</span>
<span class="fc" id="L163">                final Object copy = fieldSerializers[i].copy(fromField);</span>
<span class="fc" id="L164">                fieldByPosition[i] = copy;</span>
            }
        }
<span class="fc" id="L167">        return RowUtils.createRowWithNamedPositions(</span>
<span class="fc" id="L168">                from.getKind(), fieldByPosition, positionByName);</span>
    }

    private Row copyNameBased(Row from, Set&lt;String&gt; fieldNames) {
<span class="pc bpc" id="L172" title="1 of 2 branches missed.">        if (positionByName == null) {</span>
<span class="nc" id="L173">            throw new RuntimeException(&quot;Serializer does not support named field positions.&quot;);</span>
        }
<span class="fc" id="L175">        final Row newRow = Row.withNames(from.getKind());</span>
<span class="fc bfc" id="L176" title="All 2 branches covered.">        for (String fieldName : fieldNames) {</span>
<span class="fc" id="L177">            final int targetPos = getPositionByName(fieldName);</span>
<span class="fc" id="L178">            final Object fromField = from.getField(fieldName);</span>
<span class="fc bfc" id="L179" title="All 2 branches covered.">            if (fromField != null) {</span>
<span class="fc" id="L180">                final Object copy = fieldSerializers[targetPos].copy(fromField);</span>
<span class="fc" id="L181">                newRow.setField(fieldName, copy);</span>
<span class="fc" id="L182">            } else {</span>
<span class="fc" id="L183">                newRow.setField(fieldName, null);</span>
            }
<span class="fc" id="L185">        }</span>
<span class="fc" id="L186">        return newRow;</span>
    }

    @Override
    public Row copy(Row from, Row reuse) {
        // cannot reuse, do a non-reuse copy
<span class="pc bpc" id="L192" title="1 of 2 branches missed.">        if (reuse == null) {</span>
<span class="nc" id="L193">            return copy(from);</span>
        }

<span class="fc" id="L196">        final Set&lt;String&gt; fieldNames = from.getFieldNames(false);</span>
<span class="fc bfc" id="L197" title="All 2 branches covered.">        if (fieldNames == null) {</span>
            // reuse uses name-based field mode, do a non-reuse copy
<span class="fc bfc" id="L199" title="All 2 branches covered.">            if (reuse.getFieldNames(false) != null) {</span>
<span class="fc" id="L200">                return copy(from);</span>
            }
<span class="fc" id="L202">            return copyPositionBased(from, reuse);</span>
        } else {
            // reuse uses position-based field mode, do a non-reuse copy
<span class="fc bfc" id="L205" title="All 2 branches covered.">            if (reuse.getFieldNames(false) == null) {</span>
<span class="fc" id="L206">                return copy(from);</span>
            }
<span class="fc" id="L208">            return copyNameBased(from, fieldNames, reuse);</span>
        }
    }

    private Row copyPositionBased(Row from, Row reuse) {
<span class="fc" id="L213">        final int length = fieldSerializers.length;</span>
<span class="pc bpc" id="L214" title="2 of 4 branches missed.">        if (from.getArity() != length || reuse.getArity() != length) {</span>
<span class="nc" id="L215">            throw new RuntimeException(</span>
                    &quot;Row arity of reuse (&quot;
<span class="nc" id="L217">                            + reuse.getArity()</span>
                            + &quot;) or from (&quot;
<span class="nc" id="L219">                            + from.getArity()</span>
                            + &quot;) is &quot;
                            + &quot;incompatible with this serializer's field length (&quot;
                            + length
                            + &quot;).&quot;);
        }
<span class="fc" id="L225">        reuse.setKind(from.getKind());</span>
<span class="fc bfc" id="L226" title="All 2 branches covered.">        for (int i = 0; i &lt; length; i++) {</span>
<span class="fc" id="L227">            final Object fromField = from.getField(i);</span>
<span class="fc bfc" id="L228" title="All 2 branches covered.">            if (fromField != null) {</span>
<span class="fc" id="L229">                final Object reuseField = reuse.getField(i);</span>
<span class="fc bfc" id="L230" title="All 2 branches covered.">                if (reuseField != null) {</span>
<span class="fc" id="L231">                    final Object copy = fieldSerializers[i].copy(fromField, reuseField);</span>
<span class="fc" id="L232">                    reuse.setField(i, copy);</span>
<span class="fc" id="L233">                } else {</span>
<span class="fc" id="L234">                    final Object copy = fieldSerializers[i].copy(fromField);</span>
<span class="fc" id="L235">                    reuse.setField(i, copy);</span>
                }
<span class="fc" id="L237">            } else {</span>
<span class="fc" id="L238">                reuse.setField(i, null);</span>
            }
        }
<span class="fc" id="L241">        return reuse;</span>
    }

    private Row copyNameBased(Row from, Set&lt;String&gt; fieldNames, Row reuse) {
<span class="pc bpc" id="L245" title="1 of 2 branches missed.">        if (positionByName == null) {</span>
<span class="nc" id="L246">            throw new RuntimeException(&quot;Serializer does not support named field positions.&quot;);</span>
        }
<span class="fc" id="L248">        reuse.clear();</span>
<span class="fc" id="L249">        reuse.setKind(from.getKind());</span>
<span class="pc bpc" id="L250" title="1 of 2 branches missed.">        for (String fieldName : fieldNames) {</span>
<span class="nc" id="L251">            final int targetPos = getPositionByName(fieldName);</span>
<span class="nc" id="L252">            final Object fromField = from.getField(fieldName);</span>
<span class="nc bnc" id="L253" title="All 2 branches missed.">            if (fromField != null) {</span>
<span class="nc" id="L254">                final Object reuseField = reuse.getField(fieldName);</span>
<span class="nc bnc" id="L255" title="All 2 branches missed.">                if (reuseField != null) {</span>
<span class="nc" id="L256">                    final Object copy = fieldSerializers[targetPos].copy(fromField, reuseField);</span>
<span class="nc" id="L257">                    reuse.setField(fieldName, copy);</span>
<span class="nc" id="L258">                } else {</span>
<span class="nc" id="L259">                    final Object copy = fieldSerializers[targetPos].copy(fromField);</span>
<span class="nc" id="L260">                    reuse.setField(fieldName, copy);</span>
                }
            }
<span class="nc" id="L263">        }</span>
<span class="fc" id="L264">        return reuse;</span>
    }

    @Override
    public int getLength() {
<span class="fc" id="L269">        return -1;</span>
    }

    public int getArity() {
<span class="nc" id="L273">        return arity;</span>
    }

    @Override
    public void serialize(Row record, DataOutputView target) throws IOException {
<span class="fc" id="L278">        final Set&lt;String&gt; fieldNames = record.getFieldNames(false);</span>
<span class="fc bfc" id="L279" title="All 2 branches covered.">        if (fieldNames == null) {</span>
<span class="fc" id="L280">            serializePositionBased(record, target);</span>
        } else {
<span class="fc" id="L282">            serializeNameBased(record, fieldNames, target);</span>
        }
<span class="fc" id="L284">    }</span>

    private void serializePositionBased(Row record, DataOutputView target) throws IOException {
<span class="fc" id="L287">        final int length = fieldSerializers.length;</span>
<span class="pc bpc" id="L288" title="1 of 2 branches missed.">        if (record.getArity() != length) {</span>
<span class="nc" id="L289">            throw new RuntimeException(</span>
                    &quot;Row arity of record (&quot;
<span class="nc" id="L291">                            + record.getArity()</span>
                            + &quot;) does not match this &quot;
                            + &quot;serializer's field length (&quot;
                            + length
                            + &quot;).&quot;);
        }

        // write bitmask
<span class="fc" id="L299">        fillMask(length, record, mask, legacyModeEnabled, legacyOffset);</span>
<span class="fc" id="L300">        writeMask(mask, target);</span>

        // serialize non-null fields
<span class="fc bfc" id="L303" title="All 2 branches covered.">        for (int fieldPos = 0; fieldPos &lt; length; fieldPos++) {</span>
<span class="fc" id="L304">            final Object o = record.getField(fieldPos);</span>
<span class="fc bfc" id="L305" title="All 2 branches covered.">            if (o != null) {</span>
<span class="fc" id="L306">                fieldSerializers[fieldPos].serialize(o, target);</span>
            }
        }
<span class="fc" id="L309">    }</span>

    private void serializeNameBased(Row record, Set&lt;String&gt; fieldNames, DataOutputView target)
            throws IOException {
<span class="pc bpc" id="L313" title="1 of 2 branches missed.">        if (positionByName == null) {</span>
<span class="nc" id="L314">            throw new RuntimeException(&quot;Serializer does not support named field positions.&quot;);</span>
        }
<span class="fc" id="L316">        reuseRowPositionBased.clear();</span>
<span class="fc" id="L317">        reuseRowPositionBased.setKind(record.getKind());</span>
<span class="fc bfc" id="L318" title="All 2 branches covered.">        for (String fieldName : fieldNames) {</span>
<span class="fc" id="L319">            final int targetPos = getPositionByName(fieldName);</span>
<span class="fc" id="L320">            final Object value = record.getField(fieldName);</span>
<span class="fc" id="L321">            reuseRowPositionBased.setField(targetPos, value);</span>
<span class="fc" id="L322">        }</span>
<span class="fc" id="L323">        serializePositionBased(reuseRowPositionBased, target);</span>
<span class="fc" id="L324">    }</span>

    @Override
    public Row deserialize(DataInputView source) throws IOException {
<span class="fc" id="L328">        final int length = fieldSerializers.length;</span>

        // read bitmask
<span class="fc" id="L331">        readIntoMask(source, mask);</span>

        // read row kind
        final RowKind kind;
<span class="fc bfc" id="L335" title="All 2 branches covered.">        if (legacyModeEnabled) {</span>
<span class="fc" id="L336">            kind = RowKind.INSERT;</span>
        } else {
<span class="fc" id="L338">            kind = readKindFromMask(mask);</span>
        }

        // deserialize fields
<span class="fc" id="L342">        final Object[] fieldByPosition = new Object[length];</span>
<span class="fc bfc" id="L343" title="All 2 branches covered.">        for (int fieldPos = 0; fieldPos &lt; length; fieldPos++) {</span>
<span class="fc bfc" id="L344" title="All 2 branches covered.">            if (!mask[legacyOffset + fieldPos]) {</span>
<span class="fc" id="L345">                fieldByPosition[fieldPos] = fieldSerializers[fieldPos].deserialize(source);</span>
            }
        }

<span class="fc" id="L349">        return RowUtils.createRowWithNamedPositions(kind, fieldByPosition, positionByName);</span>
    }

    @Override
    public Row deserialize(Row reuse, DataInputView source) throws IOException {
        // reuse uses name-based field mode, do a non-reuse deserialize
<span class="pc bpc" id="L355" title="2 of 4 branches missed.">        if (reuse == null || reuse.getFieldNames(false) != null) {</span>
<span class="nc" id="L356">            return deserialize(source);</span>
        }
<span class="fc" id="L358">        final int length = fieldSerializers.length;</span>

<span class="pc bpc" id="L360" title="1 of 2 branches missed.">        if (reuse.getArity() != length) {</span>
<span class="nc" id="L361">            throw new RuntimeException(</span>
                    &quot;Row arity of reuse (&quot;
<span class="nc" id="L363">                            + reuse.getArity()</span>
                            + &quot;) does not match &quot;
                            + &quot;this serializer's field length (&quot;
                            + length
                            + &quot;).&quot;);
        }

        // read bitmask
<span class="fc" id="L371">        readIntoMask(source, mask);</span>
<span class="fc bfc" id="L372" title="All 2 branches covered.">        if (!legacyModeEnabled) {</span>
<span class="fc" id="L373">            reuse.setKind(readKindFromMask(mask));</span>
        }

        // deserialize fields
<span class="fc bfc" id="L377" title="All 2 branches covered.">        for (int fieldPos = 0; fieldPos &lt; length; fieldPos++) {</span>
<span class="fc bfc" id="L378" title="All 2 branches covered.">            if (mask[legacyOffset + fieldPos]) {</span>
<span class="fc" id="L379">                reuse.setField(fieldPos, null);</span>
            } else {
<span class="fc" id="L381">                Object reuseField = reuse.getField(fieldPos);</span>
<span class="fc bfc" id="L382" title="All 2 branches covered.">                if (reuseField != null) {</span>
<span class="fc" id="L383">                    reuse.setField(</span>
<span class="fc" id="L384">                            fieldPos, fieldSerializers[fieldPos].deserialize(reuseField, source));</span>
                } else {
<span class="fc" id="L386">                    reuse.setField(fieldPos, fieldSerializers[fieldPos].deserialize(source));</span>
                }
            }
        }

<span class="fc" id="L391">        return reuse;</span>
    }

    @Override
    public void copy(DataInputView source, DataOutputView target) throws IOException {
<span class="fc" id="L396">        int len = fieldSerializers.length;</span>

        // copy bitmask
<span class="fc" id="L399">        readIntoAndCopyMask(source, target, mask);</span>

        // copy non-null fields
<span class="fc bfc" id="L402" title="All 2 branches covered.">        for (int fieldPos = 0; fieldPos &lt; len; fieldPos++) {</span>
<span class="fc bfc" id="L403" title="All 2 branches covered.">            if (!mask[legacyOffset + fieldPos]) {</span>
<span class="fc" id="L404">                fieldSerializers[fieldPos].copy(source, target);</span>
            }
        }
<span class="fc" id="L407">    }</span>

    @Override
    public boolean equals(Object o) {
<span class="pc bpc" id="L411" title="1 of 2 branches missed.">        if (this == o) {</span>
<span class="nc" id="L412">            return true;</span>
        }
<span class="pc bpc" id="L414" title="2 of 4 branches missed.">        if (o == null || getClass() != o.getClass()) {</span>
<span class="nc" id="L415">            return false;</span>
        }
<span class="fc" id="L417">        RowSerializer that = (RowSerializer) o;</span>
<span class="pc bpc" id="L418" title="1 of 2 branches missed.">        return legacyModeEnabled == that.legacyModeEnabled</span>
<span class="pc bpc" id="L419" title="1 of 2 branches missed.">                &amp;&amp; Arrays.equals(fieldSerializers, that.fieldSerializers);</span>
    }

    @Override
    public int hashCode() {
<span class="nc" id="L424">        int result = Objects.hash(legacyModeEnabled);</span>
<span class="nc" id="L425">        result = 31 * result + Arrays.hashCode(fieldSerializers);</span>
<span class="nc" id="L426">        return result;</span>
    }

    // --------------------------------------------------------------------------------------------

    private int getPositionByName(String fieldName) {
<span class="pc bpc" id="L432" title="2 of 4 branches missed.">        assert positionByName != null;</span>
<span class="fc" id="L433">        final Integer targetPos = positionByName.get(fieldName);</span>
<span class="pc bpc" id="L434" title="1 of 2 branches missed.">        if (targetPos == null) {</span>
<span class="nc" id="L435">            throw new RuntimeException(</span>
<span class="nc" id="L436">                    String.format(</span>
                            &quot;Unknown field name '%s' for mapping to a row position. &quot;
                                    + &quot;Available names are: %s&quot;,
<span class="nc" id="L439">                            fieldName, positionByName.keySet()));</span>
        }
<span class="fc" id="L441">        return targetPos;</span>
    }

    private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {
<span class="fc" id="L445">        in.defaultReadObject();</span>
<span class="fc" id="L446">        this.mask = new boolean[legacyOffset + fieldSerializers.length];</span>
<span class="fc" id="L447">        this.reuseRowPositionBased = new Row(fieldSerializers.length);</span>
<span class="fc" id="L448">    }</span>

    // --------------------------------------------------------------------------------------------
    // Serialization utilities
    // --------------------------------------------------------------------------------------------

    private static void fillMask(
            int fieldLength, Row row, boolean[] mask, boolean legacyModeEnabled, int legacyOffset) {
<span class="fc bfc" id="L456" title="All 2 branches covered.">        if (!legacyModeEnabled) {</span>
<span class="fc" id="L457">            final byte kind = row.getKind().toByteValue();</span>
<span class="fc bfc" id="L458" title="All 2 branches covered.">            mask[0] = (kind &amp; 0x01) &gt; 0;</span>
<span class="fc bfc" id="L459" title="All 2 branches covered.">            mask[1] = (kind &amp; 0x02) &gt; 0;</span>
        }

<span class="fc bfc" id="L462" title="All 2 branches covered.">        for (int fieldPos = 0; fieldPos &lt; fieldLength; fieldPos++) {</span>
<span class="fc bfc" id="L463" title="All 2 branches covered.">            mask[legacyOffset + fieldPos] = row.getField(fieldPos) == null;</span>
        }
<span class="fc" id="L465">    }</span>

    private static RowKind readKindFromMask(boolean[] mask) {
<span class="fc bfc" id="L468" title="All 4 branches covered.">        final byte kind = (byte) ((mask[0] ? 0x01 : 0x00) + (mask[1] ? 0x02 : 0x00));</span>
<span class="fc" id="L469">        return RowKind.fromByteValue(kind);</span>
    }

    // --------------------------------------------------------------------------------------------
    // Serializer configuration snapshoting &amp; compatibility
    // --------------------------------------------------------------------------------------------

    @Override
    public TypeSerializerSnapshot&lt;Row&gt; snapshotConfiguration() {
<span class="fc" id="L478">        return new RowSerializerSnapshot(this);</span>
    }

    /**
     * A snapshot for {@link RowSerializer}.
     *
     * @deprecated this snapshot class is no longer in use, and is maintained only for backwards
     *     compatibility. It is fully replaced by {@link RowSerializerSnapshot}.
     */
    @Deprecated
    public static final class RowSerializerConfigSnapshot
            extends CompositeTypeSerializerConfigSnapshot&lt;Row&gt; {

        private static final int VERSION = 1;

        /** This empty nullary constructor is required for deserializing the configuration. */
<span class="nc" id="L494">        public RowSerializerConfigSnapshot() {}</span>

        public RowSerializerConfigSnapshot(TypeSerializer&lt;?&gt;[] fieldSerializers) {
<span class="nc" id="L497">            super(fieldSerializers);</span>
<span class="nc" id="L498">        }</span>

        @Override
        public int getVersion() {
<span class="nc" id="L502">            return VERSION;</span>
        }

        @Override
        public TypeSerializerSchemaCompatibility&lt;Row&gt; resolveSchemaCompatibility(
                TypeSerializer&lt;Row&gt; newSerializer) {
<span class="nc" id="L508">            TypeSerializerSnapshot&lt;?&gt;[] nestedSnapshots =</span>
<span class="nc" id="L509">                    getNestedSerializersAndConfigs().stream()</span>
<span class="nc" id="L510">                            .map(t -&gt; t.f1)</span>
<span class="nc" id="L511">                            .toArray(TypeSerializerSnapshot[]::new);</span>

<span class="nc" id="L513">            return CompositeTypeSerializerUtil.delegateCompatibilityCheckToNewSnapshot(</span>
                    newSerializer, new RowSerializerSnapshot(), nestedSnapshots);
        }
    }

    /** A {@link TypeSerializerSnapshot} for RowSerializer. */
    public static final class RowSerializerSnapshot
            extends CompositeTypeSerializerSnapshot&lt;Row, RowSerializer&gt; {

        private static final int VERSION = 3;

        private static final int LAST_VERSION_WITHOUT_ROW_KIND = 2;

<span class="fc" id="L526">        private int readVersion = VERSION;</span>

        public RowSerializerSnapshot() {
<span class="fc" id="L529">            super(RowSerializer.class);</span>
<span class="fc" id="L530">        }</span>

        RowSerializerSnapshot(RowSerializer serializerInstance) {
<span class="fc" id="L533">            super(serializerInstance);</span>
<span class="fc" id="L534">        }</span>

        @Override
        protected int getCurrentOuterSnapshotVersion() {
<span class="fc" id="L538">            return VERSION;</span>
        }

        @Override
        protected void readOuterSnapshot(
                int readOuterSnapshotVersion, DataInputView in, ClassLoader userCodeClassLoader) {
<span class="fc" id="L544">            readVersion = readOuterSnapshotVersion;</span>
<span class="fc" id="L545">        }</span>

        @Override
        protected OuterSchemaCompatibility resolveOuterSchemaCompatibility(
                RowSerializer newSerializer) {
<span class="fc bfc" id="L550" title="All 2 branches covered.">            if (readVersion &lt;= LAST_VERSION_WITHOUT_ROW_KIND) {</span>
<span class="fc" id="L551">                return OuterSchemaCompatibility.COMPATIBLE_AFTER_MIGRATION;</span>
            }
<span class="fc" id="L553">            return OuterSchemaCompatibility.COMPATIBLE_AS_IS;</span>
        }

        @Override
        protected TypeSerializer&lt;?&gt;[] getNestedSerializers(RowSerializer outerSerializer) {
<span class="fc" id="L558">            return outerSerializer.fieldSerializers;</span>
        }

        @Override
        protected RowSerializer createOuterSerializerWithNestedSerializers(
                TypeSerializer&lt;?&gt;[] nestedSerializers) {
<span class="fc bfc" id="L564" title="All 2 branches covered.">            return new RowSerializer(</span>
                    nestedSerializers, null, readVersion &lt;= LAST_VERSION_WITHOUT_ROW_KIND);
        }
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.7.202105040129</span></div></body></html>