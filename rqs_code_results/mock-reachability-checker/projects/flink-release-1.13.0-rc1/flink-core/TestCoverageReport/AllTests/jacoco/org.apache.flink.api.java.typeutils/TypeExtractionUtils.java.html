<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>TypeExtractionUtils.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Flink : Core</a> &gt; <a href="index.source.html" class="el_package">org.apache.flink.api.java.typeutils</a> &gt; <span class="el_source">TypeExtractionUtils.java</span></div><h1>TypeExtractionUtils.java</h1><pre class="source lang-java linenums">/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * &quot;License&quot;); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.apache.flink.api.java.typeutils;

import org.apache.flink.annotation.Internal;
import org.apache.flink.api.common.functions.Function;
import org.apache.flink.api.common.functions.InvalidTypesException;

import java.lang.invoke.SerializedLambda;
import java.lang.reflect.Array;
import java.lang.reflect.Constructor;
import java.lang.reflect.GenericArrayType;
import java.lang.reflect.Method;
import java.lang.reflect.Modifier;
import java.lang.reflect.ParameterizedType;
import java.lang.reflect.Type;
import java.lang.reflect.TypeVariable;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;

import static org.apache.flink.shaded.asm7.org.objectweb.asm.Type.getConstructorDescriptor;
import static org.apache.flink.shaded.asm7.org.objectweb.asm.Type.getMethodDescriptor;

@Internal
public class TypeExtractionUtils {

    private TypeExtractionUtils() {
        // do not allow instantiation
    }

    /** Similar to a Java 8 Executable but with a return type. */
    public static class LambdaExecutable {

        private Type[] parameterTypes;
        private Type returnType;
        private String name;
        private Object executable;

<span class="fc" id="L56">        public LambdaExecutable(Constructor&lt;?&gt; constructor) {</span>
<span class="fc" id="L57">            this.parameterTypes = constructor.getGenericParameterTypes();</span>
<span class="fc" id="L58">            this.returnType = constructor.getDeclaringClass();</span>
<span class="fc" id="L59">            this.name = constructor.getName();</span>
<span class="fc" id="L60">            this.executable = constructor;</span>
<span class="fc" id="L61">        }</span>

<span class="fc" id="L63">        public LambdaExecutable(Method method) {</span>
<span class="fc" id="L64">            this.parameterTypes = method.getGenericParameterTypes();</span>
<span class="fc" id="L65">            this.returnType = method.getGenericReturnType();</span>
<span class="fc" id="L66">            this.name = method.getName();</span>
<span class="fc" id="L67">            this.executable = method;</span>
<span class="fc" id="L68">        }</span>

        public Type[] getParameterTypes() {
<span class="fc" id="L71">            return parameterTypes;</span>
        }

        public Type getReturnType() {
<span class="fc" id="L75">            return returnType;</span>
        }

        public String getName() {
<span class="nc" id="L79">            return name;</span>
        }

        public boolean executablesEquals(Method m) {
<span class="nc" id="L83">            return executable.equals(m);</span>
        }

        public boolean executablesEquals(Constructor&lt;?&gt; c) {
<span class="nc" id="L87">            return executable.equals(c);</span>
        }
    }

    /**
     * Checks if the given function has been implemented using a Java 8 lambda. If yes, a
     * LambdaExecutable is returned describing the method/constructor. Otherwise null.
     *
     * @throws TypeExtractionException lambda extraction is pretty hacky, it might fail for unknown
     *     JVM issues.
     */
    public static LambdaExecutable checkAndExtractLambda(Function function)
            throws TypeExtractionException {
        try {
            // get serialized lambda
<span class="fc" id="L102">            SerializedLambda serializedLambda = null;</span>
<span class="fc" id="L103">            for (Class&lt;?&gt; clazz = function.getClass();</span>
<span class="fc bfc" id="L104" title="All 2 branches covered.">                    clazz != null;</span>
<span class="fc" id="L105">                    clazz = clazz.getSuperclass()) {</span>
                try {
<span class="fc" id="L107">                    Method replaceMethod = clazz.getDeclaredMethod(&quot;writeReplace&quot;);</span>
<span class="fc" id="L108">                    replaceMethod.setAccessible(true);</span>
<span class="fc" id="L109">                    Object serialVersion = replaceMethod.invoke(function);</span>

                    // check if class is a lambda function
<span class="pc bpc" id="L112" title="1 of 2 branches missed.">                    if (serialVersion != null</span>
<span class="pc bpc" id="L113" title="1 of 2 branches missed.">                            &amp;&amp; serialVersion.getClass() == SerializedLambda.class) {</span>
<span class="fc" id="L114">                        serializedLambda = (SerializedLambda) serialVersion;</span>
<span class="fc" id="L115">                        break;</span>
                    }
<span class="fc" id="L117">                } catch (NoSuchMethodException e) {</span>
                    // thrown if the method is not there. fall through the loop
<span class="nc" id="L119">                }</span>
            }

            // not a lambda method -&gt; return null
<span class="fc bfc" id="L123" title="All 2 branches covered.">            if (serializedLambda == null) {</span>
<span class="fc" id="L124">                return null;</span>
            }

            // find lambda method
<span class="fc" id="L128">            String className = serializedLambda.getImplClass();</span>
<span class="fc" id="L129">            String methodName = serializedLambda.getImplMethodName();</span>
<span class="fc" id="L130">            String methodSig = serializedLambda.getImplMethodSignature();</span>

<span class="fc" id="L132">            Class&lt;?&gt; implClass =</span>
<span class="fc" id="L133">                    Class.forName(</span>
<span class="fc" id="L134">                            className.replace('/', '.'),</span>
                            true,
<span class="fc" id="L136">                            Thread.currentThread().getContextClassLoader());</span>

            // find constructor
<span class="fc bfc" id="L139" title="All 2 branches covered.">            if (methodName.equals(&quot;&lt;init&gt;&quot;)) {</span>
<span class="fc" id="L140">                Constructor&lt;?&gt;[] constructors = implClass.getDeclaredConstructors();</span>
<span class="pc bpc" id="L141" title="1 of 2 branches missed.">                for (Constructor&lt;?&gt; constructor : constructors) {</span>
<span class="fc bfc" id="L142" title="All 2 branches covered.">                    if (getConstructorDescriptor(constructor).equals(methodSig)) {</span>
<span class="fc" id="L143">                        return new LambdaExecutable(constructor);</span>
                    }
                }
<span class="nc" id="L146">            }</span>
            // find method
            else {
<span class="fc" id="L149">                List&lt;Method&gt; methods = getAllDeclaredMethods(implClass);</span>
<span class="pc bpc" id="L150" title="1 of 2 branches missed.">                for (Method method : methods) {</span>
<span class="fc bfc" id="L151" title="All 2 branches covered.">                    if (method.getName().equals(methodName)</span>
<span class="pc bpc" id="L152" title="1 of 2 branches missed.">                            &amp;&amp; getMethodDescriptor(method).equals(methodSig)) {</span>
<span class="fc" id="L153">                        return new LambdaExecutable(method);</span>
                    }
<span class="fc" id="L155">                }</span>
            }
<span class="nc" id="L157">            throw new TypeExtractionException(&quot;No lambda method found.&quot;);</span>
<span class="nc" id="L158">        } catch (Exception e) {</span>
<span class="nc" id="L159">            throw new TypeExtractionException(</span>
                    &quot;Could not extract lambda method out of function: &quot;
<span class="nc" id="L161">                            + e.getClass().getSimpleName()</span>
                            + &quot; - &quot;
<span class="nc" id="L163">                            + e.getMessage(),</span>
                    e);
        }
    }

    /**
     * Extracts type from given index from lambda. It supports nested types.
     *
     * @param baseClass SAM function that the lambda implements
     * @param exec lambda function to extract the type from
     * @param lambdaTypeArgumentIndices position of type to extract in type hierarchy
     * @param paramLen count of total parameters of the lambda (including closure parameters)
     * @param baseParametersLen count of lambda interface parameters (without closure parameters)
     * @return extracted type
     */
    public static Type extractTypeFromLambda(
            Class&lt;?&gt; baseClass,
            LambdaExecutable exec,
            int[] lambdaTypeArgumentIndices,
            int paramLen,
            int baseParametersLen) {
<span class="fc" id="L184">        Type output =</span>
<span class="fc" id="L185">                exec.getParameterTypes()[</span>
                        paramLen - baseParametersLen + lambdaTypeArgumentIndices[0]];
<span class="pc bpc" id="L187" title="1 of 2 branches missed.">        for (int i = 1; i &lt; lambdaTypeArgumentIndices.length; i++) {</span>
<span class="nc" id="L188">            validateLambdaType(baseClass, output);</span>
<span class="nc" id="L189">            output = extractTypeArgument(output, lambdaTypeArgumentIndices[i]);</span>
        }
<span class="nc" id="L191">        validateLambdaType(baseClass, output);</span>
<span class="nc" id="L192">        return output;</span>
    }

    /**
     * This method extracts the n-th type argument from the given type. An InvalidTypesException is
     * thrown if the type does not have any type arguments or if the index exceeds the number of
     * type arguments.
     *
     * @param t Type to extract the type arguments from
     * @param index Index of the type argument to extract
     * @return The extracted type argument
     * @throws InvalidTypesException if the given type does not have any type arguments or if the
     *     index exceeds the number of type arguments.
     */
    public static Type extractTypeArgument(Type t, int index) throws InvalidTypesException {
<span class="nc bnc" id="L207" title="All 2 branches missed.">        if (t instanceof ParameterizedType) {</span>
<span class="nc" id="L208">            Type[] actualTypeArguments = ((ParameterizedType) t).getActualTypeArguments();</span>

<span class="nc bnc" id="L210" title="All 4 branches missed.">            if (index &lt; 0 || index &gt;= actualTypeArguments.length) {</span>
<span class="nc" id="L211">                throw new InvalidTypesException(</span>
                        &quot;Cannot extract the type argument with index &quot;
                                + index
                                + &quot; because the type has only &quot;
                                + actualTypeArguments.length
                                + &quot; type arguments.&quot;);
            } else {
<span class="nc" id="L218">                return actualTypeArguments[index];</span>
            }
        } else {
<span class="nc" id="L221">            throw new InvalidTypesException(</span>
                    &quot;The given type &quot; + t + &quot; is not a parameterized type.&quot;);
        }
    }

    /**
     * Extracts a Single Abstract Method (SAM) as defined in Java Specification (4.3.2. The Class
     * Object, 9.8 Functional Interfaces, 9.4.3 Interface Method Body) from given class.
     *
     * @param baseClass a class that is a FunctionalInterface to retrieve a SAM from
     * @throws InvalidTypesException if the given class does not implement FunctionalInterface
     * @return single abstract method of the given class
     */
    public static Method getSingleAbstractMethod(Class&lt;?&gt; baseClass) {

<span class="fc bfc" id="L236" title="All 2 branches covered.">        if (!baseClass.isInterface()) {</span>
<span class="fc" id="L237">            throw new InvalidTypesException(</span>
                    &quot;Given class: &quot; + baseClass + &quot;is not a FunctionalInterface.&quot;);
        }

<span class="fc" id="L241">        Method sam = null;</span>
<span class="fc bfc" id="L242" title="All 2 branches covered.">        for (Method method : baseClass.getMethods()) {</span>
<span class="fc bfc" id="L243" title="All 2 branches covered.">            if (Modifier.isAbstract(method.getModifiers())) {</span>
<span class="fc bfc" id="L244" title="All 2 branches covered.">                if (sam == null) {</span>
<span class="fc" id="L245">                    sam = method;</span>
                } else {
<span class="fc" id="L247">                    throw new InvalidTypesException(</span>
                            &quot;Given class: &quot;
                                    + baseClass
                                    + &quot; is not a FunctionalInterface. It has more than one abstract method.&quot;);
                }
            }
        }

<span class="fc bfc" id="L255" title="All 2 branches covered.">        if (sam == null) {</span>
<span class="fc" id="L256">            throw new InvalidTypesException(</span>
                    &quot;Given class: &quot;
                            + baseClass
                            + &quot; is not a FunctionalInterface. It does not have any abstract methods.&quot;);
        }

<span class="fc" id="L262">        return sam;</span>
    }

    /** Returns all declared methods of a class including methods of superclasses. */
    public static List&lt;Method&gt; getAllDeclaredMethods(Class&lt;?&gt; clazz) {
<span class="fc" id="L267">        List&lt;Method&gt; result = new ArrayList&lt;&gt;();</span>
<span class="fc bfc" id="L268" title="All 2 branches covered.">        while (clazz != null) {</span>
<span class="fc" id="L269">            Method[] methods = clazz.getDeclaredMethods();</span>
<span class="fc" id="L270">            Collections.addAll(result, methods);</span>
<span class="fc" id="L271">            clazz = clazz.getSuperclass();</span>
<span class="fc" id="L272">        }</span>
<span class="fc" id="L273">        return result;</span>
    }

    /** Convert ParameterizedType or Class to a Class. */
    @SuppressWarnings(&quot;unchecked&quot;)
    public static &lt;T&gt; Class&lt;T&gt; typeToClass(Type t) {
<span class="fc bfc" id="L279" title="All 2 branches covered.">        if (t instanceof Class) {</span>
<span class="fc" id="L280">            return (Class&lt;T&gt;) t;</span>
<span class="pc bpc" id="L281" title="1 of 2 branches missed.">        } else if (t instanceof ParameterizedType) {</span>
<span class="fc" id="L282">            return ((Class&lt;T&gt;) ((ParameterizedType) t).getRawType());</span>
        }
<span class="nc" id="L284">        throw new IllegalArgumentException(&quot;Cannot convert type to class&quot;);</span>
    }

    /**
     * Checks if a type can be converted to a Class. This is true for ParameterizedType and Class.
     */
    public static boolean isClassType(Type t) {
<span class="fc bfc" id="L291" title="All 4 branches covered.">        return t instanceof Class&lt;?&gt; || t instanceof ParameterizedType;</span>
    }

    /** Checks whether two types are type variables describing the same. */
    public static boolean sameTypeVars(Type t1, Type t2) {
<span class="fc bfc" id="L296" title="All 4 branches covered.">        return t1 instanceof TypeVariable</span>
                &amp;&amp; t2 instanceof TypeVariable
<span class="fc bfc" id="L298" title="All 2 branches covered.">                &amp;&amp; ((TypeVariable&lt;?&gt;) t1).getName().equals(((TypeVariable&lt;?&gt;) t2).getName())</span>
                &amp;&amp; ((TypeVariable&lt;?&gt;) t1)
<span class="fc" id="L300">                        .getGenericDeclaration()</span>
<span class="fc bfc" id="L301" title="All 2 branches covered.">                        .equals(((TypeVariable&lt;?&gt;) t2).getGenericDeclaration());</span>
    }

    /**
     * Traverses the type hierarchy of a type up until a certain stop class is found.
     *
     * @param t type for which a hierarchy need to be created
     * @return type of the immediate child of the stop class
     */
    public static Type getTypeHierarchy(List&lt;Type&gt; typeHierarchy, Type t, Class&lt;?&gt; stopAtClass) {
<span class="pc bpc" id="L311" title="1 of 4 branches missed.">        while (!(isClassType(t) &amp;&amp; typeToClass(t).equals(stopAtClass))) {</span>
<span class="fc" id="L312">            typeHierarchy.add(t);</span>
<span class="fc" id="L313">            t = typeToClass(t).getGenericSuperclass();</span>

<span class="fc bfc" id="L315" title="All 2 branches covered.">            if (t == null) {</span>
<span class="fc" id="L316">                break;</span>
            }
        }
<span class="fc" id="L319">        return t;</span>
    }

    /**
     * Returns true if the given class has a superclass of given name.
     *
     * @param clazz class to be analyzed
     * @param superClassName class name of the super class
     */
    public static boolean hasSuperclass(Class&lt;?&gt; clazz, String superClassName) {
<span class="fc" id="L329">        List&lt;Type&gt; hierarchy = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L330">        getTypeHierarchy(hierarchy, clazz, Object.class);</span>
<span class="fc bfc" id="L331" title="All 2 branches covered.">        for (Type t : hierarchy) {</span>
<span class="pc bpc" id="L332" title="2 of 4 branches missed.">            if (isClassType(t) &amp;&amp; typeToClass(t).getName().equals(superClassName)) {</span>
<span class="nc" id="L333">                return true;</span>
            }
<span class="fc" id="L335">        }</span>
<span class="fc" id="L336">        return false;</span>
    }

    /**
     * Returns the raw class of both parameterized types and generic arrays. Returns
     * java.lang.Object for all other types.
     */
    public static Class&lt;?&gt; getRawClass(Type t) {
<span class="nc bnc" id="L344" title="All 2 branches missed.">        if (isClassType(t)) {</span>
<span class="nc" id="L345">            return typeToClass(t);</span>
<span class="nc bnc" id="L346" title="All 2 branches missed.">        } else if (t instanceof GenericArrayType) {</span>
<span class="nc" id="L347">            Type component = ((GenericArrayType) t).getGenericComponentType();</span>
<span class="nc" id="L348">            return Array.newInstance(getRawClass(component), 0).getClass();</span>
        }
<span class="nc" id="L350">        return Object.class;</span>
    }

    /**
     * Checks whether the given type has the generic parameters declared in the class definition.
     *
     * @param t type to be validated
     */
    public static void validateLambdaType(Class&lt;?&gt; baseClass, Type t) {
<span class="fc bfc" id="L359" title="All 2 branches covered.">        if (!(t instanceof Class)) {</span>
<span class="fc" id="L360">            return;</span>
        }
<span class="fc" id="L362">        final Class&lt;?&gt; clazz = (Class&lt;?&gt;) t;</span>

<span class="fc bfc" id="L364" title="All 2 branches covered.">        if (clazz.getTypeParameters().length &gt; 0) {</span>
<span class="fc" id="L365">            throw new InvalidTypesException(</span>
                    &quot;The generic type parameters of '&quot;
<span class="fc" id="L367">                            + clazz.getSimpleName()</span>
                            + &quot;' are missing. &quot;
                            + &quot;In many cases lambda methods don't provide enough information for automatic type extraction when Java generics are involved. &quot;
                            + &quot;An easy workaround is to use an (anonymous) class instead that implements the '&quot;
<span class="fc" id="L371">                            + baseClass.getName()</span>
                            + &quot;' interface. &quot;
                            + &quot;Otherwise the type has to be specified explicitly using type information.&quot;);
        }
<span class="fc" id="L375">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.7.202105040129</span></div></body></html>