<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>RowComparator.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Flink : Core</a> &gt; <a href="index.source.html" class="el_package">org.apache.flink.api.java.typeutils.runtime</a> &gt; <span class="el_source">RowComparator.java</span></div><h1>RowComparator.java</h1><pre class="source lang-java linenums">/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * &quot;License&quot;); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.flink.api.java.typeutils.runtime;

import org.apache.flink.annotation.Internal;
import org.apache.flink.api.common.typeutils.CompositeTypeComparator;
import org.apache.flink.api.common.typeutils.TypeComparator;
import org.apache.flink.api.common.typeutils.TypeSerializer;
import org.apache.flink.api.java.tuple.Tuple4;
import org.apache.flink.core.memory.DataInputView;
import org.apache.flink.core.memory.DataOutputView;
import org.apache.flink.core.memory.MemorySegment;
import org.apache.flink.types.KeyFieldOutOfBoundsException;
import org.apache.flink.types.Row;

import java.io.IOException;
import java.util.Collections;
import java.util.List;

import static org.apache.flink.api.java.typeutils.runtime.MaskUtils.readIntoMask;
import static org.apache.flink.api.java.typeutils.runtime.RowSerializer.ROW_KIND_OFFSET;
import static org.apache.flink.util.Preconditions.checkArgument;

/**
 * Comparator for {@link Row}.
 *
 * &lt;p&gt;Note: Since comparators are used only in DataSet API for batch use cases, this comparator
 * assumes the latest serialization format and ignores {@link Row#getKind()} for simplicity of the
 * implementation and efficiency.
 */
@Internal
public class RowComparator extends CompositeTypeComparator&lt;Row&gt; {

    private static final long serialVersionUID = 2L;
    /** The number of fields of the Row */
    private final int arity;
    /** key positions describe which fields are keys in what order */
    private final int[] keyPositions;
    /** null-aware comparators for the key fields, in the same order as the key fields */
    private final NullAwareComparator&lt;Object&gt;[] comparators;
    /** serializers to deserialize the first n fields for comparison */
    private final TypeSerializer&lt;Object&gt;[] serializers;
    /** auxiliary fields for normalized key support */
    private final int[] normalizedKeyLengths;

    private final int numLeadingNormalizableKeys;
    private final int normalizableKeyPrefixLen;
    private final boolean invertNormKey;

    // bitmask for serialized comparison
    // see serializer for more information about the bitmask encoding
    private final boolean[] mask1;
    private final boolean[] mask2;

    // cache for the deserialized key field objects
    private final transient Object[] deserializedKeyFields1;
    private final transient Object[] deserializedKeyFields2;

    /**
     * General constructor for RowComparator.
     *
     * @param arity the number of fields of the Row
     * @param keyPositions key positions describe which fields are keys in what order
     * @param comparators non-null-aware comparators for the key fields, in the same order as the
     *     key fields
     * @param serializers serializers to deserialize the first n fields for comparison
     * @param orders sorting orders for the fields
     */
    public RowComparator(
            int arity,
            int[] keyPositions,
            TypeComparator&lt;Object&gt;[] comparators,
            TypeSerializer&lt;Object&gt;[] serializers,
            boolean[] orders) {

<span class="fc" id="L91">        this(arity, keyPositions, makeNullAware(comparators, orders), serializers);</span>
<span class="fc" id="L92">    }</span>

    /** Intermediate constructor for creating auxiliary fields. */
    private RowComparator(
            int arity,
            int[] keyPositions,
            NullAwareComparator&lt;Object&gt;[] comparators,
            TypeSerializer&lt;Object&gt;[] serializers) {

<span class="fc" id="L101">        this(</span>
                arity,
                keyPositions,
                comparators,
                serializers,
<span class="fc" id="L106">                createAuxiliaryFields(keyPositions, comparators));</span>
<span class="fc" id="L107">    }</span>

    /** Intermediate constructor for creating auxiliary fields. */
    private RowComparator(
            int arity,
            int[] keyPositions,
            NullAwareComparator&lt;Object&gt;[] comparators,
            TypeSerializer&lt;Object&gt;[] serializers,
            Tuple4&lt;int[], Integer, Integer, Boolean&gt; auxiliaryFields) {

<span class="fc" id="L117">        this(</span>
                arity,
                keyPositions,
                comparators,
                serializers,
                auxiliaryFields.f0,
<span class="fc" id="L123">                auxiliaryFields.f1,</span>
<span class="fc" id="L124">                auxiliaryFields.f2,</span>
<span class="fc" id="L125">                auxiliaryFields.f3);</span>
<span class="fc" id="L126">    }</span>

    /** Intermediate constructor for creating auxiliary fields. */
    private RowComparator(
            int arity,
            int[] keyPositions,
            NullAwareComparator&lt;Object&gt;[] comparators,
            TypeSerializer&lt;Object&gt;[] serializers,
            int[] normalizedKeyLengths,
            int numLeadingNormalizableKeys,
            int normalizableKeyPrefixLen,
<span class="fc" id="L137">            boolean invertNormKey) {</span>

<span class="fc" id="L139">        this.arity = arity;</span>
<span class="fc" id="L140">        this.keyPositions = keyPositions;</span>
<span class="fc" id="L141">        this.comparators = comparators;</span>
<span class="fc" id="L142">        this.serializers = serializers;</span>
<span class="fc" id="L143">        this.normalizedKeyLengths = normalizedKeyLengths;</span>
<span class="fc" id="L144">        this.numLeadingNormalizableKeys = numLeadingNormalizableKeys;</span>
<span class="fc" id="L145">        this.normalizableKeyPrefixLen = normalizableKeyPrefixLen;</span>
<span class="fc" id="L146">        this.invertNormKey = invertNormKey;</span>
<span class="fc" id="L147">        this.mask1 = new boolean[ROW_KIND_OFFSET + arity];</span>
<span class="fc" id="L148">        this.mask2 = new boolean[ROW_KIND_OFFSET + arity];</span>
<span class="fc" id="L149">        deserializedKeyFields1 = instantiateDeserializationFields();</span>
<span class="fc" id="L150">        deserializedKeyFields2 = instantiateDeserializationFields();</span>
<span class="fc" id="L151">    }</span>

    // --------------------------------------------------------------------------------------------
    //  Comparator Methods
    // --------------------------------------------------------------------------------------------

    @Override
    public void getFlatComparator(List&lt;TypeComparator&gt; flatComparators) {
<span class="fc bfc" id="L159" title="All 2 branches covered.">        for (NullAwareComparator&lt;Object&gt; c : comparators) {</span>
<span class="fc" id="L160">            Collections.addAll(flatComparators, c.getFlatComparators());</span>
        }
<span class="fc" id="L162">    }</span>

    @Override
    public int hash(Row record) {
<span class="nc" id="L166">        int code = 0;</span>
<span class="nc" id="L167">        int i = 0;</span>

        try {
<span class="nc bnc" id="L170" title="All 2 branches missed.">            for (; i &lt; keyPositions.length; i++) {</span>
<span class="nc" id="L171">                code *= TupleComparatorBase.HASH_SALT[i &amp; 0x1F];</span>
<span class="nc" id="L172">                Object element = record.getField(keyPositions[i]); // element can be null</span>
<span class="nc" id="L173">                code += comparators[i].hash(element);</span>
            }
<span class="nc" id="L175">        } catch (IndexOutOfBoundsException e) {</span>
<span class="nc" id="L176">            throw new KeyFieldOutOfBoundsException(keyPositions[i]);</span>
<span class="nc" id="L177">        }</span>

<span class="nc" id="L179">        return code;</span>
    }

    @Override
    public void setReference(Row toCompare) {
<span class="fc" id="L184">        int i = 0;</span>
        try {
<span class="fc bfc" id="L186" title="All 2 branches covered.">            for (; i &lt; keyPositions.length; i++) {</span>
<span class="fc" id="L187">                TypeComparator&lt;Object&gt; comparator = comparators[i];</span>
<span class="fc" id="L188">                Object element = toCompare.getField(keyPositions[i]);</span>
<span class="fc" id="L189">                comparator.setReference(element); // element can be null</span>
            }
<span class="nc" id="L191">        } catch (IndexOutOfBoundsException e) {</span>
<span class="nc" id="L192">            throw new KeyFieldOutOfBoundsException(keyPositions[i]);</span>
<span class="fc" id="L193">        }</span>
<span class="fc" id="L194">    }</span>

    @Override
    public boolean equalToReference(Row candidate) {
<span class="fc" id="L198">        int i = 0;</span>
        try {
<span class="fc bfc" id="L200" title="All 2 branches covered.">            for (; i &lt; keyPositions.length; i++) {</span>
<span class="fc" id="L201">                TypeComparator&lt;Object&gt; comparator = comparators[i];</span>
<span class="fc" id="L202">                Object element = candidate.getField(keyPositions[i]); // element can be null</span>
                // check if reference is not equal
<span class="pc bpc" id="L204" title="1 of 2 branches missed.">                if (!comparator.equalToReference(element)) {</span>
<span class="nc" id="L205">                    return false;</span>
                }
            }
<span class="nc" id="L208">        } catch (IndexOutOfBoundsException e) {</span>
<span class="nc" id="L209">            throw new KeyFieldOutOfBoundsException(keyPositions[i]);</span>
<span class="fc" id="L210">        }</span>
<span class="fc" id="L211">        return true;</span>
    }

    @Override
    public int compareToReference(TypeComparator&lt;Row&gt; referencedComparator) {
<span class="fc" id="L216">        RowComparator other = (RowComparator) referencedComparator;</span>
<span class="fc" id="L217">        int i = 0;</span>
        try {
<span class="fc bfc" id="L219" title="All 2 branches covered.">            for (; i &lt; keyPositions.length; i++) {</span>
<span class="fc" id="L220">                int cmp = comparators[i].compareToReference(other.comparators[i]);</span>
<span class="fc bfc" id="L221" title="All 2 branches covered.">                if (cmp != 0) {</span>
<span class="fc" id="L222">                    return cmp;</span>
                }
            }
<span class="nc" id="L225">        } catch (IndexOutOfBoundsException e) {</span>
<span class="nc" id="L226">            throw new KeyFieldOutOfBoundsException(keyPositions[i]);</span>
<span class="fc" id="L227">        }</span>
<span class="fc" id="L228">        return 0;</span>
    }

    @Override
    public int compare(Row first, Row second) {
<span class="nc" id="L233">        int i = 0;</span>
        try {
<span class="nc bnc" id="L235" title="All 2 branches missed.">            for (; i &lt; keyPositions.length; i++) {</span>
<span class="nc" id="L236">                int keyPos = keyPositions[i];</span>
<span class="nc" id="L237">                TypeComparator&lt;Object&gt; comparator = comparators[i];</span>
<span class="nc" id="L238">                Object firstElement = first.getField(keyPos); // element can be null</span>
<span class="nc" id="L239">                Object secondElement = second.getField(keyPos); // element can be null</span>

<span class="nc" id="L241">                int cmp = comparator.compare(firstElement, secondElement);</span>
<span class="nc bnc" id="L242" title="All 2 branches missed.">                if (cmp != 0) {</span>
<span class="nc" id="L243">                    return cmp;</span>
                }
            }
<span class="nc" id="L246">        } catch (IndexOutOfBoundsException e) {</span>
<span class="nc" id="L247">            throw new KeyFieldOutOfBoundsException(keyPositions[i]);</span>
<span class="nc" id="L248">        }</span>
<span class="nc" id="L249">        return 0;</span>
    }

    @Override
    public int compareSerialized(DataInputView firstSource, DataInputView secondSource)
            throws IOException {
<span class="fc" id="L255">        final int len = serializers.length;</span>
<span class="fc" id="L256">        final int keyLen = keyPositions.length;</span>

        // read bitmask
<span class="fc" id="L259">        readIntoMask(firstSource, mask1);</span>
<span class="fc" id="L260">        readIntoMask(secondSource, mask2);</span>

        // deserialize fields
<span class="fc bfc" id="L263" title="All 2 branches covered.">        for (int fieldPos = 0; fieldPos &lt; len; fieldPos++) {</span>
<span class="fc" id="L264">            final TypeSerializer&lt;Object&gt; serializer = serializers[fieldPos];</span>

            // deserialize field 1
<span class="fc bfc" id="L267" title="All 2 branches covered.">            if (!mask1[ROW_KIND_OFFSET + fieldPos]) {</span>
<span class="fc" id="L268">                deserializedKeyFields1[fieldPos] =</span>
<span class="fc" id="L269">                        serializer.deserialize(deserializedKeyFields1[fieldPos], firstSource);</span>
            }

            // deserialize field 2
<span class="fc bfc" id="L273" title="All 2 branches covered.">            if (!mask2[ROW_KIND_OFFSET + fieldPos]) {</span>
<span class="fc" id="L274">                deserializedKeyFields2[fieldPos] =</span>
<span class="fc" id="L275">                        serializer.deserialize(deserializedKeyFields2[fieldPos], secondSource);</span>
            }
        }

        // compare
<span class="fc bfc" id="L280" title="All 2 branches covered.">        for (int fieldPos = 0; fieldPos &lt; keyLen; fieldPos++) {</span>
<span class="fc" id="L281">            final int keyPos = keyPositions[fieldPos];</span>
<span class="fc" id="L282">            final TypeComparator&lt;Object&gt; comparator = comparators[fieldPos];</span>

<span class="fc" id="L284">            final boolean isNull1 = mask1[ROW_KIND_OFFSET + keyPos];</span>
<span class="fc" id="L285">            final boolean isNull2 = mask2[ROW_KIND_OFFSET + keyPos];</span>

            int cmp;
            // both values are null -&gt; equality
<span class="fc bfc" id="L289" title="All 4 branches covered.">            if (isNull1 &amp;&amp; isNull2) {</span>
<span class="fc" id="L290">                cmp = 0;</span>
            }
            // first value is null -&gt; inequality
<span class="fc bfc" id="L293" title="All 2 branches covered.">            else if (isNull1) {</span>
<span class="fc" id="L294">                cmp = comparator.compare(null, deserializedKeyFields2[keyPos]);</span>
            }
            // second value is null -&gt; inequality
<span class="fc bfc" id="L297" title="All 2 branches covered.">            else if (isNull2) {</span>
<span class="fc" id="L298">                cmp = comparator.compare(deserializedKeyFields1[keyPos], null);</span>
            }
            // no null values
            else {
<span class="fc" id="L302">                cmp =</span>
<span class="fc" id="L303">                        comparator.compare(</span>
                                deserializedKeyFields1[keyPos], deserializedKeyFields2[keyPos]);
            }

<span class="fc bfc" id="L307" title="All 2 branches covered.">            if (cmp != 0) {</span>
<span class="fc" id="L308">                return cmp;</span>
            }
        }

<span class="fc" id="L312">        return 0;</span>
    }

    @Override
    public boolean supportsNormalizedKey() {
<span class="pc bpc" id="L317" title="1 of 2 branches missed.">        return numLeadingNormalizableKeys &gt; 0;</span>
    }

    @Override
    public boolean supportsSerializationWithKeyNormalization() {
<span class="fc" id="L322">        return false;</span>
    }

    @Override
    public int getNormalizeKeyLen() {
<span class="fc" id="L327">        return normalizableKeyPrefixLen;</span>
    }

    @Override
    public boolean isNormalizedKeyPrefixOnly(int keyBytes) {
<span class="pc bpc" id="L332" title="5 of 6 branches missed.">        return numLeadingNormalizableKeys &lt; keyPositions.length</span>
                || normalizableKeyPrefixLen == Integer.MAX_VALUE
                || normalizableKeyPrefixLen &gt; keyBytes;
    }

    @Override
    public void putNormalizedKey(Row record, MemorySegment target, int offset, int numBytes) {
<span class="fc" id="L339">        int bytesLeft = numBytes;</span>
<span class="fc" id="L340">        int currentOffset = offset;</span>

<span class="pc bpc" id="L342" title="1 of 4 branches missed.">        for (int i = 0; i &lt; numLeadingNormalizableKeys &amp;&amp; bytesLeft &gt; 0; i++) {</span>
<span class="fc" id="L343">            int len = normalizedKeyLengths[i];</span>
<span class="fc bfc" id="L344" title="All 2 branches covered.">            len = bytesLeft &gt;= len ? len : bytesLeft;</span>

<span class="fc" id="L346">            TypeComparator&lt;Object&gt; comparator = comparators[i];</span>
<span class="fc" id="L347">            Object element = record.getField(keyPositions[i]); // element can be null</span>
            // write key
<span class="fc" id="L349">            comparator.putNormalizedKey(element, target, currentOffset, len);</span>

<span class="fc" id="L351">            bytesLeft -= len;</span>
<span class="fc" id="L352">            currentOffset += len;</span>
        }
<span class="fc" id="L354">    }</span>

    @Override
    public void writeWithKeyNormalization(Row record, DataOutputView target) throws IOException {
<span class="nc" id="L358">        throw new UnsupportedOperationException(</span>
                &quot;Record serialization with leading normalized keys not supported.&quot;);
    }

    @Override
    public Row readWithKeyDenormalization(Row reuse, DataInputView source) throws IOException {
<span class="nc" id="L364">        throw new UnsupportedOperationException(</span>
                &quot;Record deserialization with leading normalized keys not supported.&quot;);
    }

    @Override
    public boolean invertNormalizedKey() {
<span class="nc" id="L370">        return invertNormKey;</span>
    }

    @Override
    public TypeComparator&lt;Row&gt; duplicate() {
<span class="fc" id="L375">        NullAwareComparator&lt;?&gt;[] comparatorsCopy = new NullAwareComparator&lt;?&gt;[comparators.length];</span>
<span class="fc bfc" id="L376" title="All 2 branches covered.">        for (int i = 0; i &lt; comparators.length; i++) {</span>
<span class="fc" id="L377">            comparatorsCopy[i] = (NullAwareComparator&lt;?&gt;) comparators[i].duplicate();</span>
        }

<span class="fc" id="L380">        TypeSerializer&lt;?&gt;[] serializersCopy = new TypeSerializer&lt;?&gt;[serializers.length];</span>
<span class="fc bfc" id="L381" title="All 2 branches covered.">        for (int i = 0; i &lt; serializers.length; i++) {</span>
<span class="fc" id="L382">            serializersCopy[i] = serializers[i].duplicate();</span>
        }

<span class="fc" id="L385">        return new RowComparator(</span>
                arity,
                keyPositions,
                (NullAwareComparator&lt;Object&gt;[]) comparatorsCopy,
                (TypeSerializer&lt;Object&gt;[]) serializersCopy,
                normalizedKeyLengths,
                numLeadingNormalizableKeys,
                normalizableKeyPrefixLen,
                invertNormKey);
    }

    @Override
    public int extractKeys(Object record, Object[] target, int index) {
<span class="fc" id="L398">        int len = comparators.length;</span>
<span class="fc" id="L399">        int localIndex = index;</span>
<span class="fc bfc" id="L400" title="All 2 branches covered.">        for (int i = 0; i &lt; len; i++) {</span>
<span class="fc" id="L401">            Object element = ((Row) record).getField(keyPositions[i]); // element can be null</span>
<span class="fc" id="L402">            localIndex += comparators[i].extractKeys(element, target, localIndex);</span>
        }
<span class="fc" id="L404">        return localIndex - index;</span>
    }

    private Object[] instantiateDeserializationFields() {
<span class="fc" id="L408">        Object[] newFields = new Object[serializers.length];</span>
<span class="fc bfc" id="L409" title="All 2 branches covered.">        for (int i = 0; i &lt; serializers.length; i++) {</span>
<span class="fc" id="L410">            newFields[i] = serializers[i].createInstance();</span>
        }
<span class="fc" id="L412">        return newFields;</span>
    }

    /** @return creates auxiliary fields for normalized key support */
    private static Tuple4&lt;int[], Integer, Integer, Boolean&gt; createAuxiliaryFields(
            int[] keyPositions, NullAwareComparator&lt;Object&gt;[] comparators) {

<span class="fc" id="L419">        int[] normalizedKeyLengths = new int[keyPositions.length];</span>
<span class="fc" id="L420">        int numLeadingNormalizableKeys = 0;</span>
<span class="fc" id="L421">        int normalizableKeyPrefixLen = 0;</span>
<span class="fc" id="L422">        boolean inverted = false;</span>

<span class="pc bpc" id="L424" title="1 of 2 branches missed.">        for (int i = 0; i &lt; keyPositions.length; i++) {</span>
<span class="fc" id="L425">            NullAwareComparator&lt;Object&gt; k = comparators[i];</span>
            // as long as the leading keys support normalized keys, we can build up the composite
            // key
<span class="fc bfc" id="L428" title="All 2 branches covered.">            if (k.supportsNormalizedKey()) {</span>
<span class="pc bpc" id="L429" title="1 of 2 branches missed.">                if (i == 0) {</span>
                    // the first comparator decides whether we need to invert the key direction
<span class="fc" id="L431">                    inverted = k.invertNormalizedKey();</span>
<span class="nc bnc" id="L432" title="All 2 branches missed.">                } else if (k.invertNormalizedKey() != inverted) {</span>
                    // if a successor does not agree on the inversion direction, it cannot be part
                    // of the
                    // normalized key
<span class="nc" id="L436">                    return new Tuple4&lt;&gt;(</span>
                            normalizedKeyLengths,
<span class="nc" id="L438">                            numLeadingNormalizableKeys,</span>
<span class="nc" id="L439">                            normalizableKeyPrefixLen,</span>
<span class="nc" id="L440">                            inverted);</span>
                }
<span class="fc" id="L442">                numLeadingNormalizableKeys++;</span>
<span class="fc" id="L443">                int len = k.getNormalizeKeyLen();</span>
<span class="pc bpc" id="L444" title="1 of 2 branches missed.">                if (len &lt; 0) {</span>
<span class="nc" id="L445">                    throw new RuntimeException(</span>
                            &quot;Comparator &quot;
<span class="nc" id="L447">                                    + k.getClass().getName()</span>
                                    + &quot; specifies an invalid length for the normalized key: &quot;
                                    + len);
                }
<span class="fc" id="L451">                normalizedKeyLengths[i] = len;</span>
<span class="fc" id="L452">                normalizableKeyPrefixLen += len;</span>
<span class="pc bpc" id="L453" title="1 of 2 branches missed.">                if (normalizableKeyPrefixLen &lt; 0) {</span>
                    // overflow, which means we are out of budget for normalized key space anyways
<span class="nc" id="L455">                    return new Tuple4&lt;&gt;(</span>
                            normalizedKeyLengths,
<span class="nc" id="L457">                            numLeadingNormalizableKeys,</span>
<span class="nc" id="L458">                            Integer.MAX_VALUE,</span>
<span class="nc" id="L459">                            inverted);</span>
                }
<span class="fc" id="L461">            } else {</span>
<span class="fc" id="L462">                return new Tuple4&lt;&gt;(</span>
                        normalizedKeyLengths,
<span class="fc" id="L464">                        numLeadingNormalizableKeys,</span>
<span class="fc" id="L465">                        normalizableKeyPrefixLen,</span>
<span class="fc" id="L466">                        inverted);</span>
            }
        }
<span class="nc" id="L469">        return new Tuple4&lt;&gt;(</span>
                normalizedKeyLengths,
<span class="nc" id="L471">                numLeadingNormalizableKeys,</span>
<span class="nc" id="L472">                normalizableKeyPrefixLen,</span>
<span class="nc" id="L473">                inverted);</span>
    }

    private static NullAwareComparator&lt;Object&gt;[] makeNullAware(
            TypeComparator&lt;Object&gt;[] comparators, boolean[] orders) {

<span class="pc bpc" id="L479" title="1 of 2 branches missed.">        checkArgument(comparators.length == orders.length);</span>
<span class="fc" id="L480">        NullAwareComparator&lt;?&gt;[] result = new NullAwareComparator&lt;?&gt;[comparators.length];</span>
<span class="fc bfc" id="L481" title="All 2 branches covered.">        for (int i = 0; i &lt; comparators.length; i++) {</span>
<span class="fc" id="L482">            result[i] = new NullAwareComparator&lt;Object&gt;(comparators[i], orders[i]);</span>
        }
<span class="fc" id="L484">        return (NullAwareComparator&lt;Object&gt;[]) result;</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.7.202105040129</span></div></body></html>