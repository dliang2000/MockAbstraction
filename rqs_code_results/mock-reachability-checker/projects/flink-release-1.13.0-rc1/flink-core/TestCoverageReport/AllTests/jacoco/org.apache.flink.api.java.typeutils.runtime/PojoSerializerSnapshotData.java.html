<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>PojoSerializerSnapshotData.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Flink : Core</a> &gt; <a href="index.source.html" class="el_package">org.apache.flink.api.java.typeutils.runtime</a> &gt; <span class="el_source">PojoSerializerSnapshotData.java</span></div><h1>PojoSerializerSnapshotData.java</h1><pre class="source lang-java linenums">/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * &quot;License&quot;); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.apache.flink.api.java.typeutils.runtime;

import org.apache.flink.annotation.Internal;
import org.apache.flink.api.common.typeutils.TypeSerializer;
import org.apache.flink.api.common.typeutils.TypeSerializerSnapshot;
import org.apache.flink.api.common.typeutils.TypeSerializerUtils;
import org.apache.flink.core.memory.DataInputView;
import org.apache.flink.core.memory.DataOutputView;
import org.apache.flink.util.InstantiationUtil;
import org.apache.flink.util.LinkedOptionalMap;
import org.apache.flink.util.function.BiConsumerWithException;
import org.apache.flink.util.function.BiFunctionWithException;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.io.IOException;
import java.lang.reflect.Field;
import java.util.HashMap;
import java.util.LinkedHashMap;
import java.util.Map;

import static org.apache.flink.util.LinkedOptionalMap.optionalMapOf;
import static org.apache.flink.util.LinkedOptionalMapSerializer.readOptionalMap;
import static org.apache.flink.util.LinkedOptionalMapSerializer.writeOptionalMap;
import static org.apache.flink.util.Preconditions.checkNotNull;

/**
 * This class holds the snapshot content for the {@link PojoSerializer}.
 *
 * &lt;h2&gt;Serialization Format&lt;/hr&gt;
 *
 * &lt;p&gt;The serialization format defined by this class is as follows:
 *
 * &lt;pre&gt;{@code
 * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 * |                                            POJO class name                                          |
 * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 * |      number of fields      |                (field name, field serializer snapshot)                 |
 * |                            |                                pairs                                   |
 * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 * |         number of          |       (registered subclass name, subclass serializer snapshot)         |
 * |   registered subclasses    |                                pairs                                   |
 * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 * |         number of          |     (non-registered subclass name, subclass serializer snapshot)       |
 * | non-registered subclasses  |                                pairs                                   |
 * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 * }&lt;/pre&gt;
 */
@Internal
final class PojoSerializerSnapshotData&lt;T&gt; {

<span class="fc" id="L71">    private static final Logger LOG = LoggerFactory.getLogger(PojoSerializerSnapshotData.class);</span>

    // ---------------------------------------------------------------------------------------------
    //  Factory methods
    // ---------------------------------------------------------------------------------------------

    /**
     * Creates a {@link PojoSerializerSnapshotData} from configuration of a {@link PojoSerializer}.
     *
     * &lt;p&gt;This factory method is meant to be used in regular write paths, i.e. when taking a
     * snapshot of the {@link PojoSerializer}. All registered subclass classes, and non-registered
     * subclass classes are all present. Some POJO fields may be absent, if the originating {@link
     * PojoSerializer} was a restored one with already missing fields, and was never replaced by a
     * new {@link PojoSerializer} (i.e. because the serialized old data was never accessed).
     */
    static &lt;T&gt; PojoSerializerSnapshotData&lt;T&gt; createFrom(
            Class&lt;T&gt; pojoClass,
            Field[] fields,
            TypeSerializer&lt;?&gt;[] fieldSerializers,
            LinkedHashMap&lt;Class&lt;?&gt;, TypeSerializer&lt;?&gt;&gt; registeredSubclassSerializers,
            Map&lt;Class&lt;?&gt;, TypeSerializer&lt;?&gt;&gt; nonRegisteredSubclassSerializers) {

<span class="fc" id="L93">        final LinkedOptionalMap&lt;Field, TypeSerializerSnapshot&lt;?&gt;&gt; fieldSerializerSnapshots =</span>
                new LinkedOptionalMap&lt;&gt;(fields.length);

<span class="fc bfc" id="L96" title="All 2 branches covered.">        for (int i = 0; i &lt; fields.length; i++) {</span>
<span class="fc" id="L97">            Field field = fields[i];</span>
<span class="pc bpc" id="L98" title="1 of 2 branches missed.">            String fieldName = (field == null) ? getDummyNameForMissingField(i) : field.getName();</span>
<span class="fc" id="L99">            fieldSerializerSnapshots.put(</span>
                    fieldName,
                    field,
<span class="fc" id="L102">                    TypeSerializerUtils.snapshotBackwardsCompatible(fieldSerializers[i]));</span>
        }

<span class="fc" id="L105">        LinkedHashMap&lt;Class&lt;?&gt;, TypeSerializerSnapshot&lt;?&gt;&gt; registeredSubclassSerializerSnapshots =</span>
<span class="fc" id="L106">                new LinkedHashMap&lt;&gt;(registeredSubclassSerializers.size());</span>
<span class="fc" id="L107">        registeredSubclassSerializers.forEach(</span>
                (k, v) -&gt;
<span class="fc" id="L109">                        registeredSubclassSerializerSnapshots.put(</span>
<span class="fc" id="L110">                                k, TypeSerializerUtils.snapshotBackwardsCompatible(v)));</span>

<span class="fc" id="L112">        Map&lt;Class&lt;?&gt;, TypeSerializerSnapshot&lt;?&gt;&gt; nonRegisteredSubclassSerializerSnapshots =</span>
<span class="fc" id="L113">                new HashMap&lt;&gt;(nonRegisteredSubclassSerializers.size());</span>
<span class="fc" id="L114">        nonRegisteredSubclassSerializers.forEach(</span>
                (k, v) -&gt;
<span class="fc" id="L116">                        nonRegisteredSubclassSerializerSnapshots.put(</span>
<span class="fc" id="L117">                                k, TypeSerializerUtils.snapshotBackwardsCompatible(v)));</span>

<span class="fc" id="L119">        return new PojoSerializerSnapshotData&lt;&gt;(</span>
                pojoClass,
                fieldSerializerSnapshots,
<span class="fc" id="L122">                optionalMapOf(registeredSubclassSerializerSnapshots, Class::getName),</span>
<span class="fc" id="L123">                optionalMapOf(nonRegisteredSubclassSerializerSnapshots, Class::getName));</span>
    }

    /**
     * Creates a {@link PojoSerializerSnapshotData} from serialized data stream.
     *
     * &lt;p&gt;This factory method is meant to be used in regular read paths, i.e. when reading back a
     * snapshot of the {@link PojoSerializer}. POJO fields, registered subclass classes, and
     * non-registered subclass classes may no longer be present anymore.
     */
    static &lt;T&gt; PojoSerializerSnapshotData&lt;T&gt; createFrom(
            DataInputView in, ClassLoader userCodeClassLoader) throws IOException {
<span class="fc" id="L135">        return PojoSerializerSnapshotData.readSnapshotData(in, userCodeClassLoader);</span>
    }

    /**
     * Creates a {@link PojoSerializerSnapshotData} from existing snapshotted configuration of a
     * {@link PojoSerializer}.
     */
    static &lt;T&gt; PojoSerializerSnapshotData&lt;T&gt; createFrom(
            Class&lt;T&gt; pojoClass,
            Field[] fields,
            TypeSerializerSnapshot&lt;?&gt;[] existingFieldSerializerSnapshots,
            LinkedHashMap&lt;Class&lt;?&gt;, TypeSerializerSnapshot&lt;?&gt;&gt;
                    existingRegisteredSubclassSerializerSnapshots,
            Map&lt;Class&lt;?&gt;, TypeSerializerSnapshot&lt;?&gt;&gt;
                    existingNonRegisteredSubclassSerializerSnapshots) {

<span class="fc" id="L151">        final LinkedOptionalMap&lt;Field, TypeSerializerSnapshot&lt;?&gt;&gt; fieldSerializerSnapshots =</span>
                new LinkedOptionalMap&lt;&gt;(fields.length);
<span class="fc bfc" id="L153" title="All 2 branches covered.">        for (int i = 0; i &lt; fields.length; i++) {</span>
<span class="fc" id="L154">            Field field = fields[i];</span>
<span class="fc bfc" id="L155" title="All 2 branches covered.">            String fieldName = (field == null) ? getDummyNameForMissingField(i) : field.getName();</span>
<span class="fc" id="L156">            fieldSerializerSnapshots.put(fieldName, field, existingFieldSerializerSnapshots[i]);</span>
        }

<span class="fc" id="L159">        return new PojoSerializerSnapshotData&lt;&gt;(</span>
                pojoClass,
                fieldSerializerSnapshots,
<span class="fc" id="L162">                optionalMapOf(existingRegisteredSubclassSerializerSnapshots, Class::getName),</span>
<span class="fc" id="L163">                optionalMapOf(existingNonRegisteredSubclassSerializerSnapshots, Class::getName));</span>
    }

    private Class&lt;T&gt; pojoClass;
    private LinkedOptionalMap&lt;Field, TypeSerializerSnapshot&lt;?&gt;&gt; fieldSerializerSnapshots;
    private LinkedOptionalMap&lt;Class&lt;?&gt;, TypeSerializerSnapshot&lt;?&gt;&gt;
            registeredSubclassSerializerSnapshots;
    private LinkedOptionalMap&lt;Class&lt;?&gt;, TypeSerializerSnapshot&lt;?&gt;&gt;
            nonRegisteredSubclassSerializerSnapshots;

    private PojoSerializerSnapshotData(
            Class&lt;T&gt; typeClass,
            LinkedOptionalMap&lt;Field, TypeSerializerSnapshot&lt;?&gt;&gt; fieldSerializerSnapshots,
            LinkedOptionalMap&lt;Class&lt;?&gt;, TypeSerializerSnapshot&lt;?&gt;&gt;
                    registeredSubclassSerializerSnapshots,
            LinkedOptionalMap&lt;Class&lt;?&gt;, TypeSerializerSnapshot&lt;?&gt;&gt;
<span class="fc" id="L179">                    nonRegisteredSubclassSerializerSnapshots) {</span>

<span class="fc" id="L181">        this.pojoClass = checkNotNull(typeClass);</span>
<span class="fc" id="L182">        this.fieldSerializerSnapshots = checkNotNull(fieldSerializerSnapshots);</span>
<span class="fc" id="L183">        this.registeredSubclassSerializerSnapshots =</span>
<span class="fc" id="L184">                checkNotNull(registeredSubclassSerializerSnapshots);</span>
<span class="fc" id="L185">        this.nonRegisteredSubclassSerializerSnapshots =</span>
<span class="fc" id="L186">                checkNotNull(nonRegisteredSubclassSerializerSnapshots);</span>
<span class="fc" id="L187">    }</span>

    // ---------------------------------------------------------------------------------------------
    //  Snapshot data read / write methods
    // ---------------------------------------------------------------------------------------------

    void writeSnapshotData(DataOutputView out) throws IOException {
<span class="fc" id="L194">        out.writeUTF(pojoClass.getName());</span>
<span class="fc" id="L195">        writeOptionalMap(</span>
                out,
                fieldSerializerSnapshots,
                PojoFieldUtils::writeField,
                TypeSerializerSnapshot::writeVersionedSnapshot);
<span class="fc" id="L200">        writeOptionalMap(</span>
                out,
                registeredSubclassSerializerSnapshots,
<span class="fc" id="L203">                NoOpWriter.noopWriter(),</span>
                TypeSerializerSnapshot::writeVersionedSnapshot);
<span class="fc" id="L205">        writeOptionalMap(</span>
                out,
                nonRegisteredSubclassSerializerSnapshots,
<span class="fc" id="L208">                NoOpWriter.noopWriter(),</span>
                TypeSerializerSnapshot::writeVersionedSnapshot);
<span class="fc" id="L210">    }</span>

    private static &lt;T&gt; PojoSerializerSnapshotData&lt;T&gt; readSnapshotData(
            DataInputView in, ClassLoader userCodeClassLoader) throws IOException {
<span class="fc" id="L214">        Class&lt;T&gt; pojoClass = InstantiationUtil.resolveClassByName(in, userCodeClassLoader);</span>

<span class="fc" id="L216">        LinkedOptionalMap&lt;Field, TypeSerializerSnapshot&lt;?&gt;&gt; fieldSerializerSnapshots =</span>
<span class="fc" id="L217">                readOptionalMap(</span>
<span class="fc" id="L218">                        in, fieldReader(userCodeClassLoader), snapshotReader(userCodeClassLoader));</span>
        LinkedOptionalMap&lt;Class&lt;?&gt;, TypeSerializerSnapshot&lt;?&gt;&gt;
<span class="fc" id="L220">                registeredSubclassSerializerSnapshots =</span>
<span class="fc" id="L221">                        readOptionalMap(</span>
                                in,
<span class="fc" id="L223">                                classReader(userCodeClassLoader),</span>
<span class="fc" id="L224">                                snapshotReader(userCodeClassLoader));</span>
        LinkedOptionalMap&lt;Class&lt;?&gt;, TypeSerializerSnapshot&lt;?&gt;&gt;
<span class="fc" id="L226">                nonRegisteredSubclassSerializerSnapshots =</span>
<span class="fc" id="L227">                        readOptionalMap(</span>
                                in,
<span class="fc" id="L229">                                classReader(userCodeClassLoader),</span>
<span class="fc" id="L230">                                snapshotReader(userCodeClassLoader));</span>

<span class="fc" id="L232">        return new PojoSerializerSnapshotData&lt;&gt;(</span>
                pojoClass,
                fieldSerializerSnapshots,
                registeredSubclassSerializerSnapshots,
                nonRegisteredSubclassSerializerSnapshots);
    }

    // ---------------------------------------------------------------------------------------------
    //  Snapshot data accessors
    // ---------------------------------------------------------------------------------------------

    Class&lt;T&gt; getPojoClass() {
<span class="fc" id="L244">        return pojoClass;</span>
    }

    LinkedOptionalMap&lt;Field, TypeSerializerSnapshot&lt;?&gt;&gt; getFieldSerializerSnapshots() {
<span class="fc" id="L248">        return fieldSerializerSnapshots;</span>
    }

    LinkedOptionalMap&lt;Class&lt;?&gt;, TypeSerializerSnapshot&lt;?&gt;&gt;
            getRegisteredSubclassSerializerSnapshots() {
<span class="fc" id="L253">        return registeredSubclassSerializerSnapshots;</span>
    }

    LinkedOptionalMap&lt;Class&lt;?&gt;, TypeSerializerSnapshot&lt;?&gt;&gt;
            getNonRegisteredSubclassSerializerSnapshots() {
<span class="fc" id="L258">        return nonRegisteredSubclassSerializerSnapshots;</span>
    }

    // ---------------------------------------------------------------------------------------------
    //  Utilities
    // ---------------------------------------------------------------------------------------------

    private static String getDummyNameForMissingField(int fieldIndex) {
<span class="fc" id="L266">        return String.format(&quot;missing-field-at-%d&quot;, fieldIndex);</span>
    }

<span class="fc" id="L269">    private enum NoOpWriter</span>
            implements BiConsumerWithException&lt;DataOutputView, Object, IOException&gt; {
<span class="fc" id="L271">        INSTANCE;</span>

        @Override
<span class="fc" id="L274">        public void accept(DataOutputView dataOutputView, Object o) {}</span>

        @SuppressWarnings(&quot;unchecked&quot;)
        static &lt;K&gt; BiConsumerWithException&lt;DataOutputView, K, IOException&gt; noopWriter() {
<span class="fc" id="L278">            return (BiConsumerWithException&lt;DataOutputView, K, IOException&gt;) INSTANCE;</span>
        }
    }

    private static BiFunctionWithException&lt;DataInputView, String, Field, IOException&gt; fieldReader(
            ClassLoader cl) {
<span class="fc" id="L284">        return (input, fieldName) -&gt; {</span>
            try {
<span class="fc" id="L286">                return PojoFieldUtils.readField(input, cl);</span>
<span class="nc" id="L287">            } catch (Throwable t) {</span>
<span class="nc" id="L288">                LOG.warn(String.format(&quot;Exception while reading field %s&quot;, fieldName), t);</span>
<span class="nc" id="L289">                return null;</span>
            }
        };
    }

    private static BiFunctionWithException&lt;
                    DataInputView, String, TypeSerializerSnapshot&lt;?&gt;, IOException&gt;
            snapshotReader(ClassLoader cl) {
<span class="fc" id="L297">        return (input, unused) -&gt; {</span>
            try {
<span class="fc" id="L299">                return TypeSerializerSnapshot.readVersionedSnapshot(input, cl);</span>
<span class="nc" id="L300">            } catch (Throwable t) {</span>
<span class="nc" id="L301">                LOG.warn(&quot;Exception while reading serializer snapshot.&quot;, t);</span>
<span class="nc" id="L302">                return null;</span>
            }
        };
    }

    private static BiFunctionWithException&lt;DataInputView, String, Class&lt;?&gt;, IOException&gt;
            classReader(ClassLoader cl) {
<span class="fc" id="L309">        return (input, className) -&gt; {</span>
            try {
                // input is ignored because we don't write the actual class as value.
<span class="fc" id="L312">                return Class.forName(className, false, cl);</span>
<span class="nc" id="L313">            } catch (Throwable t) {</span>
<span class="nc" id="L314">                LOG.warn(String.format(&quot;Exception while reading class %s&quot;, className), t);</span>
<span class="nc" id="L315">                return null;</span>
            }
        };
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.7.202105040129</span></div></body></html>