<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>StateDescriptor.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Flink : Core</a> &gt; <a href="index.source.html" class="el_package">org.apache.flink.api.common.state</a> &gt; <span class="el_source">StateDescriptor.java</span></div><h1>StateDescriptor.java</h1><pre class="source lang-java linenums">/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * &quot;License&quot;); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.apache.flink.api.common.state;

import org.apache.flink.annotation.Internal;
import org.apache.flink.annotation.PublicEvolving;
import org.apache.flink.annotation.VisibleForTesting;
import org.apache.flink.api.common.ExecutionConfig;
import org.apache.flink.api.common.typeinfo.TypeInformation;
import org.apache.flink.api.common.typeutils.TypeSerializer;
import org.apache.flink.api.java.typeutils.TypeExtractor;
import org.apache.flink.core.memory.DataInputViewStreamWrapper;
import org.apache.flink.core.memory.DataOutputViewStreamWrapper;
import org.apache.flink.util.Preconditions;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import javax.annotation.Nonnull;
import javax.annotation.Nullable;

import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.io.Serializable;
import java.util.concurrent.atomic.AtomicReference;

import static org.apache.flink.util.Preconditions.checkNotNull;
import static org.apache.flink.util.Preconditions.checkState;

/**
 * Base class for state descriptors. A {@code StateDescriptor} is used for creating partitioned
 * {@link State} in stateful operations.
 *
 * &lt;p&gt;Subclasses must correctly implement {@link #equals(Object)} and {@link #hashCode()}.
 *
 * @param &lt;S&gt; The type of the State objects created from this {@code StateDescriptor}.
 * @param &lt;T&gt; The type of the value of the state object described by this state descriptor.
 */
@PublicEvolving
public abstract class StateDescriptor&lt;S extends State, T&gt; implements Serializable {
<span class="fc" id="L60">    private static final Logger LOG = LoggerFactory.getLogger(StateDescriptor.class);</span>

    /**
     * An enumeration of the types of supported states. Used to identify the state type when writing
     * and restoring checkpoints and savepoints.
     */
    // IMPORTANT: Do not change the order of the elements in this enum, ordinal is used in
    // serialization
<span class="nc" id="L68">    public enum Type {</span>
        /** @deprecated Enum for migrating from old checkpoints/savepoint versions. */
<span class="nc" id="L70">        @Deprecated</span>
        UNKNOWN,
<span class="nc" id="L72">        VALUE,</span>
<span class="nc" id="L73">        LIST,</span>
<span class="nc" id="L74">        REDUCING,</span>
<span class="nc" id="L75">        FOLDING,</span>
<span class="nc" id="L76">        AGGREGATING,</span>
<span class="nc" id="L77">        MAP</span>
    }

    private static final long serialVersionUID = 1L;

    // ------------------------------------------------------------------------

    /** Name that uniquely identifies state created from this StateDescriptor. */
    protected final String name;

    /**
     * The serializer for the type. May be eagerly initialized in the constructor, or lazily once
     * the {@link #initializeSerializerUnlessSet(ExecutionConfig)} method is called.
     */
<span class="fc" id="L91">    private final AtomicReference&lt;TypeSerializer&lt;T&gt;&gt; serializerAtomicReference =</span>
            new AtomicReference&lt;&gt;();

    /**
     * The type information describing the value type. Only used to if the serializer is created
     * lazily.
     */
    @Nullable private TypeInformation&lt;T&gt; typeInfo;

    /** Name for queries against state created from this StateDescriptor. */
    @Nullable private String queryableStateName;

    /** Name for queries against state created from this StateDescriptor. */
<span class="fc" id="L104">    @Nonnull private StateTtlConfig ttlConfig = StateTtlConfig.DISABLED;</span>

    /** The default value returned by the state when no other value is bound to a key. */
    @Nullable protected transient T defaultValue;

    // ------------------------------------------------------------------------

    /**
     * Create a new {@code StateDescriptor} with the given name and the given type serializer.
     *
     * @param name The name of the {@code StateDescriptor}.
     * @param serializer The type serializer for the values in the state.
     * @param defaultValue The default value that will be set when requesting state without setting
     *     a value before.
     */
<span class="fc" id="L119">    protected StateDescriptor(String name, TypeSerializer&lt;T&gt; serializer, @Nullable T defaultValue) {</span>
<span class="fc" id="L120">        this.name = checkNotNull(name, &quot;name must not be null&quot;);</span>
<span class="fc" id="L121">        this.serializerAtomicReference.set(checkNotNull(serializer, &quot;serializer must not be null&quot;));</span>
<span class="fc" id="L122">        this.defaultValue = defaultValue;</span>
<span class="fc" id="L123">    }</span>

    /**
     * Create a new {@code StateDescriptor} with the given name and the given type information.
     *
     * @param name The name of the {@code StateDescriptor}.
     * @param typeInfo The type information for the values in the state.
     * @param defaultValue The default value that will be set when requesting state without setting
     *     a value before.
     */
<span class="fc" id="L133">    protected StateDescriptor(String name, TypeInformation&lt;T&gt; typeInfo, @Nullable T defaultValue) {</span>
<span class="fc" id="L134">        this.name = checkNotNull(name, &quot;name must not be null&quot;);</span>
<span class="fc" id="L135">        this.typeInfo = checkNotNull(typeInfo, &quot;type information must not be null&quot;);</span>
<span class="fc" id="L136">        this.defaultValue = defaultValue;</span>
<span class="fc" id="L137">    }</span>

    /**
     * Create a new {@code StateDescriptor} with the given name and the given type information.
     *
     * &lt;p&gt;If this constructor fails (because it is not possible to describe the type via a class),
     * consider using the {@link #StateDescriptor(String, TypeInformation, Object)} constructor.
     *
     * @param name The name of the {@code StateDescriptor}.
     * @param type The class of the type of values in the state.
     * @param defaultValue The default value that will be set when requesting state without setting
     *     a value before.
     */
<span class="fc" id="L150">    protected StateDescriptor(String name, Class&lt;T&gt; type, @Nullable T defaultValue) {</span>
<span class="fc" id="L151">        this.name = checkNotNull(name, &quot;name must not be null&quot;);</span>
<span class="fc" id="L152">        checkNotNull(type, &quot;type class must not be null&quot;);</span>

        try {
<span class="fc" id="L155">            this.typeInfo = TypeExtractor.createTypeInfo(type);</span>
<span class="nc" id="L156">        } catch (Exception e) {</span>
<span class="nc" id="L157">            throw new RuntimeException(</span>
                    &quot;Could not create the type information for '&quot;
<span class="nc" id="L159">                            + type.getName()</span>
                            + &quot;'. &quot;
                            + &quot;The most common reason is failure to infer the generic type information, due to Java's type erasure. &quot;
                            + &quot;In that case, please pass a 'TypeHint' instead of a class to describe the type. &quot;
                            + &quot;For example, to describe 'Tuple2&lt;String, String&gt;' as a generic type, use &quot;
                            + &quot;'new PravegaDeserializationSchema&lt;&gt;(new TypeHint&lt;Tuple2&lt;String, String&gt;&gt;(){}, serializer);'&quot;,
                    e);
<span class="fc" id="L166">        }</span>

<span class="fc" id="L168">        this.defaultValue = defaultValue;</span>
<span class="fc" id="L169">    }</span>

    // ------------------------------------------------------------------------

    /** Returns the name of this {@code StateDescriptor}. */
    public String getName() {
<span class="fc" id="L175">        return name;</span>
    }

    /** Returns the default value. */
    public T getDefaultValue() {
<span class="pc bpc" id="L180" title="1 of 2 branches missed.">        if (defaultValue != null) {</span>
<span class="fc" id="L181">            TypeSerializer&lt;T&gt; serializer = serializerAtomicReference.get();</span>
<span class="pc bpc" id="L182" title="1 of 2 branches missed.">            if (serializer != null) {</span>
<span class="fc" id="L183">                return serializer.copy(defaultValue);</span>
            } else {
<span class="nc" id="L185">                throw new IllegalStateException(&quot;Serializer not yet initialized.&quot;);</span>
            }
        } else {
<span class="nc" id="L188">            return null;</span>
        }
    }

    /**
     * Returns the {@link TypeSerializer} that can be used to serialize the value in the state. Note
     * that the serializer may initialized lazily and is only guaranteed to exist after calling
     * {@link #initializeSerializerUnlessSet(ExecutionConfig)}.
     */
    public TypeSerializer&lt;T&gt; getSerializer() {
<span class="fc" id="L198">        TypeSerializer&lt;T&gt; serializer = serializerAtomicReference.get();</span>
<span class="fc bfc" id="L199" title="All 2 branches covered.">        if (serializer != null) {</span>
<span class="fc" id="L200">            return serializer.duplicate();</span>
        } else {
<span class="fc" id="L202">            throw new IllegalStateException(&quot;Serializer not yet initialized.&quot;);</span>
        }
    }

    @VisibleForTesting
    final TypeSerializer&lt;T&gt; getOriginalSerializer() {
<span class="fc" id="L208">        TypeSerializer&lt;T&gt; serializer = serializerAtomicReference.get();</span>
<span class="pc bpc" id="L209" title="1 of 2 branches missed.">        if (serializer != null) {</span>
<span class="fc" id="L210">            return serializer;</span>
        } else {
<span class="nc" id="L212">            throw new IllegalStateException(&quot;Serializer not yet initialized.&quot;);</span>
        }
    }

    /**
     * Sets the name for queries of state created from this descriptor.
     *
     * &lt;p&gt;If a name is set, the created state will be published for queries during runtime. The name
     * needs to be unique per job. If there is another state instance published under the same name,
     * the job will fail during runtime.
     *
     * @param queryableStateName State name for queries (unique name per job)
     * @throws IllegalStateException If queryable state name already set
     */
    public void setQueryable(String queryableStateName) {
<span class="nc" id="L227">        Preconditions.checkArgument(</span>
<span class="nc bnc" id="L228" title="All 2 branches missed.">                ttlConfig.getUpdateType() == StateTtlConfig.UpdateType.Disabled,</span>
                &quot;Queryable state is currently not supported with TTL&quot;);
<span class="nc bnc" id="L230" title="All 2 branches missed.">        if (this.queryableStateName == null) {</span>
<span class="nc" id="L231">            this.queryableStateName =</span>
<span class="nc" id="L232">                    Preconditions.checkNotNull(queryableStateName, &quot;Registration name&quot;);</span>
        } else {
<span class="nc" id="L234">            throw new IllegalStateException(&quot;Queryable state name already set&quot;);</span>
        }
<span class="nc" id="L236">    }</span>

    /**
     * Returns the queryable state name.
     *
     * @return Queryable state name or &lt;code&gt;null&lt;/code&gt; if not set.
     */
    @Nullable
    public String getQueryableStateName() {
<span class="nc" id="L245">        return queryableStateName;</span>
    }

    /**
     * Returns whether the state created from this descriptor is queryable.
     *
     * @return &lt;code&gt;true&lt;/code&gt; if state is queryable, &lt;code&gt;false&lt;/code&gt; otherwise.
     */
    public boolean isQueryable() {
<span class="nc bnc" id="L254" title="All 2 branches missed.">        return queryableStateName != null;</span>
    }

    /**
     * Configures optional activation of state time-to-live (TTL).
     *
     * &lt;p&gt;State user value will expire, become unavailable and be cleaned up in storage depending on
     * configured {@link StateTtlConfig}.
     *
     * @param ttlConfig configuration of state TTL
     */
    public void enableTimeToLive(StateTtlConfig ttlConfig) {
<span class="nc" id="L266">        Preconditions.checkNotNull(ttlConfig);</span>
<span class="nc" id="L267">        Preconditions.checkArgument(</span>
<span class="nc bnc" id="L268" title="All 4 branches missed.">                ttlConfig.getUpdateType() != StateTtlConfig.UpdateType.Disabled</span>
                        &amp;&amp; queryableStateName == null,
                &quot;Queryable state is currently not supported with TTL&quot;);
<span class="nc" id="L271">        this.ttlConfig = ttlConfig;</span>
<span class="nc" id="L272">    }</span>

    @Nonnull
    @Internal
    public StateTtlConfig getTtlConfig() {
<span class="nc" id="L277">        return ttlConfig;</span>
    }

    // ------------------------------------------------------------------------

    /**
     * Checks whether the serializer has been initialized. Serializer initialization is lazy, to
     * allow parametrization of serializers with an {@link ExecutionConfig} via {@link
     * #initializeSerializerUnlessSet(ExecutionConfig)}.
     *
     * @return True if the serializers have been initialized, false otherwise.
     */
    public boolean isSerializerInitialized() {
<span class="fc bfc" id="L290" title="All 2 branches covered.">        return serializerAtomicReference.get() != null;</span>
    }

    /**
     * Initializes the serializer, unless it has been initialized before.
     *
     * @param executionConfig The execution config to use when creating the serializer.
     */
    public void initializeSerializerUnlessSet(ExecutionConfig executionConfig) {
<span class="fc bfc" id="L299" title="All 2 branches covered.">        if (serializerAtomicReference.get() == null) {</span>
<span class="pc bpc" id="L300" title="1 of 2 branches missed.">            checkState(typeInfo != null, &quot;no serializer and no type info&quot;);</span>
            // try to instantiate and set the serializer
<span class="fc" id="L302">            TypeSerializer&lt;T&gt; serializer = typeInfo.createSerializer(executionConfig);</span>
            // use cas to assure the singleton
<span class="pc bpc" id="L304" title="1 of 2 branches missed.">            if (!serializerAtomicReference.compareAndSet(null, serializer)) {</span>
<span class="nc" id="L305">                LOG.debug(&quot;Someone else beat us at initializing the serializer.&quot;);</span>
            }
        }
<span class="fc" id="L308">    }</span>

    // ------------------------------------------------------------------------
    //  Standard Utils
    // ------------------------------------------------------------------------

    @Override
    public final int hashCode() {
<span class="fc" id="L316">        return name.hashCode() + 31 * getClass().hashCode();</span>
    }

    @Override
    public final boolean equals(Object o) {
<span class="pc bpc" id="L321" title="1 of 2 branches missed.">        if (o == this) {</span>
<span class="nc" id="L322">            return true;</span>
<span class="pc bpc" id="L323" title="1 of 4 branches missed.">        } else if (o != null &amp;&amp; o.getClass() == this.getClass()) {</span>
<span class="fc" id="L324">            final StateDescriptor&lt;?, ?&gt; that = (StateDescriptor&lt;?, ?&gt;) o;</span>
<span class="fc" id="L325">            return this.name.equals(that.name);</span>
        } else {
<span class="fc" id="L327">            return false;</span>
        }
    }

    @Override
    public String toString() {
<span class="nc" id="L333">        return getClass().getSimpleName()</span>
                + &quot;{name=&quot;
                + name
                + &quot;, defaultValue=&quot;
                + defaultValue
                + &quot;, serializer=&quot;
<span class="nc" id="L339">                + serializerAtomicReference.get()</span>
<span class="nc bnc" id="L340" title="All 2 branches missed.">                + (isQueryable() ? &quot;, queryableStateName=&quot; + queryableStateName + &quot;&quot; : &quot;&quot;)</span>
                + '}';
    }

    public abstract Type getType();

    // ------------------------------------------------------------------------
    //  Serialization
    // ------------------------------------------------------------------------

    private void writeObject(final ObjectOutputStream out) throws IOException {
        // write all the non-transient fields
<span class="fc" id="L352">        out.defaultWriteObject();</span>

        // write the non-serializable default value field
<span class="fc bfc" id="L355" title="All 2 branches covered.">        if (defaultValue == null) {</span>
            // we don't have a default value
<span class="fc" id="L357">            out.writeBoolean(false);</span>
        } else {
<span class="fc" id="L359">            TypeSerializer&lt;T&gt; serializer = serializerAtomicReference.get();</span>
<span class="fc" id="L360">            checkNotNull(serializer, &quot;Serializer not initialized.&quot;);</span>

            // we have a default value
<span class="fc" id="L363">            out.writeBoolean(true);</span>

            byte[] serializedDefaultValue;
<span class="fc" id="L366">            try (ByteArrayOutputStream baos = new ByteArrayOutputStream();</span>
<span class="fc" id="L367">                    DataOutputViewStreamWrapper outView = new DataOutputViewStreamWrapper(baos)) {</span>

<span class="fc" id="L369">                TypeSerializer&lt;T&gt; duplicateSerializer = serializer.duplicate();</span>
<span class="fc" id="L370">                duplicateSerializer.serialize(defaultValue, outView);</span>

<span class="fc" id="L372">                outView.flush();</span>
<span class="fc" id="L373">                serializedDefaultValue = baos.toByteArray();</span>
<span class="nc" id="L374">            } catch (Exception e) {</span>
<span class="nc" id="L375">                throw new IOException(</span>
                        &quot;Unable to serialize default value of type &quot;
<span class="nc" id="L377">                                + defaultValue.getClass().getSimpleName()</span>
                                + &quot;.&quot;,
                        e);
<span class="fc" id="L380">            }</span>

<span class="fc" id="L382">            out.writeInt(serializedDefaultValue.length);</span>
<span class="fc" id="L383">            out.write(serializedDefaultValue);</span>
        }
<span class="fc" id="L385">    }</span>

    private void readObject(final ObjectInputStream in) throws IOException, ClassNotFoundException {
        // read the non-transient fields
<span class="fc" id="L389">        in.defaultReadObject();</span>

        // read the default value field
<span class="fc" id="L392">        boolean hasDefaultValue = in.readBoolean();</span>
<span class="fc bfc" id="L393" title="All 2 branches covered.">        if (hasDefaultValue) {</span>
<span class="fc" id="L394">            TypeSerializer&lt;T&gt; serializer = serializerAtomicReference.get();</span>
<span class="fc" id="L395">            checkNotNull(serializer, &quot;Serializer not initialized.&quot;);</span>

<span class="fc" id="L397">            int size = in.readInt();</span>

<span class="fc" id="L399">            byte[] buffer = new byte[size];</span>

<span class="fc" id="L401">            in.readFully(buffer);</span>

<span class="fc" id="L403">            try (ByteArrayInputStream bais = new ByteArrayInputStream(buffer);</span>
<span class="fc" id="L404">                    DataInputViewStreamWrapper inView = new DataInputViewStreamWrapper(bais)) {</span>

<span class="fc" id="L406">                defaultValue = serializer.deserialize(inView);</span>
<span class="nc" id="L407">            } catch (Exception e) {</span>
<span class="nc" id="L408">                throw new IOException(&quot;Unable to deserialize default value.&quot;, e);</span>
<span class="fc" id="L409">            }</span>
<span class="fc" id="L410">        } else {</span>
<span class="fc" id="L411">            defaultValue = null;</span>
        }
<span class="fc" id="L413">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.7.202105040129</span></div></body></html>