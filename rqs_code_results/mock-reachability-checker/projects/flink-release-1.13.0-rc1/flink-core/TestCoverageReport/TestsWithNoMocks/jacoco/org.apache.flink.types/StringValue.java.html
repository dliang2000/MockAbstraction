<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>StringValue.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Flink : Core</a> &gt; <a href="index.source.html" class="el_package">org.apache.flink.types</a> &gt; <span class="el_source">StringValue.java</span></div><h1>StringValue.java</h1><pre class="source lang-java linenums">/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * &quot;License&quot;); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.apache.flink.types;

import org.apache.flink.annotation.Public;
import org.apache.flink.core.memory.DataInputView;
import org.apache.flink.core.memory.DataOutputView;
import org.apache.flink.core.memory.MemorySegment;

import java.io.DataInput;
import java.io.DataOutput;
import java.io.IOException;
import java.nio.CharBuffer;

import static org.apache.flink.util.Preconditions.checkNotNull;

/**
 * Mutable string data type that implements the Key interface. StringValue encapsulates the basic
 * functionality of a {@link String}, in a serializable and mutable way.
 *
 * &lt;p&gt;The mutability allows to reuse the object inside the user code, also across invocations.
 * Reusing a StringValue object helps to increase the performance, as string objects are rather
 * heavy-weight objects and incur a lot of garbage collection overhead, if created and destroyed en
 * masse.
 *
 * @see org.apache.flink.types.NormalizableKey
 * @see java.lang.String
 * @see java.lang.CharSequence
 */
@Public
public class StringValue
        implements NormalizableKey&lt;StringValue&gt;,
                CharSequence,
                ResettableValue&lt;StringValue&gt;,
                CopyableValue&lt;StringValue&gt;,
                Appendable {
    private static final long serialVersionUID = 1L;

<span class="fc" id="L55">    private static final char[] EMPTY_STRING = new char[0];</span>

    private static final int HIGH_BIT = 0x1 &lt;&lt; 7;

    private static final int HIGH_BIT14 = 0x1 &lt;&lt; 14;

    private static final int HIGH_BIT21 = 0x1 &lt;&lt; 21;

    private static final int HIGH_BIT28 = 0x1 &lt;&lt; 28;

    private static final int HIGH_BIT2 = 0x1 &lt;&lt; 13;

    private static final int HIGH_BIT2_MASK = 0x3 &lt;&lt; 6;

    private static final int SHORT_STRING_MAX_LENGTH = 2048;

<span class="fc" id="L71">    private static final ThreadLocal&lt;char[]&gt; charBuffer =</span>
<span class="fc" id="L72">            ThreadLocal.withInitial(() -&gt; new char[SHORT_STRING_MAX_LENGTH]);</span>

    private char[] value; // character value of the string value, not necessarily completely filled

    private int len; // length of the string value

    private int hashCode; // cache for the hashCode

    // --------------------------------------------------------------------------------------------
    //                                      Constructors
    // --------------------------------------------------------------------------------------------

    /** Initializes the encapsulated String object with an empty string. */
<span class="fc" id="L85">    public StringValue() {</span>
<span class="fc" id="L86">        this.value = EMPTY_STRING;</span>
<span class="fc" id="L87">    }</span>

    /**
     * Initializes this StringValue to the value of the given string.
     *
     * @param value The string containing the value for this StringValue.
     */
<span class="fc" id="L94">    public StringValue(CharSequence value) {</span>
<span class="fc" id="L95">        this.value = EMPTY_STRING;</span>
<span class="fc" id="L96">        setValue(value);</span>
<span class="fc" id="L97">    }</span>

    /**
     * Initializes this StringValue to a copy the given StringValue.
     *
     * @param value The initial value.
     */
<span class="fc" id="L104">    public StringValue(StringValue value) {</span>
<span class="fc" id="L105">        this.value = EMPTY_STRING;</span>
<span class="fc" id="L106">        setValue(value);</span>
<span class="fc" id="L107">    }</span>

    /**
     * Initializes the StringValue to a sub-string of the given StringValue.
     *
     * @param value The string containing the substring.
     * @param offset The offset of the substring.
     * @param len The length of the substring.
     */
<span class="fc" id="L116">    public StringValue(StringValue value, int offset, int len) {</span>
<span class="fc" id="L117">        this.value = EMPTY_STRING;</span>
<span class="fc" id="L118">        setValue(value, offset, len);</span>
<span class="fc" id="L119">    }</span>

    // --------------------------------------------------------------------------------------------
    //                                Getters and Setters
    // --------------------------------------------------------------------------------------------

    /**
     * Sets a new length for the string.
     *
     * @param len The new length.
     */
    public void setLength(int len) {
<span class="nc bnc" id="L131" title="All 4 branches missed.">        if (len &lt; 0 || len &gt; this.len) {</span>
<span class="nc" id="L132">            throw new IllegalArgumentException(&quot;Length must be between 0 and the current length.&quot;);</span>
        }
<span class="nc" id="L134">        this.len = len;</span>
<span class="nc" id="L135">    }</span>
    /**
     * Returns this StringValue's internal character data. The array might be larger than the string
     * which is currently stored in the StringValue.
     *
     * @return The character data.
     */
    public char[] getCharArray() {
<span class="fc" id="L143">        return this.value;</span>
    }

    /**
     * Gets this StringValue as a String.
     *
     * @return A String resembling the contents of this StringValue.
     */
    public String getValue() {
<span class="fc" id="L152">        return toString();</span>
    }

    /**
     * Sets the value of the StringValue to the given string.
     *
     * @param value The new string value.
     */
    public void setValue(CharSequence value) {
<span class="fc" id="L161">        checkNotNull(value);</span>
<span class="fc" id="L162">        setValue(value, 0, value.length());</span>
<span class="fc" id="L163">    }</span>

    /**
     * Sets the value of the StringValue to the given string.
     *
     * @param value The new string value.
     */
    @Override
    public void setValue(StringValue value) {
<span class="fc" id="L172">        checkNotNull(value);</span>
<span class="fc" id="L173">        setValue(value.value, 0, value.len);</span>
<span class="fc" id="L174">    }</span>

    /**
     * Sets the value of the StringValue to a substring of the given string.
     *
     * @param value The new string value.
     * @param offset The position to start the substring.
     * @param len The length of the substring.
     */
    public void setValue(StringValue value, int offset, int len) {
<span class="fc" id="L184">        checkNotNull(value);</span>
<span class="fc" id="L185">        setValue(value.value, offset, len);</span>
<span class="fc" id="L186">    }</span>

    /**
     * Sets the value of the StringValue to a substring of the given string.
     *
     * @param value The new string value.
     * @param offset The position to start the substring.
     * @param len The length of the substring.
     */
    public void setValue(CharSequence value, int offset, int len) {
<span class="fc" id="L196">        checkNotNull(value);</span>
<span class="pc bpc" id="L197" title="3 of 6 branches missed.">        if (offset &lt; 0 || len &lt; 0 || offset &gt; value.length() - len) {</span>
<span class="nc" id="L198">            throw new IndexOutOfBoundsException(</span>
                    &quot;offset: &quot; + offset + &quot; len: &quot; + len + &quot; value.len: &quot; + len);
        }

<span class="fc" id="L202">        ensureSize(len);</span>
<span class="fc" id="L203">        this.len = len;</span>
<span class="fc bfc" id="L204" title="All 2 branches covered.">        for (int i = 0; i &lt; len; i++) {</span>
<span class="fc" id="L205">            this.value[i] = value.charAt(offset + i);</span>
        }
<span class="fc" id="L207">        this.hashCode = 0;</span>
<span class="fc" id="L208">    }</span>

    /**
     * Sets the contents of this string to the contents of the given &lt;tt&gt;CharBuffer&lt;/tt&gt;. The
     * characters between the buffer's current position (inclusive) and the buffer's limit
     * (exclusive) will be stored in this string.
     *
     * @param buffer The character buffer to read the characters from.
     */
    public void setValue(CharBuffer buffer) {
<span class="nc" id="L218">        checkNotNull(buffer);</span>
<span class="nc" id="L219">        final int len = buffer.length();</span>
<span class="nc" id="L220">        ensureSize(len);</span>
<span class="nc" id="L221">        buffer.get(this.value, 0, len);</span>
<span class="nc" id="L222">        this.len = len;</span>
<span class="nc" id="L223">        this.hashCode = 0;</span>
<span class="nc" id="L224">    }</span>

    /**
     * Sets the value of the StringValue to a substring of the given value.
     *
     * @param chars The new string value (as a character array).
     * @param offset The position to start the substring.
     * @param len The length of the substring.
     */
    public void setValue(char[] chars, int offset, int len) {
<span class="fc" id="L234">        checkNotNull(chars);</span>
<span class="pc bpc" id="L235" title="3 of 6 branches missed.">        if (offset &lt; 0 || len &lt; 0 || offset &gt; chars.length - len) {</span>
<span class="nc" id="L236">            throw new IndexOutOfBoundsException();</span>
        }

<span class="fc" id="L239">        ensureSize(len);</span>
<span class="fc" id="L240">        System.arraycopy(chars, offset, this.value, 0, len);</span>
<span class="fc" id="L241">        this.len = len;</span>
<span class="fc" id="L242">        this.hashCode = 0;</span>
<span class="fc" id="L243">    }</span>

    /**
     * Sets the value of this &lt;code&gt;StringValue&lt;/code&gt;, assuming that the binary data is ASCII
     * coded. The n-th character of the &lt;code&gt;StringValue&lt;/code&gt; corresponds directly to the n-th
     * byte in the given array after the offset.
     *
     * @param bytes The binary character data.
     * @param offset The offset in the array.
     * @param len The number of bytes to read from the array.
     */
    public void setValueAscii(byte[] bytes, int offset, int len) {
<span class="pc bpc" id="L255" title="1 of 2 branches missed.">        if (bytes == null) {</span>
<span class="nc" id="L256">            throw new NullPointerException(&quot;Bytes must not be null&quot;);</span>
        }
<span class="pc bpc" id="L258" title="3 of 6 branches missed.">        if (len &lt; 0 || offset &lt; 0 || offset &gt; bytes.length - len) {</span>
<span class="nc" id="L259">            throw new IndexOutOfBoundsException();</span>
        }

<span class="fc" id="L262">        ensureSize(len);</span>
<span class="fc" id="L263">        this.len = len;</span>
<span class="fc" id="L264">        this.hashCode = 0;</span>

<span class="fc" id="L266">        final char[] chars = this.value;</span>

<span class="fc bfc" id="L268" title="All 2 branches covered.">        for (int i = 0, limit = offset + len; offset &lt; limit; offset++, i++) {</span>
<span class="fc" id="L269">            chars[i] = (char) (bytes[offset] &amp; 0xff);</span>
        }
<span class="fc" id="L271">    }</span>

    // --------------------------------------------------------------------------------------------
    //                                    String Methods
    // --------------------------------------------------------------------------------------------

    /**
     * Returns a new &lt;tt&gt;StringValue&lt;/tt&gt;string that is a substring of this string. The substring
     * begins at the given &lt;code&gt;start&lt;/code&gt; index and ends at end of the string
     *
     * @param start The beginning index, inclusive.
     * @return The substring.
     * @exception IndexOutOfBoundsException Thrown, if the start is negative.
     */
    public StringValue substring(int start) {
<span class="nc" id="L286">        return substring(start, this.len);</span>
    }

    /**
     * Returns a new &lt;tt&gt;StringValue&lt;/tt&gt;string that is a substring of this string. The substring
     * begins at the given &lt;code&gt;start&lt;/code&gt; index and ends at &lt;code&gt;end - 1&lt;/code&gt;.
     *
     * @param start The beginning index, inclusive.
     * @param end The ending index, exclusive.
     * @return The substring.
     * @exception IndexOutOfBoundsException Thrown, if the start is negative, or the end is larger
     *     than the length.
     */
    public StringValue substring(int start, int end) {
<span class="nc" id="L300">        return new StringValue(this, start, end - start);</span>
    }

    /**
     * Copies a substring of this string into the given target StringValue. The substring begins at
     * the given &lt;code&gt;start&lt;/code&gt; index and ends at end of the string
     *
     * @param target The StringValue object to copy the substring to.
     * @param start The beginning index, inclusive.
     * @exception IndexOutOfBoundsException Thrown, if the start is negative.
     */
    public void substring(StringValue target, int start) {
<span class="nc" id="L312">        substring(target, start, this.len);</span>
<span class="nc" id="L313">    }</span>

    /**
     * Copies a substring of this string into the given target StringValue. The substring begins at
     * the given &lt;code&gt;start&lt;/code&gt; index and ends at &lt;code&gt;end - 1&lt;/code&gt;.
     *
     * @param target The StringValue object to copy the substring to.
     * @param start The beginning index, inclusive.
     * @param end The ending index, exclusive.
     * @exception IndexOutOfBoundsException Thrown, if the start is negative, or the end is larger
     *     than the length.
     */
    public void substring(StringValue target, int start, int end) {
<span class="nc" id="L326">        target.setValue(this, start, end - start);</span>
<span class="nc" id="L327">    }</span>

    /**
     * Finds any occurrence of the &lt;code&gt;str&lt;/code&gt; character sequence in this StringValue.
     *
     * @return The position of the first occurrence of the search string in the string value, or
     *     &lt;code&gt;-1&lt;/code&gt;, if the character sequence was not found.
     */
    public int find(CharSequence str) {
<span class="nc" id="L336">        return find(str, 0);</span>
    }

    /**
     * Finds any occurrence of the &lt;code&gt;str&lt;/code&gt; character sequence in this StringValue. The
     * search starts at position &lt;code&gt;start&lt;/code&gt;.
     *
     * @return The position of the first occurrence of the search string in the string value, or
     *     &lt;code&gt;-1&lt;/code&gt;, if the character sequence was not found.
     */
    public int find(CharSequence str, int start) {
<span class="nc" id="L347">        final int pLen = this.len;</span>
<span class="nc" id="L348">        final int sLen = str.length();</span>

<span class="nc bnc" id="L350" title="All 2 branches missed.">        if (sLen == 0) {</span>
<span class="nc" id="L351">            throw new IllegalArgumentException(&quot;Cannot find empty string.&quot;);</span>
        }

<span class="nc" id="L354">        int pPos = start;</span>

<span class="nc" id="L356">        final char first = str.charAt(0);</span>

<span class="nc bnc" id="L358" title="All 2 branches missed.">        while (pPos &lt; pLen) {</span>
<span class="nc bnc" id="L359" title="All 2 branches missed.">            if (first == this.value[pPos++]) {</span>
                // matching first character
<span class="nc" id="L361">                final int fallBackPosition = pPos;</span>
<span class="nc" id="L362">                int sPos = 1;</span>
<span class="nc" id="L363">                boolean found = true;</span>

<span class="nc bnc" id="L365" title="All 2 branches missed.">                while (sPos &lt; sLen) {</span>
<span class="nc bnc" id="L366" title="All 2 branches missed.">                    if (pPos &gt;= pLen) {</span>
                        // no more characters in string value
<span class="nc" id="L368">                        pPos = fallBackPosition;</span>
<span class="nc" id="L369">                        found = false;</span>
<span class="nc" id="L370">                        break;</span>
                    }

<span class="nc bnc" id="L373" title="All 2 branches missed.">                    if (str.charAt(sPos++) != this.value[pPos++]) {</span>
<span class="nc" id="L374">                        pPos = fallBackPosition;</span>
<span class="nc" id="L375">                        found = false;</span>
<span class="nc" id="L376">                        break;</span>
                    }
                }
<span class="nc bnc" id="L379" title="All 2 branches missed.">                if (found) {</span>
<span class="nc" id="L380">                    return fallBackPosition - 1;</span>
                }
<span class="nc" id="L382">            }</span>
        }
<span class="nc" id="L384">        return -1;</span>
    }

    /**
     * Checks whether the substring, starting at the specified index, starts with the given prefix
     * string.
     *
     * @param prefix The prefix character sequence.
     * @param startIndex The position to start checking for the prefix.
     * @return True, if this StringValue substring, starting at position &lt;code&gt;startIndex&lt;/code&gt; has
     *     &lt;code&gt;prefix&lt;/code&gt; as its prefix.
     */
    public boolean startsWith(CharSequence prefix, int startIndex) {
<span class="nc" id="L397">        final char[] thisChars = this.value;</span>
<span class="nc" id="L398">        final int pLen = this.len;</span>
<span class="nc" id="L399">        final int sLen = prefix.length();</span>

<span class="nc bnc" id="L401" title="All 4 branches missed.">        if ((startIndex &lt; 0) || (startIndex &gt; pLen - sLen)) {</span>
<span class="nc" id="L402">            return false;</span>
        }

<span class="nc" id="L405">        int sPos = 0;</span>
<span class="nc bnc" id="L406" title="All 2 branches missed.">        while (sPos &lt; sLen) {</span>
<span class="nc bnc" id="L407" title="All 2 branches missed.">            if (thisChars[startIndex++] != prefix.charAt(sPos++)) {</span>
<span class="nc" id="L408">                return false;</span>
            }
        }
<span class="nc" id="L411">        return true;</span>
    }

    /**
     * Checks whether this StringValue starts with the given prefix string.
     *
     * @param prefix The prefix character sequence.
     * @return True, if this StringValue has &lt;code&gt;prefix&lt;/code&gt; as its prefix.
     */
    public boolean startsWith(CharSequence prefix) {
<span class="nc" id="L421">        return startsWith(prefix, 0);</span>
    }

    // --------------------------------------------------------------------------------------------
    // Appendable Methods
    // --------------------------------------------------------------------------------------------

    /*
     * (non-Javadoc)
     * @see java.lang.Appendable#append(char)
     */
    @Override
    public Appendable append(char c) {
<span class="nc" id="L434">        grow(this.len + 1);</span>
<span class="nc" id="L435">        this.value[this.len++] = c;</span>
<span class="nc" id="L436">        return this;</span>
    }

    /*
     * (non-Javadoc)
     * @see java.lang.Appendable#append(java.lang.CharSequence)
     */
    @Override
    public Appendable append(CharSequence csq) {
<span class="nc" id="L445">        append(csq, 0, csq.length());</span>
<span class="nc" id="L446">        return this;</span>
    }

    /*
     * (non-Javadoc)
     * @see java.lang.Appendable#append(java.lang.CharSequence, int, int)
     */
    @Override
    public Appendable append(CharSequence csq, int start, int end) {
<span class="nc" id="L455">        final int otherLen = end - start;</span>
<span class="nc" id="L456">        grow(this.len + otherLen);</span>
<span class="nc bnc" id="L457" title="All 2 branches missed.">        for (int pos = start; pos &lt; end; pos++) {</span>
<span class="nc" id="L458">            this.value[this.len + pos] = csq.charAt(pos);</span>
        }
<span class="nc" id="L460">        this.len += otherLen;</span>
<span class="nc" id="L461">        return this;</span>
    }

    /*
     * (non-Javadoc)
     * @see java.lang.Appendable#append(java.lang.CharSequence)
     */
    public Appendable append(StringValue csq) {
<span class="nc" id="L469">        append(csq, 0, csq.length());</span>
<span class="nc" id="L470">        return this;</span>
    }

    /*
     * (non-Javadoc)
     * @see java.lang.Appendable#append(java.lang.CharSequence, int, int)
     */
    public Appendable append(StringValue csq, int start, int end) {
<span class="nc" id="L478">        final int otherLen = end - start;</span>
<span class="nc" id="L479">        grow(this.len + otherLen);</span>
<span class="nc" id="L480">        System.arraycopy(csq.value, start, this.value, this.len, otherLen);</span>
<span class="nc" id="L481">        this.len += otherLen;</span>
<span class="nc" id="L482">        return this;</span>
    }

    // --------------------------------------------------------------------------------------------
    //                            Serialization / De-Serialization
    // --------------------------------------------------------------------------------------------

    @Override
    public void read(final DataInputView in) throws IOException {
<span class="fc" id="L491">        int len = in.readUnsignedByte();</span>

<span class="fc bfc" id="L493" title="All 2 branches covered.">        if (len &gt;= HIGH_BIT) {</span>
<span class="fc" id="L494">            int shift = 7;</span>
            int curr;
<span class="fc" id="L496">            len = len &amp; 0x7f;</span>
<span class="fc bfc" id="L497" title="All 2 branches covered.">            while ((curr = in.readUnsignedByte()) &gt;= HIGH_BIT) {</span>
<span class="fc" id="L498">                len |= (curr &amp; 0x7f) &lt;&lt; shift;</span>
<span class="fc" id="L499">                shift += 7;</span>
            }
<span class="fc" id="L501">            len |= curr &lt;&lt; shift;</span>
        }

<span class="fc" id="L504">        this.len = len;</span>
<span class="fc" id="L505">        this.hashCode = 0;</span>
<span class="fc" id="L506">        ensureSize(len);</span>
<span class="fc" id="L507">        final char[] data = this.value;</span>

<span class="fc bfc" id="L509" title="All 2 branches covered.">        for (int i = 0; i &lt; len; i++) {</span>
<span class="fc" id="L510">            int c = in.readUnsignedByte();</span>
<span class="fc bfc" id="L511" title="All 2 branches covered.">            if (c &lt; HIGH_BIT) {</span>
<span class="fc" id="L512">                data[i] = (char) c;</span>
            } else {
<span class="fc" id="L514">                int shift = 7;</span>
                int curr;
<span class="fc" id="L516">                c = c &amp; 0x7f;</span>
<span class="fc bfc" id="L517" title="All 2 branches covered.">                while ((curr = in.readUnsignedByte()) &gt;= HIGH_BIT) {</span>
<span class="fc" id="L518">                    c |= (curr &amp; 0x7f) &lt;&lt; shift;</span>
<span class="fc" id="L519">                    shift += 7;</span>
                }
<span class="fc" id="L521">                c |= curr &lt;&lt; shift;</span>
<span class="fc" id="L522">                data[i] = (char) c;</span>
            }
        }
<span class="fc" id="L525">    }</span>

    @Override
    public void write(final DataOutputView out) throws IOException {
<span class="fc" id="L529">        int len = this.len;</span>

        // write the length, variable-length encoded
<span class="fc bfc" id="L532" title="All 2 branches covered.">        while (len &gt;= HIGH_BIT) {</span>
<span class="fc" id="L533">            out.write(len | HIGH_BIT);</span>
<span class="fc" id="L534">            len &gt;&gt;&gt;= 7;</span>
        }
<span class="fc" id="L536">        out.write(len);</span>

        // write the char data, variable length encoded
<span class="fc bfc" id="L539" title="All 2 branches covered.">        for (int i = 0; i &lt; this.len; i++) {</span>
<span class="fc" id="L540">            int c = this.value[i];</span>

<span class="fc bfc" id="L542" title="All 2 branches covered.">            while (c &gt;= HIGH_BIT) {</span>
<span class="fc" id="L543">                out.write(c | HIGH_BIT);</span>
<span class="fc" id="L544">                c &gt;&gt;&gt;= 7;</span>
            }
<span class="fc" id="L546">            out.write(c);</span>
        }
<span class="fc" id="L548">    }</span>

    // --------------------------------------------------------------------------------------------

    @Override
    public String toString() {
<span class="fc" id="L554">        return new String(this.value, 0, this.len);</span>
    }

    @Override
    public int compareTo(StringValue other) {
<span class="fc" id="L559">        int len1 = this.len;</span>
<span class="fc" id="L560">        int len2 = other.len;</span>
<span class="fc" id="L561">        int n = Math.min(len1, len2);</span>
<span class="fc" id="L562">        char[] v1 = value;</span>
<span class="fc" id="L563">        char[] v2 = other.value;</span>

<span class="fc bfc" id="L565" title="All 2 branches covered.">        for (int k = 0; k &lt; n; k++) {</span>
<span class="fc" id="L566">            char c1 = v1[k];</span>
<span class="fc" id="L567">            char c2 = v2[k];</span>
<span class="fc bfc" id="L568" title="All 2 branches covered.">            if (c1 != c2) {</span>
<span class="fc" id="L569">                return c1 - c2;</span>
            }
        }
<span class="fc" id="L572">        return len1 - len2;</span>
    }

    @Override
    public int hashCode() {
<span class="fc" id="L577">        int h = this.hashCode;</span>
<span class="pc bpc" id="L578" title="2 of 4 branches missed.">        if (h == 0 &amp;&amp; this.len &gt; 0) {</span>
<span class="fc" id="L579">            int off = 0;</span>
<span class="fc" id="L580">            char[] val = this.value;</span>
<span class="fc" id="L581">            int len = this.len;</span>
<span class="fc bfc" id="L582" title="All 2 branches covered.">            for (int i = 0; i &lt; len; i++) {</span>
<span class="fc" id="L583">                h = 31 * h + val[off++];</span>
            }
<span class="fc" id="L585">            this.hashCode = h;</span>
        }
<span class="fc" id="L587">        return h;</span>
    }

    @Override
    public boolean equals(final Object obj) {
<span class="fc bfc" id="L592" title="All 2 branches covered.">        if (this == obj) {</span>
<span class="fc" id="L593">            return true;</span>
        }

<span class="pc bpc" id="L596" title="1 of 2 branches missed.">        if (obj instanceof StringValue) {</span>
<span class="fc" id="L597">            final StringValue other = (StringValue) obj;</span>
<span class="fc" id="L598">            int len = this.len;</span>

<span class="pc bpc" id="L600" title="1 of 2 branches missed.">            if (len == other.len) {</span>
<span class="fc" id="L601">                final char[] tc = this.value;</span>
<span class="fc" id="L602">                final char[] oc = other.value;</span>
<span class="fc" id="L603">                int i = 0, j = 0;</span>

<span class="fc bfc" id="L605" title="All 2 branches covered.">                while (len-- != 0) {</span>
<span class="pc bpc" id="L606" title="1 of 2 branches missed.">                    if (tc[i++] != oc[j++]) {</span>
<span class="nc" id="L607">                        return false;</span>
                    }
                }
<span class="fc" id="L610">                return true;</span>
            }
        }
<span class="nc" id="L613">        return false;</span>
    }

    // --------------------------------------------------------------------------------------------
    //                              Char Sequence Implementation
    // --------------------------------------------------------------------------------------------

    @Override
    public int length() {
<span class="fc" id="L622">        return this.len;</span>
    }

    @Override
    public char charAt(int index) {
<span class="fc bfc" id="L627" title="All 2 branches covered.">        if (index &lt; len) {</span>
<span class="fc" id="L628">            return this.value[index];</span>
        } else {
<span class="fc" id="L630">            throw new IndexOutOfBoundsException();</span>
        }
    }

    @Override
    public CharSequence subSequence(int start, int end) {
<span class="fc" id="L636">        return new StringValue(this, start, end - start);</span>
    }

    // --------------------------------------------------------------------------------------------
    //                                   Normalized Key
    // --------------------------------------------------------------------------------------------

    @Override
    public int getMaxNormalizedKeyLen() {
<span class="fc" id="L645">        return Integer.MAX_VALUE;</span>
    }

    @Override
    public void copyNormalizedKey(MemorySegment target, int offset, int len) {
        // cache variables on stack, avoid repeated dereferencing of &quot;this&quot;
<span class="fc" id="L651">        final char[] chars = this.value;</span>
<span class="fc" id="L652">        final int limit = offset + len;</span>
<span class="fc" id="L653">        final int end = this.len;</span>
<span class="fc" id="L654">        int pos = 0;</span>

<span class="fc bfc" id="L656" title="All 4 branches covered.">        while (pos &lt; end &amp;&amp; offset &lt; limit) {</span>
<span class="fc" id="L657">            char c = chars[pos++];</span>
<span class="fc bfc" id="L658" title="All 2 branches covered.">            if (c &lt; HIGH_BIT) {</span>
<span class="fc" id="L659">                target.put(offset++, (byte) c);</span>
<span class="pc bpc" id="L660" title="1 of 2 branches missed.">            } else if (c &lt; HIGH_BIT2) {</span>
<span class="fc" id="L661">                target.put(offset++, (byte) ((c &gt;&gt;&gt; 7) | HIGH_BIT));</span>
<span class="pc bpc" id="L662" title="1 of 2 branches missed.">                if (offset &lt; limit) {</span>
<span class="fc" id="L663">                    target.put(offset++, (byte) c);</span>
                }
            } else {
<span class="nc" id="L666">                target.put(offset++, (byte) ((c &gt;&gt;&gt; 10) | HIGH_BIT2_MASK));</span>
<span class="nc bnc" id="L667" title="All 2 branches missed.">                if (offset &lt; limit) {</span>
<span class="nc" id="L668">                    target.put(offset++, (byte) (c &gt;&gt;&gt; 2));</span>
                }
<span class="nc bnc" id="L670" title="All 2 branches missed.">                if (offset &lt; limit) {</span>
<span class="nc" id="L671">                    target.put(offset++, (byte) c);</span>
                }
            }
<span class="fc" id="L674">        }</span>
<span class="fc bfc" id="L675" title="All 2 branches covered.">        while (offset &lt; limit) {</span>
<span class="fc" id="L676">            target.put(offset++, (byte) 0);</span>
        }
<span class="fc" id="L678">    }</span>

    // --------------------------------------------------------------------------------------------

    @Override
    public int getBinaryLength() {
<span class="nc" id="L684">        return -1;</span>
    }

    @Override
    public void copyTo(StringValue target) {
<span class="fc" id="L689">        target.len = this.len;</span>
<span class="fc" id="L690">        target.hashCode = this.hashCode;</span>
<span class="fc" id="L691">        target.ensureSize(this.len);</span>
<span class="fc" id="L692">        System.arraycopy(this.value, 0, target.value, 0, this.len);</span>
<span class="fc" id="L693">    }</span>

    @Override
    public StringValue copy() {
<span class="fc" id="L697">        return new StringValue(this);</span>
    }

    @Override
    public void copy(DataInputView in, DataOutputView target) throws IOException {
<span class="fc" id="L702">        int len = in.readUnsignedByte();</span>
<span class="fc" id="L703">        target.writeByte(len);</span>

<span class="fc bfc" id="L705" title="All 2 branches covered.">        if (len &gt;= HIGH_BIT) {</span>
<span class="fc" id="L706">            int shift = 7;</span>
            int curr;
<span class="fc" id="L708">            len = len &amp; 0x7f;</span>
<span class="fc bfc" id="L709" title="All 2 branches covered.">            while ((curr = in.readUnsignedByte()) &gt;= HIGH_BIT) {</span>
<span class="fc" id="L710">                len |= (curr &amp; 0x7f) &lt;&lt; shift;</span>
<span class="fc" id="L711">                shift += 7;</span>
<span class="fc" id="L712">                target.writeByte(curr);</span>
            }
<span class="fc" id="L714">            len |= curr &lt;&lt; shift;</span>
<span class="fc" id="L715">            target.writeByte(curr);</span>
        }

<span class="fc bfc" id="L718" title="All 2 branches covered.">        for (int i = 0; i &lt; len; i++) {</span>
<span class="fc" id="L719">            int c = in.readUnsignedByte();</span>
<span class="fc" id="L720">            target.writeByte(c);</span>
<span class="fc bfc" id="L721" title="All 2 branches covered.">            while (c &gt;= HIGH_BIT) {</span>
<span class="fc" id="L722">                c = in.readUnsignedByte();</span>
<span class="fc" id="L723">                target.writeByte(c);</span>
            }
        }
<span class="fc" id="L726">    }</span>

    // --------------------------------------------------------------------------------------------
    //                                      Utilities
    // --------------------------------------------------------------------------------------------

    private void ensureSize(int size) {
<span class="fc bfc" id="L733" title="All 2 branches covered.">        if (this.value.length &lt; size) {</span>
<span class="fc" id="L734">            this.value = new char[size];</span>
        }
<span class="fc" id="L736">    }</span>

    /** Grow and retain content. */
    private void grow(int size) {
<span class="nc bnc" id="L740" title="All 2 branches missed.">        if (this.value.length &lt; size) {</span>
<span class="nc" id="L741">            char[] value = new char[Math.max(this.value.length * 3 / 2, size)];</span>
<span class="nc" id="L742">            System.arraycopy(this.value, 0, value, 0, this.len);</span>
<span class="nc" id="L743">            this.value = value;</span>
        }
<span class="nc" id="L745">    }</span>

    // --------------------------------------------------------------------------------------------
    //                           Static Helpers for String Serialization
    // --------------------------------------------------------------------------------------------

    public static String readString(DataInput in) throws IOException {
        // the length we read is offset by one, because a length of zero indicates a null value
<span class="fc" id="L753">        int len = in.readUnsignedByte();</span>

<span class="fc bfc" id="L755" title="All 2 branches covered.">        if (len == 0) {</span>
<span class="fc" id="L756">            return null;</span>
        }

<span class="fc bfc" id="L759" title="All 2 branches covered.">        if (len &gt;= HIGH_BIT) {</span>
<span class="fc" id="L760">            int shift = 7;</span>
            int curr;
<span class="fc" id="L762">            len = len &amp; 0x7f;</span>
<span class="fc bfc" id="L763" title="All 2 branches covered.">            while ((curr = in.readUnsignedByte()) &gt;= HIGH_BIT) {</span>
<span class="fc" id="L764">                len |= (curr &amp; 0x7f) &lt;&lt; shift;</span>
<span class="fc" id="L765">                shift += 7;</span>
            }
<span class="fc" id="L767">            len |= curr &lt;&lt; shift;</span>
        }

        // subtract one for the null length
<span class="fc" id="L771">        len -= 1;</span>

        final char[] data;
<span class="fc bfc" id="L774" title="All 2 branches covered.">        if (len &gt; SHORT_STRING_MAX_LENGTH) {</span>
<span class="fc" id="L775">            data = new char[len];</span>
        } else {
<span class="fc" id="L777">            data = charBuffer.get();</span>
        }

<span class="fc bfc" id="L780" title="All 2 branches covered.">        for (int i = 0; i &lt; len; i++) {</span>
<span class="fc" id="L781">            int c = in.readUnsignedByte();</span>
<span class="fc bfc" id="L782" title="All 2 branches covered.">            if (c &gt;= HIGH_BIT) {</span>
<span class="fc" id="L783">                int shift = 7;</span>
                int curr;
<span class="fc" id="L785">                c = c &amp; 0x7f;</span>
<span class="fc bfc" id="L786" title="All 2 branches covered.">                while ((curr = in.readUnsignedByte()) &gt;= HIGH_BIT) {</span>
<span class="fc" id="L787">                    c |= (curr &amp; 0x7f) &lt;&lt; shift;</span>
<span class="fc" id="L788">                    shift += 7;</span>
                }
<span class="fc" id="L790">                c |= curr &lt;&lt; shift;</span>
            }
<span class="fc" id="L792">            data[i] = (char) c;</span>
        }

<span class="fc" id="L795">        return new String(data, 0, len);</span>
    }

    public static final void writeString(CharSequence cs, DataOutput out) throws IOException {
<span class="fc bfc" id="L799" title="All 2 branches covered.">        if (cs != null) {</span>
<span class="fc" id="L800">            int strlen = cs.length();</span>

            // the length we write is offset by one, because a length of zero indicates a null value
<span class="fc" id="L803">            int lenToWrite = strlen + 1;</span>
<span class="pc bpc" id="L804" title="1 of 2 branches missed.">            if (lenToWrite &lt; 0) {</span>
<span class="nc" id="L805">                throw new IllegalArgumentException(&quot;CharSequence is too long.&quot;);</span>
            }

            // string is prefixed by it's variable length encoded size, which can take 1-5 bytes.
<span class="fc bfc" id="L809" title="All 2 branches covered.">            if (lenToWrite &lt; HIGH_BIT) {</span>
<span class="fc" id="L810">                out.write((byte) lenToWrite);</span>
<span class="fc bfc" id="L811" title="All 2 branches covered.">            } else if (lenToWrite &lt; HIGH_BIT14) {</span>
<span class="fc" id="L812">                out.write((lenToWrite | HIGH_BIT));</span>
<span class="fc" id="L813">                out.write((lenToWrite &gt;&gt;&gt; 7));</span>
<span class="pc bpc" id="L814" title="1 of 2 branches missed.">            } else if (lenToWrite &lt; HIGH_BIT21) {</span>
<span class="fc" id="L815">                out.write(lenToWrite | HIGH_BIT);</span>
<span class="fc" id="L816">                out.write((lenToWrite &gt;&gt;&gt; 7) | HIGH_BIT);</span>
<span class="fc" id="L817">                out.write((lenToWrite &gt;&gt;&gt; 14));</span>
<span class="nc bnc" id="L818" title="All 2 branches missed.">            } else if (lenToWrite &lt; HIGH_BIT28) {</span>
<span class="nc" id="L819">                out.write(lenToWrite | HIGH_BIT);</span>
<span class="nc" id="L820">                out.write((lenToWrite &gt;&gt;&gt; 7) | HIGH_BIT);</span>
<span class="nc" id="L821">                out.write((lenToWrite &gt;&gt;&gt; 14) | HIGH_BIT);</span>
<span class="nc" id="L822">                out.write((lenToWrite &gt;&gt;&gt; 21));</span>
            } else {
<span class="nc" id="L824">                out.write(lenToWrite | HIGH_BIT);</span>
<span class="nc" id="L825">                out.write((lenToWrite &gt;&gt;&gt; 7) | HIGH_BIT);</span>
<span class="nc" id="L826">                out.write((lenToWrite &gt;&gt;&gt; 14) | HIGH_BIT);</span>
<span class="nc" id="L827">                out.write((lenToWrite &gt;&gt;&gt; 21) | HIGH_BIT);</span>
<span class="nc" id="L828">                out.write((lenToWrite &gt;&gt;&gt; 28));</span>
            }

            // write the char data, variable length encoded
<span class="fc bfc" id="L832" title="All 2 branches covered.">            for (int i = 0; i &lt; strlen; i++) {</span>
<span class="fc" id="L833">                int c = cs.charAt(i);</span>

                // manual loop unroll, as it performs much better on jdk8
<span class="fc bfc" id="L836" title="All 2 branches covered.">                if (c &lt; HIGH_BIT) {</span>
<span class="fc" id="L837">                    out.write(c);</span>
<span class="fc bfc" id="L838" title="All 2 branches covered.">                } else if (c &lt; HIGH_BIT14) {</span>
<span class="fc" id="L839">                    out.write(c | HIGH_BIT);</span>
<span class="fc" id="L840">                    out.write((c &gt;&gt;&gt; 7));</span>
                } else {
<span class="fc" id="L842">                    out.write(c | HIGH_BIT);</span>
<span class="fc" id="L843">                    out.write((c &gt;&gt;&gt; 7) | HIGH_BIT);</span>
<span class="fc" id="L844">                    out.write((c &gt;&gt;&gt; 14));</span>
                }
            }
<span class="fc" id="L847">        } else {</span>
<span class="fc" id="L848">            out.write(0);</span>
        }
<span class="fc" id="L850">    }</span>

    public static final void copyString(DataInput in, DataOutput out) throws IOException {
<span class="fc" id="L853">        int len = in.readUnsignedByte();</span>
<span class="fc" id="L854">        out.writeByte(len);</span>

<span class="fc bfc" id="L856" title="All 2 branches covered.">        if (len &gt;= HIGH_BIT) {</span>
<span class="fc" id="L857">            int shift = 7;</span>
            int curr;
<span class="fc" id="L859">            len = len &amp; 0x7f;</span>
<span class="fc bfc" id="L860" title="All 2 branches covered.">            while ((curr = in.readUnsignedByte()) &gt;= HIGH_BIT) {</span>
<span class="fc" id="L861">                out.writeByte(curr);</span>
<span class="fc" id="L862">                len |= (curr &amp; 0x7f) &lt;&lt; shift;</span>
<span class="fc" id="L863">                shift += 7;</span>
            }
<span class="fc" id="L865">            out.writeByte(curr);</span>
<span class="fc" id="L866">            len |= curr &lt;&lt; shift;</span>
        }

        // note that the length is one larger than the actual length (length 0 is a null string, not
        // a zero length string)
<span class="fc" id="L871">        len--;</span>

<span class="fc bfc" id="L873" title="All 2 branches covered.">        for (int i = 0; i &lt; len; i++) {</span>
<span class="fc" id="L874">            int c = in.readUnsignedByte();</span>
<span class="fc" id="L875">            out.writeByte(c);</span>
<span class="fc bfc" id="L876" title="All 2 branches covered.">            while (c &gt;= HIGH_BIT) {</span>
<span class="fc" id="L877">                c = in.readUnsignedByte();</span>
<span class="fc" id="L878">                out.writeByte(c);</span>
            }
        }
<span class="fc" id="L881">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.7.202105040129</span></div></body></html>