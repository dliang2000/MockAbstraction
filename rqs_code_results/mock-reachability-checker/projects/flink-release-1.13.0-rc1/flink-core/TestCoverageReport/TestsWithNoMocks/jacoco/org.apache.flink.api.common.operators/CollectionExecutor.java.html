<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>CollectionExecutor.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Flink : Core</a> &gt; <a href="index.source.html" class="el_package">org.apache.flink.api.common.operators</a> &gt; <span class="el_source">CollectionExecutor.java</span></div><h1>CollectionExecutor.java</h1><pre class="source lang-java linenums">/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * &quot;License&quot;); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.apache.flink.api.common.operators;

import org.apache.flink.annotation.Internal;
import org.apache.flink.api.common.ExecutionConfig;
import org.apache.flink.api.common.InvalidProgramException;
import org.apache.flink.api.common.JobExecutionResult;
import org.apache.flink.api.common.JobID;
import org.apache.flink.api.common.Plan;
import org.apache.flink.api.common.TaskInfo;
import org.apache.flink.api.common.accumulators.Accumulator;
import org.apache.flink.api.common.accumulators.AccumulatorHelper;
import org.apache.flink.api.common.aggregators.Aggregator;
import org.apache.flink.api.common.aggregators.AggregatorWithName;
import org.apache.flink.api.common.aggregators.ConvergenceCriterion;
import org.apache.flink.api.common.cache.DistributedCache;
import org.apache.flink.api.common.functions.IterationRuntimeContext;
import org.apache.flink.api.common.functions.RichFunction;
import org.apache.flink.api.common.functions.util.RuntimeUDFContext;
import org.apache.flink.api.common.io.RichInputFormat;
import org.apache.flink.api.common.io.RichOutputFormat;
import org.apache.flink.api.common.operators.base.BulkIterationBase;
import org.apache.flink.api.common.operators.base.BulkIterationBase.PartialSolutionPlaceHolder;
import org.apache.flink.api.common.operators.base.DeltaIterationBase;
import org.apache.flink.api.common.operators.base.DeltaIterationBase.SolutionSetPlaceHolder;
import org.apache.flink.api.common.operators.base.DeltaIterationBase.WorksetPlaceHolder;
import org.apache.flink.api.common.operators.util.TypeComparable;
import org.apache.flink.api.common.typeinfo.TypeInformation;
import org.apache.flink.api.common.typeutils.CompositeType;
import org.apache.flink.api.common.typeutils.TypeComparator;
import org.apache.flink.core.fs.FileSystem;
import org.apache.flink.core.fs.Path;
import org.apache.flink.core.fs.local.LocalFileSystem;
import org.apache.flink.metrics.MetricGroup;
import org.apache.flink.metrics.groups.UnregisteredMetricsGroup;
import org.apache.flink.types.Value;
import org.apache.flink.util.OptionalFailure;
import org.apache.flink.util.Visitor;

import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.HashMap;
import java.util.HashSet;
import java.util.LinkedHashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.Future;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.TimeoutException;

/** Execution utility for serial, local, collection-based executions of Flink programs. */
@Internal
public class CollectionExecutor {

    private final Map&lt;Operator&lt;?&gt;, List&lt;?&gt;&gt; intermediateResults;

    private final Map&lt;String, Accumulator&lt;?, ?&gt;&gt; accumulators;

    private final Map&lt;String, Future&lt;Path&gt;&gt; cachedFiles;

    private final Map&lt;String, Value&gt; previousAggregates;

    private final Map&lt;String, Aggregator&lt;?&gt;&gt; aggregators;

    private final ClassLoader userCodeClassLoader;

    private final ExecutionConfig executionConfig;

    private int iterationSuperstep;

    // --------------------------------------------------------------------------------------------

<span class="nc" id="L93">    public CollectionExecutor(ExecutionConfig executionConfig) {</span>
<span class="nc" id="L94">        this.executionConfig = executionConfig;</span>

<span class="nc" id="L96">        this.intermediateResults = new HashMap&lt;Operator&lt;?&gt;, List&lt;?&gt;&gt;();</span>
<span class="nc" id="L97">        this.accumulators = new HashMap&lt;String, Accumulator&lt;?, ?&gt;&gt;();</span>
<span class="nc" id="L98">        this.previousAggregates = new HashMap&lt;String, Value&gt;();</span>
<span class="nc" id="L99">        this.aggregators = new HashMap&lt;String, Aggregator&lt;?&gt;&gt;();</span>
<span class="nc" id="L100">        this.cachedFiles = new HashMap&lt;String, Future&lt;Path&gt;&gt;();</span>
<span class="nc" id="L101">        this.userCodeClassLoader = Thread.currentThread().getContextClassLoader();</span>
<span class="nc" id="L102">    }</span>

    // --------------------------------------------------------------------------------------------
    //  General execution methods
    // --------------------------------------------------------------------------------------------

    public JobExecutionResult execute(Plan program) throws Exception {
<span class="nc" id="L109">        long startTime = System.currentTimeMillis();</span>
<span class="nc bnc" id="L110" title="All 2 branches missed.">        JobID jobID = program.getJobId() == null ? new JobID() : program.getJobId();</span>

<span class="nc" id="L112">        initCache(program.getCachedFiles());</span>
<span class="nc" id="L113">        Collection&lt;? extends GenericDataSinkBase&lt;?&gt;&gt; sinks = program.getDataSinks();</span>
<span class="nc bnc" id="L114" title="All 2 branches missed.">        for (Operator&lt;?&gt; sink : sinks) {</span>
<span class="nc" id="L115">            execute(sink, jobID);</span>
<span class="nc" id="L116">        }</span>

<span class="nc" id="L118">        long endTime = System.currentTimeMillis();</span>
<span class="nc" id="L119">        Map&lt;String, OptionalFailure&lt;Object&gt;&gt; accumulatorResults =</span>
<span class="nc" id="L120">                AccumulatorHelper.toResultMap(accumulators);</span>
<span class="nc" id="L121">        return new JobExecutionResult(null, endTime - startTime, accumulatorResults);</span>
    }

    private void initCache(Set&lt;Map.Entry&lt;String, DistributedCache.DistributedCacheEntry&gt;&gt; files) {
<span class="nc bnc" id="L125" title="All 2 branches missed.">        for (Map.Entry&lt;String, DistributedCache.DistributedCacheEntry&gt; file : files) {</span>
<span class="nc" id="L126">            Future&lt;Path&gt; doNothing = new CompletedFuture(new Path(file.getValue().filePath));</span>
<span class="nc" id="L127">            cachedFiles.put(file.getKey(), doNothing);</span>
<span class="nc" id="L128">        }</span>
<span class="nc" id="L129">    };</span>

    private List&lt;?&gt; execute(Operator&lt;?&gt; operator, JobID jobID) throws Exception {
<span class="nc" id="L132">        return execute(operator, 0, jobID);</span>
    }

    private List&lt;?&gt; execute(Operator&lt;?&gt; operator, int superStep, JobID jobID) throws Exception {
<span class="nc" id="L136">        List&lt;?&gt; result = this.intermediateResults.get(operator);</span>

        // if it has already been computed, use the cached variant
<span class="nc bnc" id="L139" title="All 2 branches missed.">        if (result != null) {</span>
<span class="nc" id="L140">            return result;</span>
        }

<span class="nc bnc" id="L143" title="All 2 branches missed.">        if (operator instanceof BulkIterationBase) {</span>
<span class="nc" id="L144">            result = executeBulkIteration((BulkIterationBase&lt;?&gt;) operator, jobID);</span>
<span class="nc bnc" id="L145" title="All 2 branches missed.">        } else if (operator instanceof DeltaIterationBase) {</span>
<span class="nc" id="L146">            result = executeDeltaIteration((DeltaIterationBase&lt;?, ?&gt;) operator, jobID);</span>
<span class="nc bnc" id="L147" title="All 2 branches missed.">        } else if (operator instanceof SingleInputOperator) {</span>
<span class="nc" id="L148">            result =</span>
<span class="nc" id="L149">                    executeUnaryOperator((SingleInputOperator&lt;?, ?, ?&gt;) operator, superStep, jobID);</span>
<span class="nc bnc" id="L150" title="All 2 branches missed.">        } else if (operator instanceof DualInputOperator) {</span>
<span class="nc" id="L151">            result =</span>
<span class="nc" id="L152">                    executeBinaryOperator(</span>
                            (DualInputOperator&lt;?, ?, ?, ?&gt;) operator, superStep, jobID);
<span class="nc bnc" id="L154" title="All 2 branches missed.">        } else if (operator instanceof GenericDataSourceBase) {</span>
<span class="nc" id="L155">            result = executeDataSource((GenericDataSourceBase&lt;?, ?&gt;) operator, superStep, jobID);</span>
<span class="nc bnc" id="L156" title="All 2 branches missed.">        } else if (operator instanceof GenericDataSinkBase) {</span>
<span class="nc" id="L157">            executeDataSink((GenericDataSinkBase&lt;?&gt;) operator, superStep, jobID);</span>
<span class="nc" id="L158">            result = Collections.emptyList();</span>
        } else {
<span class="nc" id="L160">            throw new RuntimeException(&quot;Cannot execute operator &quot; + operator.getClass().getName());</span>
        }

<span class="nc" id="L163">        this.intermediateResults.put(operator, result);</span>

<span class="nc" id="L165">        return result;</span>
    }

    // --------------------------------------------------------------------------------------------
    //  Operator class specific execution methods
    // --------------------------------------------------------------------------------------------

    private &lt;IN&gt; void executeDataSink(GenericDataSinkBase&lt;?&gt; sink, int superStep, JobID jobID)
            throws Exception {
<span class="nc" id="L174">        Operator&lt;?&gt; inputOp = sink.getInput();</span>
<span class="nc bnc" id="L175" title="All 2 branches missed.">        if (inputOp == null) {</span>
<span class="nc" id="L176">            throw new InvalidProgramException(&quot;The data sink &quot; + sink.getName() + &quot; has no input.&quot;);</span>
        }

        @SuppressWarnings(&quot;unchecked&quot;)
<span class="nc" id="L180">        List&lt;IN&gt; input = (List&lt;IN&gt;) execute(inputOp, jobID);</span>

        @SuppressWarnings(&quot;unchecked&quot;)
<span class="nc" id="L183">        GenericDataSinkBase&lt;IN&gt; typedSink = (GenericDataSinkBase&lt;IN&gt;) sink;</span>

        // build the runtime context and compute broadcast variables, if necessary
<span class="nc" id="L186">        TaskInfo taskInfo = new TaskInfo(typedSink.getName(), 1, 0, 1, 0);</span>
        RuntimeUDFContext ctx;

<span class="nc" id="L189">        MetricGroup metrics = new UnregisteredMetricsGroup();</span>

<span class="nc bnc" id="L191" title="All 2 branches missed.">        if (RichOutputFormat.class.isAssignableFrom(</span>
<span class="nc" id="L192">                typedSink.getUserCodeWrapper().getUserCodeClass())) {</span>
<span class="nc bnc" id="L193" title="All 2 branches missed.">            ctx =</span>
                    superStep == 0
                            ? new RuntimeUDFContext(
                                    taskInfo,
                                    userCodeClassLoader,
                                    executionConfig,
                                    cachedFiles,
                                    accumulators,
                                    metrics,
                                    jobID)
                            : new IterationRuntimeUDFContext(
                                    taskInfo,
                                    userCodeClassLoader,
                                    executionConfig,
                                    cachedFiles,
                                    accumulators,
                                    metrics,
                                    jobID);
        } else {
<span class="nc" id="L212">            ctx = null;</span>
        }

<span class="nc" id="L215">        typedSink.executeOnCollections(input, ctx, executionConfig);</span>
<span class="nc" id="L216">    }</span>

    private &lt;OUT&gt; List&lt;OUT&gt; executeDataSource(
            GenericDataSourceBase&lt;?, ?&gt; source, int superStep, JobID jobID) throws Exception {
        @SuppressWarnings(&quot;unchecked&quot;)
<span class="nc" id="L221">        GenericDataSourceBase&lt;OUT, ?&gt; typedSource = (GenericDataSourceBase&lt;OUT, ?&gt;) source;</span>
        // build the runtime context and compute broadcast variables, if necessary
<span class="nc" id="L223">        TaskInfo taskInfo = new TaskInfo(typedSource.getName(), 1, 0, 1, 0);</span>

        RuntimeUDFContext ctx;

<span class="nc" id="L227">        MetricGroup metrics = new UnregisteredMetricsGroup();</span>
<span class="nc bnc" id="L228" title="All 2 branches missed.">        if (RichInputFormat.class.isAssignableFrom(</span>
<span class="nc" id="L229">                typedSource.getUserCodeWrapper().getUserCodeClass())) {</span>
<span class="nc bnc" id="L230" title="All 2 branches missed.">            ctx =</span>
                    superStep == 0
                            ? new RuntimeUDFContext(
                                    taskInfo,
                                    userCodeClassLoader,
                                    executionConfig,
                                    cachedFiles,
                                    accumulators,
                                    metrics,
                                    jobID)
                            : new IterationRuntimeUDFContext(
                                    taskInfo,
                                    userCodeClassLoader,
                                    executionConfig,
                                    cachedFiles,
                                    accumulators,
                                    metrics,
                                    jobID);
        } else {
<span class="nc" id="L249">            ctx = null;</span>
        }
<span class="nc" id="L251">        return typedSource.executeOnCollections(ctx, executionConfig);</span>
    }

    private &lt;IN, OUT&gt; List&lt;OUT&gt; executeUnaryOperator(
            SingleInputOperator&lt;?, ?, ?&gt; operator, int superStep, JobID jobID) throws Exception {
<span class="nc" id="L256">        Operator&lt;?&gt; inputOp = operator.getInput();</span>
<span class="nc bnc" id="L257" title="All 2 branches missed.">        if (inputOp == null) {</span>
<span class="nc" id="L258">            throw new InvalidProgramException(</span>
<span class="nc" id="L259">                    &quot;The unary operation &quot; + operator.getName() + &quot; has no input.&quot;);</span>
        }

        @SuppressWarnings(&quot;unchecked&quot;)
<span class="nc" id="L263">        List&lt;IN&gt; inputData = (List&lt;IN&gt;) execute(inputOp, superStep, jobID);</span>

        @SuppressWarnings(&quot;unchecked&quot;)
<span class="nc" id="L266">        SingleInputOperator&lt;IN, OUT, ?&gt; typedOp = (SingleInputOperator&lt;IN, OUT, ?&gt;) operator;</span>

        // build the runtime context and compute broadcast variables, if necessary
<span class="nc" id="L269">        TaskInfo taskInfo = new TaskInfo(typedOp.getName(), 1, 0, 1, 0);</span>
        RuntimeUDFContext ctx;

<span class="nc" id="L272">        MetricGroup metrics = new UnregisteredMetricsGroup();</span>
<span class="nc bnc" id="L273" title="All 2 branches missed.">        if (RichFunction.class.isAssignableFrom(typedOp.getUserCodeWrapper().getUserCodeClass())) {</span>
<span class="nc bnc" id="L274" title="All 2 branches missed.">            ctx =</span>
                    superStep == 0
                            ? new RuntimeUDFContext(
                                    taskInfo,
                                    userCodeClassLoader,
                                    executionConfig,
                                    cachedFiles,
                                    accumulators,
                                    metrics,
                                    jobID)
                            : new IterationRuntimeUDFContext(
                                    taskInfo,
                                    userCodeClassLoader,
                                    executionConfig,
                                    cachedFiles,
                                    accumulators,
                                    metrics,
                                    jobID);

            for (Map.Entry&lt;String, Operator&lt;?&gt;&gt; bcInputs :
<span class="nc bnc" id="L294" title="All 2 branches missed.">                    operator.getBroadcastInputs().entrySet()) {</span>
<span class="nc" id="L295">                List&lt;?&gt; bcData = execute(bcInputs.getValue(), jobID);</span>
<span class="nc" id="L296">                ctx.setBroadcastVariable(bcInputs.getKey(), bcData);</span>
<span class="nc" id="L297">            }</span>
        } else {
<span class="nc" id="L299">            ctx = null;</span>
        }

<span class="nc" id="L302">        return typedOp.executeOnCollections(inputData, ctx, executionConfig);</span>
    }

    private &lt;IN1, IN2, OUT&gt; List&lt;OUT&gt; executeBinaryOperator(
            DualInputOperator&lt;?, ?, ?, ?&gt; operator, int superStep, JobID jobID) throws Exception {
<span class="nc" id="L307">        Operator&lt;?&gt; inputOp1 = operator.getFirstInput();</span>
<span class="nc" id="L308">        Operator&lt;?&gt; inputOp2 = operator.getSecondInput();</span>

<span class="nc bnc" id="L310" title="All 2 branches missed.">        if (inputOp1 == null) {</span>
<span class="nc" id="L311">            throw new InvalidProgramException(</span>
<span class="nc" id="L312">                    &quot;The binary operation &quot; + operator.getName() + &quot; has no first input.&quot;);</span>
        }
<span class="nc bnc" id="L314" title="All 2 branches missed.">        if (inputOp2 == null) {</span>
<span class="nc" id="L315">            throw new InvalidProgramException(</span>
<span class="nc" id="L316">                    &quot;The binary operation &quot; + operator.getName() + &quot; has no second input.&quot;);</span>
        }

        // compute inputs
        @SuppressWarnings(&quot;unchecked&quot;)
<span class="nc" id="L321">        List&lt;IN1&gt; inputData1 = (List&lt;IN1&gt;) execute(inputOp1, superStep, jobID);</span>
        @SuppressWarnings(&quot;unchecked&quot;)
<span class="nc" id="L323">        List&lt;IN2&gt; inputData2 = (List&lt;IN2&gt;) execute(inputOp2, superStep, jobID);</span>

        @SuppressWarnings(&quot;unchecked&quot;)
<span class="nc" id="L326">        DualInputOperator&lt;IN1, IN2, OUT, ?&gt; typedOp =</span>
                (DualInputOperator&lt;IN1, IN2, OUT, ?&gt;) operator;

        // build the runtime context and compute broadcast variables, if necessary
<span class="nc" id="L330">        TaskInfo taskInfo = new TaskInfo(typedOp.getName(), 1, 0, 1, 0);</span>
        RuntimeUDFContext ctx;

<span class="nc" id="L333">        MetricGroup metrics = new UnregisteredMetricsGroup();</span>

<span class="nc bnc" id="L335" title="All 2 branches missed.">        if (RichFunction.class.isAssignableFrom(typedOp.getUserCodeWrapper().getUserCodeClass())) {</span>
<span class="nc bnc" id="L336" title="All 2 branches missed.">            ctx =</span>
                    superStep == 0
                            ? new RuntimeUDFContext(
                                    taskInfo,
                                    userCodeClassLoader,
                                    executionConfig,
                                    cachedFiles,
                                    accumulators,
                                    metrics,
                                    jobID)
                            : new IterationRuntimeUDFContext(
                                    taskInfo,
                                    userCodeClassLoader,
                                    executionConfig,
                                    cachedFiles,
                                    accumulators,
                                    metrics,
                                    jobID);

            for (Map.Entry&lt;String, Operator&lt;?&gt;&gt; bcInputs :
<span class="nc bnc" id="L356" title="All 2 branches missed.">                    operator.getBroadcastInputs().entrySet()) {</span>
<span class="nc" id="L357">                List&lt;?&gt; bcData = execute(bcInputs.getValue(), jobID);</span>
<span class="nc" id="L358">                ctx.setBroadcastVariable(bcInputs.getKey(), bcData);</span>
<span class="nc" id="L359">            }</span>
        } else {
<span class="nc" id="L361">            ctx = null;</span>
        }

<span class="nc" id="L364">        return typedOp.executeOnCollections(inputData1, inputData2, ctx, executionConfig);</span>
    }

    @SuppressWarnings(&quot;unchecked&quot;)
    private &lt;T&gt; List&lt;T&gt; executeBulkIteration(BulkIterationBase&lt;?&gt; iteration, JobID jobID)
            throws Exception {
<span class="nc" id="L370">        Operator&lt;?&gt; inputOp = iteration.getInput();</span>
<span class="nc bnc" id="L371" title="All 2 branches missed.">        if (inputOp == null) {</span>
<span class="nc" id="L372">            throw new InvalidProgramException(</span>
                    &quot;The iteration &quot;
<span class="nc" id="L374">                            + iteration.getName()</span>
                            + &quot; has no input (initial partial solution).&quot;);
        }
<span class="nc bnc" id="L377" title="All 2 branches missed.">        if (iteration.getNextPartialSolution() == null) {</span>
<span class="nc" id="L378">            throw new InvalidProgramException(</span>
                    &quot;The iteration &quot;
<span class="nc" id="L380">                            + iteration.getName()</span>
                            + &quot; has no next partial solution defined (is not closed).&quot;);
        }

<span class="nc" id="L384">        List&lt;T&gt; inputData = (List&lt;T&gt;) execute(inputOp, jobID);</span>

        // get the operators that are iterative
<span class="nc" id="L387">        Set&lt;Operator&lt;?&gt;&gt; dynamics = new LinkedHashSet&lt;Operator&lt;?&gt;&gt;();</span>
<span class="nc" id="L388">        DynamicPathCollector dynCollector = new DynamicPathCollector(dynamics);</span>
<span class="nc" id="L389">        iteration.getNextPartialSolution().accept(dynCollector);</span>
<span class="nc bnc" id="L390" title="All 2 branches missed.">        if (iteration.getTerminationCriterion() != null) {</span>
<span class="nc" id="L391">            iteration.getTerminationCriterion().accept(dynCollector);</span>
        }

        // register the aggregators
<span class="nc bnc" id="L395" title="All 2 branches missed.">        for (AggregatorWithName&lt;?&gt; a : iteration.getAggregators().getAllRegisteredAggregators()) {</span>
<span class="nc" id="L396">            aggregators.put(a.getName(), a.getAggregator());</span>
<span class="nc" id="L397">        }</span>

<span class="nc" id="L399">        String convCriterionAggName =</span>
<span class="nc" id="L400">                iteration.getAggregators().getConvergenceCriterionAggregatorName();</span>
<span class="nc" id="L401">        ConvergenceCriterion&lt;Value&gt; convCriterion =</span>
<span class="nc" id="L402">                (ConvergenceCriterion&lt;Value&gt;) iteration.getAggregators().getConvergenceCriterion();</span>

<span class="nc" id="L404">        List&lt;T&gt; currentResult = inputData;</span>

<span class="nc" id="L406">        final int maxIterations = iteration.getMaximumNumberOfIterations();</span>

<span class="nc bnc" id="L408" title="All 2 branches missed.">        for (int superstep = 1; superstep &lt;= maxIterations; superstep++) {</span>

            // set the input to the current partial solution
<span class="nc" id="L411">            this.intermediateResults.put(iteration.getPartialSolution(), currentResult);</span>

            // set the superstep number
<span class="nc" id="L414">            iterationSuperstep = superstep;</span>

            // grab the current iteration result
<span class="nc" id="L417">            currentResult = (List&lt;T&gt;) execute(iteration.getNextPartialSolution(), superstep, jobID);</span>

            // evaluate the termination criterion
<span class="nc bnc" id="L420" title="All 2 branches missed.">            if (iteration.getTerminationCriterion() != null) {</span>
<span class="nc" id="L421">                execute(iteration.getTerminationCriterion(), superstep, jobID);</span>
            }

            // evaluate the aggregator convergence criterion
<span class="nc bnc" id="L425" title="All 4 branches missed.">            if (convCriterion != null &amp;&amp; convCriterionAggName != null) {</span>
<span class="nc" id="L426">                Value v = aggregators.get(convCriterionAggName).getAggregate();</span>
<span class="nc bnc" id="L427" title="All 2 branches missed.">                if (convCriterion.isConverged(superstep, v)) {</span>
<span class="nc" id="L428">                    break;</span>
                }
            }

            // clear the dynamic results
<span class="nc bnc" id="L433" title="All 2 branches missed.">            for (Operator&lt;?&gt; o : dynamics) {</span>
<span class="nc" id="L434">                intermediateResults.remove(o);</span>
<span class="nc" id="L435">            }</span>

            // set the previous iteration's aggregates and reset the aggregators
<span class="nc bnc" id="L438" title="All 2 branches missed.">            for (Map.Entry&lt;String, Aggregator&lt;?&gt;&gt; e : aggregators.entrySet()) {</span>
<span class="nc" id="L439">                previousAggregates.put(e.getKey(), e.getValue().getAggregate());</span>
<span class="nc" id="L440">                e.getValue().reset();</span>
<span class="nc" id="L441">            }</span>
        }

<span class="nc" id="L444">        previousAggregates.clear();</span>
<span class="nc" id="L445">        aggregators.clear();</span>

<span class="nc" id="L447">        return currentResult;</span>
    }

    @SuppressWarnings(&quot;unchecked&quot;)
    private &lt;T&gt; List&lt;T&gt; executeDeltaIteration(DeltaIterationBase&lt;?, ?&gt; iteration, JobID jobID)
            throws Exception {
<span class="nc" id="L453">        Operator&lt;?&gt; solutionInput = iteration.getInitialSolutionSet();</span>
<span class="nc" id="L454">        Operator&lt;?&gt; worksetInput = iteration.getInitialWorkset();</span>
<span class="nc bnc" id="L455" title="All 2 branches missed.">        if (solutionInput == null) {</span>
<span class="nc" id="L456">            throw new InvalidProgramException(</span>
<span class="nc" id="L457">                    &quot;The delta iteration &quot; + iteration.getName() + &quot; has no initial solution set.&quot;);</span>
        }
<span class="nc bnc" id="L459" title="All 2 branches missed.">        if (worksetInput == null) {</span>
<span class="nc" id="L460">            throw new InvalidProgramException(</span>
<span class="nc" id="L461">                    &quot;The delta iteration &quot; + iteration.getName() + &quot; has no initial workset.&quot;);</span>
        }
<span class="nc bnc" id="L463" title="All 2 branches missed.">        if (iteration.getSolutionSetDelta() == null) {</span>
<span class="nc" id="L464">            throw new InvalidProgramException(</span>
                    &quot;The iteration &quot;
<span class="nc" id="L466">                            + iteration.getName()</span>
                            + &quot; has no solution set delta defined (is not closed).&quot;);
        }
<span class="nc bnc" id="L469" title="All 2 branches missed.">        if (iteration.getNextWorkset() == null) {</span>
<span class="nc" id="L470">            throw new InvalidProgramException(</span>
                    &quot;The iteration &quot;
<span class="nc" id="L472">                            + iteration.getName()</span>
                            + &quot; has no workset defined (is not closed).&quot;);
        }

<span class="nc" id="L476">        List&lt;T&gt; solutionInputData = (List&lt;T&gt;) execute(solutionInput, jobID);</span>
<span class="nc" id="L477">        List&lt;T&gt; worksetInputData = (List&lt;T&gt;) execute(worksetInput, jobID);</span>

        // get the operators that are iterative
<span class="nc" id="L480">        Set&lt;Operator&lt;?&gt;&gt; dynamics = new LinkedHashSet&lt;Operator&lt;?&gt;&gt;();</span>
<span class="nc" id="L481">        DynamicPathCollector dynCollector = new DynamicPathCollector(dynamics);</span>
<span class="nc" id="L482">        iteration.getSolutionSetDelta().accept(dynCollector);</span>
<span class="nc" id="L483">        iteration.getNextWorkset().accept(dynCollector);</span>

<span class="nc" id="L485">        BinaryOperatorInformation&lt;?, ?, ?&gt; operatorInfo = iteration.getOperatorInfo();</span>
<span class="nc" id="L486">        TypeInformation&lt;?&gt; solutionType = operatorInfo.getFirstInputType();</span>

<span class="nc" id="L488">        int[] keyColumns = iteration.getSolutionSetKeyFields();</span>
<span class="nc" id="L489">        boolean[] inputOrderings = new boolean[keyColumns.length];</span>
<span class="nc" id="L490">        TypeComparator&lt;T&gt; inputComparator =</span>
                ((CompositeType&lt;T&gt;) solutionType)
<span class="nc" id="L492">                        .createComparator(keyColumns, inputOrderings, 0, executionConfig);</span>

<span class="nc" id="L494">        Map&lt;TypeComparable&lt;T&gt;, T&gt; solutionMap =</span>
<span class="nc" id="L495">                new HashMap&lt;TypeComparable&lt;T&gt;, T&gt;(solutionInputData.size());</span>
        // fill the solution from the initial input
<span class="nc bnc" id="L497" title="All 2 branches missed.">        for (T delta : solutionInputData) {</span>
<span class="nc" id="L498">            TypeComparable&lt;T&gt; wrapper = new TypeComparable&lt;T&gt;(delta, inputComparator);</span>
<span class="nc" id="L499">            solutionMap.put(wrapper, delta);</span>
<span class="nc" id="L500">        }</span>

<span class="nc" id="L502">        List&lt;?&gt; currentWorkset = worksetInputData;</span>

        // register the aggregators
<span class="nc bnc" id="L505" title="All 2 branches missed.">        for (AggregatorWithName&lt;?&gt; a : iteration.getAggregators().getAllRegisteredAggregators()) {</span>
<span class="nc" id="L506">            aggregators.put(a.getName(), a.getAggregator());</span>
<span class="nc" id="L507">        }</span>

<span class="nc" id="L509">        String convCriterionAggName =</span>
<span class="nc" id="L510">                iteration.getAggregators().getConvergenceCriterionAggregatorName();</span>
<span class="nc" id="L511">        ConvergenceCriterion&lt;Value&gt; convCriterion =</span>
<span class="nc" id="L512">                (ConvergenceCriterion&lt;Value&gt;) iteration.getAggregators().getConvergenceCriterion();</span>

<span class="nc" id="L514">        final int maxIterations = iteration.getMaximumNumberOfIterations();</span>

<span class="nc bnc" id="L516" title="All 2 branches missed.">        for (int superstep = 1; superstep &lt;= maxIterations; superstep++) {</span>

<span class="nc" id="L518">            List&lt;T&gt; currentSolution = new ArrayList&lt;T&gt;(solutionMap.size());</span>
<span class="nc" id="L519">            currentSolution.addAll(solutionMap.values());</span>

            // set the input to the current partial solution
<span class="nc" id="L522">            this.intermediateResults.put(iteration.getSolutionSet(), currentSolution);</span>
<span class="nc" id="L523">            this.intermediateResults.put(iteration.getWorkset(), currentWorkset);</span>

            // set the superstep number
<span class="nc" id="L526">            iterationSuperstep = superstep;</span>

            // grab the current iteration result
<span class="nc" id="L529">            List&lt;T&gt; solutionSetDelta =</span>
<span class="nc" id="L530">                    (List&lt;T&gt;) execute(iteration.getSolutionSetDelta(), superstep, jobID);</span>
<span class="nc" id="L531">            this.intermediateResults.put(iteration.getSolutionSetDelta(), solutionSetDelta);</span>

            // update the solution
<span class="nc bnc" id="L534" title="All 2 branches missed.">            for (T delta : solutionSetDelta) {</span>
<span class="nc" id="L535">                TypeComparable&lt;T&gt; wrapper = new TypeComparable&lt;T&gt;(delta, inputComparator);</span>
<span class="nc" id="L536">                solutionMap.put(wrapper, delta);</span>
<span class="nc" id="L537">            }</span>

<span class="nc" id="L539">            currentWorkset = execute(iteration.getNextWorkset(), superstep, jobID);</span>

<span class="nc bnc" id="L541" title="All 2 branches missed.">            if (currentWorkset.isEmpty()) {</span>
<span class="nc" id="L542">                break;</span>
            }

            // evaluate the aggregator convergence criterion
<span class="nc bnc" id="L546" title="All 4 branches missed.">            if (convCriterion != null &amp;&amp; convCriterionAggName != null) {</span>
<span class="nc" id="L547">                Value v = aggregators.get(convCriterionAggName).getAggregate();</span>
<span class="nc bnc" id="L548" title="All 2 branches missed.">                if (convCriterion.isConverged(superstep, v)) {</span>
<span class="nc" id="L549">                    break;</span>
                }
            }

            // clear the dynamic results
<span class="nc bnc" id="L554" title="All 2 branches missed.">            for (Operator&lt;?&gt; o : dynamics) {</span>
<span class="nc" id="L555">                intermediateResults.remove(o);</span>
<span class="nc" id="L556">            }</span>

            // set the previous iteration's aggregates and reset the aggregators
<span class="nc bnc" id="L559" title="All 2 branches missed.">            for (Map.Entry&lt;String, Aggregator&lt;?&gt;&gt; e : aggregators.entrySet()) {</span>
<span class="nc" id="L560">                previousAggregates.put(e.getKey(), e.getValue().getAggregate());</span>
<span class="nc" id="L561">                e.getValue().reset();</span>
<span class="nc" id="L562">            }</span>
        }

<span class="nc" id="L565">        previousAggregates.clear();</span>
<span class="nc" id="L566">        aggregators.clear();</span>

<span class="nc" id="L568">        List&lt;T&gt; currentSolution = new ArrayList&lt;T&gt;(solutionMap.size());</span>
<span class="nc" id="L569">        currentSolution.addAll(solutionMap.values());</span>
<span class="nc" id="L570">        return currentSolution;</span>
    }

    // --------------------------------------------------------------------------------------------
    // --------------------------------------------------------------------------------------------

    private static final class DynamicPathCollector implements Visitor&lt;Operator&lt;?&gt;&gt; {

<span class="nc" id="L578">        private final Set&lt;Operator&lt;?&gt;&gt; visited = new HashSet&lt;Operator&lt;?&gt;&gt;();</span>

        private final Set&lt;Operator&lt;?&gt;&gt; dynamicPathOperations;

<span class="nc" id="L582">        public DynamicPathCollector(Set&lt;Operator&lt;?&gt;&gt; dynamicPathOperations) {</span>
<span class="nc" id="L583">            this.dynamicPathOperations = dynamicPathOperations;</span>
<span class="nc" id="L584">        }</span>

        @Override
        public boolean preVisit(Operator&lt;?&gt; op) {
<span class="nc" id="L588">            return visited.add(op);</span>
        }

        @Override
        public void postVisit(Operator&lt;?&gt; op) {

<span class="nc bnc" id="L594" title="All 2 branches missed.">            if (op instanceof SingleInputOperator) {</span>
<span class="nc" id="L595">                SingleInputOperator&lt;?, ?, ?&gt; siop = (SingleInputOperator&lt;?, ?, ?&gt;) op;</span>

<span class="nc bnc" id="L597" title="All 2 branches missed.">                if (dynamicPathOperations.contains(siop.getInput())) {</span>
<span class="nc" id="L598">                    dynamicPathOperations.add(op);</span>
                } else {
<span class="nc bnc" id="L600" title="All 2 branches missed.">                    for (Operator&lt;?&gt; o : siop.getBroadcastInputs().values()) {</span>
<span class="nc bnc" id="L601" title="All 2 branches missed.">                        if (dynamicPathOperations.contains(o)) {</span>
<span class="nc" id="L602">                            dynamicPathOperations.add(op);</span>
<span class="nc" id="L603">                            break;</span>
                        }
<span class="nc" id="L605">                    }</span>
                }
<span class="nc bnc" id="L607" title="All 2 branches missed.">            } else if (op instanceof DualInputOperator) {</span>
<span class="nc" id="L608">                DualInputOperator&lt;?, ?, ?, ?&gt; siop = (DualInputOperator&lt;?, ?, ?, ?&gt;) op;</span>

<span class="nc bnc" id="L610" title="All 2 branches missed.">                if (dynamicPathOperations.contains(siop.getFirstInput())) {</span>
<span class="nc" id="L611">                    dynamicPathOperations.add(op);</span>
<span class="nc bnc" id="L612" title="All 2 branches missed.">                } else if (dynamicPathOperations.contains(siop.getSecondInput())) {</span>
<span class="nc" id="L613">                    dynamicPathOperations.add(op);</span>
                } else {
<span class="nc bnc" id="L615" title="All 2 branches missed.">                    for (Operator&lt;?&gt; o : siop.getBroadcastInputs().values()) {</span>
<span class="nc bnc" id="L616" title="All 2 branches missed.">                        if (dynamicPathOperations.contains(o)) {</span>
<span class="nc" id="L617">                            dynamicPathOperations.add(op);</span>
<span class="nc" id="L618">                            break;</span>
                        }
<span class="nc" id="L620">                    }</span>
                }
<span class="nc bnc" id="L622" title="All 2 branches missed.">            } else if (op.getClass() == PartialSolutionPlaceHolder.class</span>
<span class="nc bnc" id="L623" title="All 2 branches missed.">                    || op.getClass() == WorksetPlaceHolder.class</span>
<span class="nc bnc" id="L624" title="All 2 branches missed.">                    || op.getClass() == SolutionSetPlaceHolder.class) {</span>
<span class="nc" id="L625">                dynamicPathOperations.add(op);</span>
<span class="nc bnc" id="L626" title="All 2 branches missed.">            } else if (op instanceof GenericDataSourceBase) {</span>
                // skip
            } else {
<span class="nc" id="L629">                throw new RuntimeException(</span>
<span class="nc" id="L630">                        &quot;Cannot handle operator type &quot; + op.getClass().getName());</span>
            }
<span class="nc" id="L632">        }</span>
    }

    private class IterationRuntimeUDFContext extends RuntimeUDFContext
            implements IterationRuntimeContext {

        public IterationRuntimeUDFContext(
                TaskInfo taskInfo,
                ClassLoader classloader,
                ExecutionConfig executionConfig,
                Map&lt;String, Future&lt;Path&gt;&gt; cpTasks,
                Map&lt;String, Accumulator&lt;?, ?&gt;&gt; accumulators,
                MetricGroup metrics,
<span class="nc" id="L645">                JobID jobID) {</span>
<span class="nc" id="L646">            super(taskInfo, classloader, executionConfig, cpTasks, accumulators, metrics, jobID);</span>
<span class="nc" id="L647">        }</span>

        @Override
        public int getSuperstepNumber() {
<span class="nc" id="L651">            return iterationSuperstep;</span>
        }

        @SuppressWarnings(&quot;unchecked&quot;)
        @Override
        public &lt;T extends Aggregator&lt;?&gt;&gt; T getIterationAggregator(String name) {
<span class="nc" id="L657">            return (T) aggregators.get(name);</span>
        }

        @SuppressWarnings(&quot;unchecked&quot;)
        @Override
        public &lt;T extends Value&gt; T getPreviousIterationAggregate(String name) {
<span class="nc" id="L663">            return (T) previousAggregates.get(name);</span>
        }
    }

    private static final class CompletedFuture implements Future&lt;Path&gt; {

        private final Path result;

<span class="nc" id="L671">        public CompletedFuture(Path entry) {</span>
            try {
<span class="nc" id="L673">                LocalFileSystem fs =</span>
<span class="nc" id="L674">                        (LocalFileSystem) FileSystem.getUnguardedFileSystem(entry.toUri());</span>
<span class="nc" id="L675">                result =</span>
<span class="nc bnc" id="L676" title="All 2 branches missed.">                        entry.isAbsolute()</span>
<span class="nc" id="L677">                                ? new Path(entry.toUri().getPath())</span>
<span class="nc" id="L678">                                : new Path(fs.getWorkingDirectory(), entry);</span>
<span class="nc" id="L679">            } catch (Exception e) {</span>
<span class="nc" id="L680">                throw new RuntimeException(</span>
                        &quot;DistributedCache supports only local files for Collection Environments&quot;);
<span class="nc" id="L682">            }</span>
<span class="nc" id="L683">        }</span>

        @Override
        public boolean cancel(boolean mayInterruptIfRunning) {
<span class="nc" id="L687">            return false;</span>
        }

        @Override
        public boolean isCancelled() {
<span class="nc" id="L692">            return false;</span>
        }

        @Override
        public boolean isDone() {
<span class="nc" id="L697">            return true;</span>
        }

        @Override
        public Path get() throws InterruptedException, ExecutionException {
<span class="nc" id="L702">            return result;</span>
        }

        @Override
        public Path get(long timeout, TimeUnit unit)
                throws InterruptedException, ExecutionException, TimeoutException {
<span class="nc" id="L708">            return get();</span>
        }
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.7.202105040129</span></div></body></html>