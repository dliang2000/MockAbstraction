<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>Configuration.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Flink : Core</a> &gt; <a href="index.source.html" class="el_package">org.apache.flink.configuration</a> &gt; <span class="el_source">Configuration.java</span></div><h1>Configuration.java</h1><pre class="source lang-java linenums">/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * &quot;License&quot;); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.apache.flink.configuration;

import org.apache.flink.annotation.Public;
import org.apache.flink.annotation.PublicEvolving;
import org.apache.flink.api.common.ExecutionConfig;
import org.apache.flink.core.io.IOReadableWritable;
import org.apache.flink.core.memory.DataInputView;
import org.apache.flink.core.memory.DataOutputView;
import org.apache.flink.types.StringValue;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.io.IOException;
import java.util.Arrays;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Map;
import java.util.Optional;
import java.util.Properties;
import java.util.Set;

import static org.apache.flink.util.Preconditions.checkNotNull;

/** Lightweight configuration object which stores key/value pairs. */
@Public
public class Configuration extends ExecutionConfig.GlobalJobParameters
        implements IOReadableWritable,
                java.io.Serializable,
                Cloneable,
                ReadableConfig,
                WritableConfig {

    private static final long serialVersionUID = 1L;

    private static final byte TYPE_STRING = 0;
    private static final byte TYPE_INT = 1;
    private static final byte TYPE_LONG = 2;
    private static final byte TYPE_BOOLEAN = 3;
    private static final byte TYPE_FLOAT = 4;
    private static final byte TYPE_DOUBLE = 5;
    private static final byte TYPE_BYTES = 6;

    /** The log object used for debugging. */
<span class="fc" id="L63">    private static final Logger LOG = LoggerFactory.getLogger(Configuration.class);</span>

    /** Stores the concrete key/value pairs of this configuration object. */
    protected final HashMap&lt;String, Object&gt; confData;

    // --------------------------------------------------------------------------------------------

    /** Creates a new empty configuration. */
<span class="fc" id="L71">    public Configuration() {</span>
<span class="fc" id="L72">        this.confData = new HashMap&lt;&gt;();</span>
<span class="fc" id="L73">    }</span>

    /**
     * Creates a new configuration with the copy of the given configuration.
     *
     * @param other The configuration to copy the entries from.
     */
<span class="fc" id="L80">    public Configuration(Configuration other) {</span>
<span class="fc" id="L81">        this.confData = new HashMap&lt;&gt;(other.confData);</span>
<span class="fc" id="L82">    }</span>

    // --------------------------------------------------------------------------------------------

    /** Creates a new configuration that is initialized with the options of the given map. */
    public static Configuration fromMap(Map&lt;String, String&gt; map) {
<span class="nc" id="L88">        final Configuration configuration = new Configuration();</span>
<span class="nc" id="L89">        map.forEach(configuration::setString);</span>
<span class="nc" id="L90">        return configuration;</span>
    }

    // --------------------------------------------------------------------------------------------

    /**
     * Returns the class associated with the given key as a string.
     *
     * @param &lt;T&gt; The type of the class to return.
     * @param key The key pointing to the associated value
     * @param defaultValue The optional default value returned if no entry exists
     * @param classLoader The class loader used to resolve the class.
     * @return The value associated with the given key, or the default value, if to entry for the
     *     key exists.
     */
    @SuppressWarnings(&quot;unchecked&quot;)
    public &lt;T&gt; Class&lt;T&gt; getClass(
            String key, Class&lt;? extends T&gt; defaultValue, ClassLoader classLoader)
            throws ClassNotFoundException {
<span class="fc" id="L109">        Optional&lt;Object&gt; o = getRawValue(key);</span>
<span class="pc bpc" id="L110" title="1 of 2 branches missed.">        if (!o.isPresent()) {</span>
<span class="nc" id="L111">            return (Class&lt;T&gt;) defaultValue;</span>
        }

<span class="pc bpc" id="L114" title="1 of 2 branches missed.">        if (o.get().getClass() == String.class) {</span>
<span class="fc" id="L115">            return (Class&lt;T&gt;) Class.forName((String) o.get(), true, classLoader);</span>
        }

<span class="nc" id="L118">        throw new IllegalArgumentException(</span>
                &quot;Configuration cannot evaluate object of class &quot;
<span class="nc" id="L120">                        + o.get().getClass()</span>
                        + &quot; as a class name&quot;);
    }

    /**
     * Adds the given key/value pair to the configuration object. The class can be retrieved by
     * invoking {@link #getClass(String, Class, ClassLoader)} if it is in the scope of the class
     * loader on the caller.
     *
     * @param key The key of the pair to be added
     * @param klazz The value of the pair to be added
     * @see #getClass(String, Class, ClassLoader)
     */
    public void setClass(String key, Class&lt;?&gt; klazz) {
<span class="fc" id="L134">        setValueInternal(key, klazz.getName());</span>
<span class="fc" id="L135">    }</span>

    /**
     * Returns the value associated with the given key as a string.
     *
     * @param key the key pointing to the associated value
     * @param defaultValue the default value which is returned in case there is no value associated
     *     with the given key
     * @return the (default) value associated with the given key
     * @deprecated use {@link #getString(ConfigOption, String)} or {@link
     *     #getOptional(ConfigOption)}
     */
    @Deprecated
    public String getString(String key, String defaultValue) {
<span class="fc" id="L149">        return getRawValue(key).map(ConfigurationUtils::convertToString).orElse(defaultValue);</span>
    }

    /**
     * Returns the value associated with the given config option as a string.
     *
     * @param configOption The configuration option
     * @return the (default) value associated with the given config option
     */
    @PublicEvolving
    public String getString(ConfigOption&lt;String&gt; configOption) {
<span class="fc" id="L160">        return getOptional(configOption).orElseGet(configOption::defaultValue);</span>
    }

    /**
     * Returns the value associated with the given config option as a string. If no value is mapped
     * under any key of the option, it returns the specified default instead of the option's default
     * value.
     *
     * @param configOption The configuration option
     * @return the (default) value associated with the given config option
     */
    @PublicEvolving
    public String getString(ConfigOption&lt;String&gt; configOption, String overrideDefault) {
<span class="fc" id="L173">        return getOptional(configOption).orElse(overrideDefault);</span>
    }

    /**
     * Adds the given key/value pair to the configuration object.
     *
     * @param key the key of the key/value pair to be added
     * @param value the value of the key/value pair to be added
     */
    public void setString(String key, String value) {
<span class="fc" id="L183">        setValueInternal(key, value);</span>
<span class="fc" id="L184">    }</span>

    /**
     * Adds the given value to the configuration object. The main key of the config option will be
     * used to map the value.
     *
     * @param key the option specifying the key to be added
     * @param value the value of the key/value pair to be added
     */
    @PublicEvolving
    public void setString(ConfigOption&lt;String&gt; key, String value) {
<span class="fc" id="L195">        setValueInternal(key.key(), value);</span>
<span class="fc" id="L196">    }</span>

    /**
     * Returns the value associated with the given key as an integer.
     *
     * @param key the key pointing to the associated value
     * @param defaultValue the default value which is returned in case there is no value associated
     *     with the given key
     * @return the (default) value associated with the given key
     * @deprecated use {@link #getInteger(ConfigOption, int)} or {@link #getOptional(ConfigOption)}
     */
    @Deprecated
    public int getInteger(String key, int defaultValue) {
<span class="fc" id="L209">        return getRawValue(key).map(ConfigurationUtils::convertToInt).orElse(defaultValue);</span>
    }

    /**
     * Returns the value associated with the given config option as an integer.
     *
     * @param configOption The configuration option
     * @return the (default) value associated with the given config option
     */
    @PublicEvolving
    public int getInteger(ConfigOption&lt;Integer&gt; configOption) {
<span class="fc" id="L220">        return getOptional(configOption).orElseGet(configOption::defaultValue);</span>
    }

    /**
     * Returns the value associated with the given config option as an integer. If no value is
     * mapped under any key of the option, it returns the specified default instead of the option's
     * default value.
     *
     * @param configOption The configuration option
     * @param overrideDefault The value to return if no value was mapper for any key of the option
     * @return the configured value associated with the given config option, or the overrideDefault
     */
    @PublicEvolving
    public int getInteger(ConfigOption&lt;Integer&gt; configOption, int overrideDefault) {
<span class="nc" id="L234">        return getOptional(configOption).orElse(overrideDefault);</span>
    }

    /**
     * Adds the given key/value pair to the configuration object.
     *
     * @param key the key of the key/value pair to be added
     * @param value the value of the key/value pair to be added
     */
    public void setInteger(String key, int value) {
<span class="fc" id="L244">        setValueInternal(key, value);</span>
<span class="fc" id="L245">    }</span>

    /**
     * Adds the given value to the configuration object. The main key of the config option will be
     * used to map the value.
     *
     * @param key the option specifying the key to be added
     * @param value the value of the key/value pair to be added
     */
    @PublicEvolving
    public void setInteger(ConfigOption&lt;Integer&gt; key, int value) {
<span class="fc" id="L256">        setValueInternal(key.key(), value);</span>
<span class="fc" id="L257">    }</span>

    /**
     * Returns the value associated with the given key as a long.
     *
     * @param key the key pointing to the associated value
     * @param defaultValue the default value which is returned in case there is no value associated
     *     with the given key
     * @return the (default) value associated with the given key
     * @deprecated use {@link #getLong(ConfigOption, long)} or {@link #getOptional(ConfigOption)}
     */
    @Deprecated
    public long getLong(String key, long defaultValue) {
<span class="fc" id="L270">        return getRawValue(key).map(ConfigurationUtils::convertToLong).orElse(defaultValue);</span>
    }

    /**
     * Returns the value associated with the given config option as a long integer.
     *
     * @param configOption The configuration option
     * @return the (default) value associated with the given config option
     */
    @PublicEvolving
    public long getLong(ConfigOption&lt;Long&gt; configOption) {
<span class="fc" id="L281">        return getOptional(configOption).orElseGet(configOption::defaultValue);</span>
    }

    /**
     * Returns the value associated with the given config option as a long integer. If no value is
     * mapped under any key of the option, it returns the specified default instead of the option's
     * default value.
     *
     * @param configOption The configuration option
     * @param overrideDefault The value to return if no value was mapper for any key of the option
     * @return the configured value associated with the given config option, or the overrideDefault
     */
    @PublicEvolving
    public long getLong(ConfigOption&lt;Long&gt; configOption, long overrideDefault) {
<span class="nc" id="L295">        return getOptional(configOption).orElse(overrideDefault);</span>
    }

    /**
     * Adds the given key/value pair to the configuration object.
     *
     * @param key the key of the key/value pair to be added
     * @param value the value of the key/value pair to be added
     */
    public void setLong(String key, long value) {
<span class="fc" id="L305">        setValueInternal(key, value);</span>
<span class="fc" id="L306">    }</span>

    /**
     * Adds the given value to the configuration object. The main key of the config option will be
     * used to map the value.
     *
     * @param key the option specifying the key to be added
     * @param value the value of the key/value pair to be added
     */
    @PublicEvolving
    public void setLong(ConfigOption&lt;Long&gt; key, long value) {
<span class="nc" id="L317">        setValueInternal(key.key(), value);</span>
<span class="nc" id="L318">    }</span>

    /**
     * Returns the value associated with the given key as a boolean.
     *
     * @param key the key pointing to the associated value
     * @param defaultValue the default value which is returned in case there is no value associated
     *     with the given key
     * @return the (default) value associated with the given key
     * @deprecated use {@link #getBoolean(ConfigOption, boolean)} or {@link
     *     #getOptional(ConfigOption)}
     */
    @Deprecated
    public boolean getBoolean(String key, boolean defaultValue) {
<span class="fc" id="L332">        return getRawValue(key).map(ConfigurationUtils::convertToBoolean).orElse(defaultValue);</span>
    }

    /**
     * Returns the value associated with the given config option as a boolean.
     *
     * @param configOption The configuration option
     * @return the (default) value associated with the given config option
     */
    @PublicEvolving
    public boolean getBoolean(ConfigOption&lt;Boolean&gt; configOption) {
<span class="fc" id="L343">        return getOptional(configOption).orElseGet(configOption::defaultValue);</span>
    }

    /**
     * Returns the value associated with the given config option as a boolean. If no value is mapped
     * under any key of the option, it returns the specified default instead of the option's default
     * value.
     *
     * @param configOption The configuration option
     * @param overrideDefault The value to return if no value was mapper for any key of the option
     * @return the configured value associated with the given config option, or the overrideDefault
     */
    @PublicEvolving
    public boolean getBoolean(ConfigOption&lt;Boolean&gt; configOption, boolean overrideDefault) {
<span class="nc" id="L357">        return getOptional(configOption).orElse(overrideDefault);</span>
    }

    /**
     * Adds the given key/value pair to the configuration object.
     *
     * @param key the key of the key/value pair to be added
     * @param value the value of the key/value pair to be added
     */
    public void setBoolean(String key, boolean value) {
<span class="fc" id="L367">        setValueInternal(key, value);</span>
<span class="fc" id="L368">    }</span>

    /**
     * Adds the given value to the configuration object. The main key of the config option will be
     * used to map the value.
     *
     * @param key the option specifying the key to be added
     * @param value the value of the key/value pair to be added
     */
    @PublicEvolving
    public void setBoolean(ConfigOption&lt;Boolean&gt; key, boolean value) {
<span class="nc" id="L379">        setValueInternal(key.key(), value);</span>
<span class="nc" id="L380">    }</span>

    /**
     * Returns the value associated with the given key as a float.
     *
     * @param key the key pointing to the associated value
     * @param defaultValue the default value which is returned in case there is no value associated
     *     with the given key
     * @return the (default) value associated with the given key
     * @deprecated use {@link #getFloat(ConfigOption, float)} or {@link #getOptional(ConfigOption)}
     */
    @Deprecated
    public float getFloat(String key, float defaultValue) {
<span class="fc" id="L393">        return getRawValue(key).map(ConfigurationUtils::convertToFloat).orElse(defaultValue);</span>
    }

    /**
     * Returns the value associated with the given config option as a float.
     *
     * @param configOption The configuration option
     * @return the (default) value associated with the given config option
     */
    @PublicEvolving
    public float getFloat(ConfigOption&lt;Float&gt; configOption) {
<span class="nc" id="L404">        return getOptional(configOption).orElseGet(configOption::defaultValue);</span>
    }

    /**
     * Returns the value associated with the given config option as a float. If no value is mapped
     * under any key of the option, it returns the specified default instead of the option's default
     * value.
     *
     * @param configOption The configuration option
     * @param overrideDefault The value to return if no value was mapper for any key of the option
     * @return the configured value associated with the given config option, or the overrideDefault
     */
    @PublicEvolving
    public float getFloat(ConfigOption&lt;Float&gt; configOption, float overrideDefault) {
<span class="nc" id="L418">        return getOptional(configOption).orElse(overrideDefault);</span>
    }

    /**
     * Adds the given key/value pair to the configuration object.
     *
     * @param key the key of the key/value pair to be added
     * @param value the value of the key/value pair to be added
     */
    public void setFloat(String key, float value) {
<span class="fc" id="L428">        setValueInternal(key, value);</span>
<span class="fc" id="L429">    }</span>

    /**
     * Adds the given value to the configuration object. The main key of the config option will be
     * used to map the value.
     *
     * @param key the option specifying the key to be added
     * @param value the value of the key/value pair to be added
     */
    @PublicEvolving
    public void setFloat(ConfigOption&lt;Float&gt; key, float value) {
<span class="nc" id="L440">        setValueInternal(key.key(), value);</span>
<span class="nc" id="L441">    }</span>

    /**
     * Returns the value associated with the given key as a double.
     *
     * @param key the key pointing to the associated value
     * @param defaultValue the default value which is returned in case there is no value associated
     *     with the given key
     * @return the (default) value associated with the given key
     * @deprecated use {@link #getDouble(ConfigOption, double)} or {@link
     *     #getOptional(ConfigOption)}
     */
    @Deprecated
    public double getDouble(String key, double defaultValue) {
<span class="fc" id="L455">        return getRawValue(key).map(ConfigurationUtils::convertToDouble).orElse(defaultValue);</span>
    }

    /**
     * Returns the value associated with the given config option as a {@code double}.
     *
     * @param configOption The configuration option
     * @return the (default) value associated with the given config option
     */
    @PublicEvolving
    public double getDouble(ConfigOption&lt;Double&gt; configOption) {
<span class="nc" id="L466">        return getOptional(configOption).orElseGet(configOption::defaultValue);</span>
    }

    /**
     * Returns the value associated with the given config option as a {@code double}. If no value is
     * mapped under any key of the option, it returns the specified default instead of the option's
     * default value.
     *
     * @param configOption The configuration option
     * @param overrideDefault The value to return if no value was mapper for any key of the option
     * @return the configured value associated with the given config option, or the overrideDefault
     */
    @PublicEvolving
    public double getDouble(ConfigOption&lt;Double&gt; configOption, double overrideDefault) {
<span class="nc" id="L480">        return getOptional(configOption).orElse(overrideDefault);</span>
    }

    /**
     * Adds the given key/value pair to the configuration object.
     *
     * @param key the key of the key/value pair to be added
     * @param value the value of the key/value pair to be added
     */
    public void setDouble(String key, double value) {
<span class="fc" id="L490">        setValueInternal(key, value);</span>
<span class="fc" id="L491">    }</span>

    /**
     * Adds the given value to the configuration object. The main key of the config option will be
     * used to map the value.
     *
     * @param key the option specifying the key to be added
     * @param value the value of the key/value pair to be added
     */
    @PublicEvolving
    public void setDouble(ConfigOption&lt;Double&gt; key, double value) {
<span class="nc" id="L502">        setValueInternal(key.key(), value);</span>
<span class="nc" id="L503">    }</span>

    /**
     * Returns the value associated with the given key as a byte array.
     *
     * @param key The key pointing to the associated value.
     * @param defaultValue The default value which is returned in case there is no value associated
     *     with the given key.
     * @return the (default) value associated with the given key.
     */
    public byte[] getBytes(String key, byte[] defaultValue) {
<span class="fc" id="L514">        return getRawValue(key)</span>
<span class="fc" id="L515">                .map(</span>
                        o -&gt; {
<span class="pc bpc" id="L517" title="1 of 2 branches missed.">                            if (o.getClass().equals(byte[].class)) {</span>
<span class="fc" id="L518">                                return (byte[]) o;</span>
                            } else {
<span class="nc" id="L520">                                throw new IllegalArgumentException(</span>
<span class="nc" id="L521">                                        String.format(</span>
                                                &quot;Configuration cannot evaluate value %s as a byte[] value&quot;,
                                                o));
                            }
                        })
<span class="fc" id="L526">                .orElse(defaultValue);</span>
    }

    /**
     * Adds the given byte array to the configuration object. If key is &lt;code&gt;null&lt;/code&gt; then
     * nothing is added.
     *
     * @param key The key under which the bytes are added.
     * @param bytes The bytes to be added.
     */
    public void setBytes(String key, byte[] bytes) {
<span class="fc" id="L537">        setValueInternal(key, bytes);</span>
<span class="fc" id="L538">    }</span>

    /**
     * Returns the value associated with the given config option as a string.
     *
     * @param configOption The configuration option
     * @return the (default) value associated with the given config option
     */
    @PublicEvolving
    public String getValue(ConfigOption&lt;?&gt; configOption) {
<span class="fc" id="L548">        return Optional.ofNullable(</span>
<span class="fc" id="L549">                        getRawValueFromOption(configOption).orElseGet(configOption::defaultValue))</span>
<span class="fc" id="L550">                .map(String::valueOf)</span>
<span class="fc" id="L551">                .orElse(null);</span>
    }

    /**
     * Returns the value associated with the given config option as an enum.
     *
     * @param enumClass The return enum class
     * @param configOption The configuration option
     * @throws IllegalArgumentException If the string associated with the given config option cannot
     *     be parsed as a value of the provided enum class.
     */
    @PublicEvolving
    public &lt;T extends Enum&lt;T&gt;&gt; T getEnum(
            final Class&lt;T&gt; enumClass, final ConfigOption&lt;String&gt; configOption) {
<span class="fc" id="L565">        checkNotNull(enumClass, &quot;enumClass must not be null&quot;);</span>
<span class="fc" id="L566">        checkNotNull(configOption, &quot;configOption must not be null&quot;);</span>

<span class="fc" id="L568">        Object rawValue = getRawValueFromOption(configOption).orElseGet(configOption::defaultValue);</span>
        try {
<span class="fc" id="L570">            return ConfigurationUtils.convertToEnum(rawValue, enumClass);</span>
<span class="fc" id="L571">        } catch (IllegalArgumentException ex) {</span>
<span class="fc" id="L572">            final String errorMessage =</span>
<span class="fc" id="L573">                    String.format(</span>
                            &quot;Value for config option %s must be one of %s (was %s)&quot;,
<span class="fc" id="L575">                            configOption.key(),</span>
<span class="fc" id="L576">                            Arrays.toString(enumClass.getEnumConstants()),</span>
                            rawValue);
<span class="fc" id="L578">            throw new IllegalArgumentException(errorMessage);</span>
        }
    }

    // --------------------------------------------------------------------------------------------

    /**
     * Returns the keys of all key/value pairs stored inside this configuration object.
     *
     * @return the keys of all key/value pairs stored inside this configuration object
     */
    public Set&lt;String&gt; keySet() {
<span class="fc" id="L590">        synchronized (this.confData) {</span>
<span class="fc" id="L591">            return new HashSet&lt;&gt;(this.confData.keySet());</span>
        }
    }

    /** Adds all entries in this {@code Configuration} to the given {@link Properties}. */
    public void addAllToProperties(Properties props) {
<span class="nc" id="L597">        synchronized (this.confData) {</span>
<span class="nc bnc" id="L598" title="All 2 branches missed.">            for (Map.Entry&lt;String, Object&gt; entry : this.confData.entrySet()) {</span>
<span class="nc" id="L599">                props.put(entry.getKey(), entry.getValue());</span>
<span class="nc" id="L600">            }</span>
<span class="nc" id="L601">        }</span>
<span class="nc" id="L602">    }</span>

    public void addAll(Configuration other) {
<span class="nc" id="L605">        synchronized (this.confData) {</span>
<span class="nc" id="L606">            synchronized (other.confData) {</span>
<span class="nc" id="L607">                this.confData.putAll(other.confData);</span>
<span class="nc" id="L608">            }</span>
<span class="nc" id="L609">        }</span>
<span class="nc" id="L610">    }</span>

    /**
     * Adds all entries from the given configuration into this configuration. The keys are prepended
     * with the given prefix.
     *
     * @param other The configuration whose entries are added to this configuration.
     * @param prefix The prefix to prepend.
     */
    public void addAll(Configuration other, String prefix) {
<span class="nc" id="L620">        final StringBuilder bld = new StringBuilder();</span>
<span class="nc" id="L621">        bld.append(prefix);</span>
<span class="nc" id="L622">        final int pl = bld.length();</span>

<span class="nc" id="L624">        synchronized (this.confData) {</span>
<span class="nc" id="L625">            synchronized (other.confData) {</span>
<span class="nc bnc" id="L626" title="All 2 branches missed.">                for (Map.Entry&lt;String, Object&gt; entry : other.confData.entrySet()) {</span>
<span class="nc" id="L627">                    bld.setLength(pl);</span>
<span class="nc" id="L628">                    bld.append(entry.getKey());</span>
<span class="nc" id="L629">                    this.confData.put(bld.toString(), entry.getValue());</span>
<span class="nc" id="L630">                }</span>
<span class="nc" id="L631">            }</span>
<span class="nc" id="L632">        }</span>
<span class="nc" id="L633">    }</span>

    @Override
    public Configuration clone() {
<span class="nc" id="L637">        Configuration config = new Configuration();</span>
<span class="nc" id="L638">        config.addAll(this);</span>

<span class="nc" id="L640">        return config;</span>
    }

    /**
     * Checks whether there is an entry with the specified key.
     *
     * @param key key of entry
     * @return true if the key is stored, false otherwise
     */
    public boolean containsKey(String key) {
<span class="nc" id="L650">        synchronized (this.confData) {</span>
<span class="nc" id="L651">            return this.confData.containsKey(key);</span>
        }
    }

    /**
     * Checks whether there is an entry for the given config option.
     *
     * @param configOption The configuration option
     * @return &lt;tt&gt;true&lt;/tt&gt; if a valid (current or deprecated) key of the config option is stored,
     *     &lt;tt&gt;false&lt;/tt&gt; otherwise
     */
    @PublicEvolving
    public boolean contains(ConfigOption&lt;?&gt; configOption) {
<span class="nc" id="L664">        synchronized (this.confData) {</span>
            // first try the current key
<span class="nc bnc" id="L666" title="All 2 branches missed.">            if (this.confData.containsKey(configOption.key())) {</span>
<span class="nc" id="L667">                return true;</span>
<span class="nc bnc" id="L668" title="All 2 branches missed.">            } else if (configOption.hasFallbackKeys()) {</span>
                // try the fallback keys
<span class="nc bnc" id="L670" title="All 2 branches missed.">                for (FallbackKey fallbackKey : configOption.fallbackKeys()) {</span>
<span class="nc bnc" id="L671" title="All 2 branches missed.">                    if (this.confData.containsKey(fallbackKey.getKey())) {</span>
<span class="nc" id="L672">                        loggingFallback(fallbackKey, configOption);</span>
<span class="nc" id="L673">                        return true;</span>
                    }
<span class="nc" id="L675">                }</span>
            }

<span class="nc" id="L678">            return false;</span>
        }
    }

    @Override
    public &lt;T&gt; T get(ConfigOption&lt;T&gt; option) {
<span class="fc" id="L684">        return getOptional(option).orElseGet(option::defaultValue);</span>
    }

    @Override
    public &lt;T&gt; Optional&lt;T&gt; getOptional(ConfigOption&lt;T&gt; option) {
<span class="fc" id="L689">        Optional&lt;Object&gt; rawValue = getRawValueFromOption(option);</span>
<span class="fc" id="L690">        Class&lt;?&gt; clazz = option.getClazz();</span>

        try {
<span class="fc bfc" id="L693" title="All 2 branches covered.">            if (option.isList()) {</span>
<span class="fc" id="L694">                return rawValue.map(v -&gt; ConfigurationUtils.convertToList(v, clazz));</span>
            } else {
<span class="fc" id="L696">                return rawValue.map(v -&gt; ConfigurationUtils.convertValue(v, clazz));</span>
            }
<span class="nc" id="L698">        } catch (Exception e) {</span>
<span class="nc" id="L699">            throw new IllegalArgumentException(</span>
<span class="nc" id="L700">                    String.format(</span>
                            &quot;Could not parse value '%s' for key '%s'.&quot;,
<span class="nc" id="L702">                            rawValue.map(Object::toString).orElse(&quot;&quot;), option.key()),</span>
                    e);
        }
    }

    @Override
    public &lt;T&gt; Configuration set(ConfigOption&lt;T&gt; option, T value) {
<span class="fc" id="L709">        setValueInternal(option.key(), value);</span>
<span class="fc" id="L710">        return this;</span>
    }

    // --------------------------------------------------------------------------------------------

    @Override
    public Map&lt;String, String&gt; toMap() {
<span class="fc" id="L717">        synchronized (this.confData) {</span>
<span class="fc" id="L718">            Map&lt;String, String&gt; ret = new HashMap&lt;&gt;(this.confData.size());</span>
<span class="fc bfc" id="L719" title="All 2 branches covered.">            for (Map.Entry&lt;String, Object&gt; entry : confData.entrySet()) {</span>
<span class="fc" id="L720">                ret.put(entry.getKey(), ConfigurationUtils.convertToString(entry.getValue()));</span>
<span class="fc" id="L721">            }</span>
<span class="fc" id="L722">            return ret;</span>
        }
    }

    /**
     * Removes given config option from the configuration.
     *
     * @param configOption config option to remove
     * @param &lt;T&gt; Type of the config option
     * @return true is config has been removed, false otherwise
     */
    public &lt;T&gt; boolean removeConfig(ConfigOption&lt;T&gt; configOption) {
<span class="fc" id="L734">        synchronized (this.confData) {</span>
            // try the current key
<span class="fc" id="L736">            Object oldValue = this.confData.remove(configOption.key());</span>
<span class="fc bfc" id="L737" title="All 2 branches covered.">            if (oldValue == null) {</span>
<span class="fc bfc" id="L738" title="All 2 branches covered.">                for (FallbackKey fallbackKey : configOption.fallbackKeys()) {</span>
<span class="fc" id="L739">                    oldValue = this.confData.remove(fallbackKey.getKey());</span>
<span class="fc bfc" id="L740" title="All 2 branches covered.">                    if (oldValue != null) {</span>
<span class="fc" id="L741">                        loggingFallback(fallbackKey, configOption);</span>
<span class="fc" id="L742">                        return true;</span>
                    }
<span class="fc" id="L744">                }</span>
<span class="fc" id="L745">                return false;</span>
            }
<span class="fc" id="L747">            return true;</span>
        }
    }

    // --------------------------------------------------------------------------------------------

    &lt;T&gt; void setValueInternal(String key, T value) {
<span class="pc bpc" id="L754" title="1 of 2 branches missed.">        if (key == null) {</span>
<span class="nc" id="L755">            throw new NullPointerException(&quot;Key must not be null.&quot;);</span>
        }
<span class="fc bfc" id="L757" title="All 2 branches covered.">        if (value == null) {</span>
<span class="fc" id="L758">            throw new NullPointerException(&quot;Value must not be null.&quot;);</span>
        }

<span class="fc" id="L761">        synchronized (this.confData) {</span>
<span class="fc" id="L762">            this.confData.put(key, value);</span>
<span class="fc" id="L763">        }</span>
<span class="fc" id="L764">    }</span>

    private Optional&lt;Object&gt; getRawValue(String key) {
<span class="pc bpc" id="L767" title="1 of 2 branches missed.">        if (key == null) {</span>
<span class="nc" id="L768">            throw new NullPointerException(&quot;Key must not be null.&quot;);</span>
        }

<span class="fc" id="L771">        synchronized (this.confData) {</span>
<span class="fc" id="L772">            return Optional.ofNullable(this.confData.get(key));</span>
        }
    }

    private Optional&lt;Object&gt; getRawValueFromOption(ConfigOption&lt;?&gt; configOption) {
        // first try the current key
<span class="fc" id="L778">        Optional&lt;Object&gt; o = getRawValue(configOption.key());</span>

<span class="fc bfc" id="L780" title="All 2 branches covered.">        if (o.isPresent()) {</span>
            // found a value for the current proper key
<span class="fc" id="L782">            return o;</span>
<span class="fc bfc" id="L783" title="All 2 branches covered.">        } else if (configOption.hasFallbackKeys()) {</span>
            // try the deprecated keys
<span class="fc bfc" id="L785" title="All 2 branches covered.">            for (FallbackKey fallbackKey : configOption.fallbackKeys()) {</span>
<span class="fc" id="L786">                Optional&lt;Object&gt; oo = getRawValue(fallbackKey.getKey());</span>
<span class="fc bfc" id="L787" title="All 2 branches covered.">                if (oo.isPresent()) {</span>
<span class="fc" id="L788">                    loggingFallback(fallbackKey, configOption);</span>
<span class="fc" id="L789">                    return oo;</span>
                }
<span class="fc" id="L791">            }</span>
        }

<span class="fc" id="L794">        return Optional.empty();</span>
    }

    private void loggingFallback(FallbackKey fallbackKey, ConfigOption&lt;?&gt; configOption) {
<span class="fc bfc" id="L798" title="All 2 branches covered.">        if (fallbackKey.isDeprecated()) {</span>
<span class="fc" id="L799">            LOG.warn(</span>
                    &quot;Config uses deprecated configuration key '{}' instead of proper key '{}'&quot;,
<span class="fc" id="L801">                    fallbackKey.getKey(),</span>
<span class="fc" id="L802">                    configOption.key());</span>
        } else {
<span class="fc" id="L804">            LOG.info(</span>
                    &quot;Config uses fallback configuration key '{}' instead of key '{}'&quot;,
<span class="fc" id="L806">                    fallbackKey.getKey(),</span>
<span class="fc" id="L807">                    configOption.key());</span>
        }
<span class="fc" id="L809">    }</span>

    // --------------------------------------------------------------------------------------------
    //  Serialization
    // --------------------------------------------------------------------------------------------

    @Override
    public void read(DataInputView in) throws IOException {
<span class="fc" id="L817">        synchronized (this.confData) {</span>
<span class="fc" id="L818">            final int numberOfProperties = in.readInt();</span>

<span class="fc bfc" id="L820" title="All 2 branches covered.">            for (int i = 0; i &lt; numberOfProperties; i++) {</span>
<span class="fc" id="L821">                String key = StringValue.readString(in);</span>
                Object value;

<span class="fc" id="L824">                byte type = in.readByte();</span>
<span class="pc bpc" id="L825" title="1 of 8 branches missed.">                switch (type) {</span>
                    case TYPE_STRING:
<span class="fc" id="L827">                        value = StringValue.readString(in);</span>
<span class="fc" id="L828">                        break;</span>
                    case TYPE_INT:
<span class="fc" id="L830">                        value = in.readInt();</span>
<span class="fc" id="L831">                        break;</span>
                    case TYPE_LONG:
<span class="fc" id="L833">                        value = in.readLong();</span>
<span class="fc" id="L834">                        break;</span>
                    case TYPE_FLOAT:
<span class="fc" id="L836">                        value = in.readFloat();</span>
<span class="fc" id="L837">                        break;</span>
                    case TYPE_DOUBLE:
<span class="fc" id="L839">                        value = in.readDouble();</span>
<span class="fc" id="L840">                        break;</span>
                    case TYPE_BOOLEAN:
<span class="fc" id="L842">                        value = in.readBoolean();</span>
<span class="fc" id="L843">                        break;</span>
                    case TYPE_BYTES:
<span class="fc" id="L845">                        byte[] bytes = new byte[in.readInt()];</span>
<span class="fc" id="L846">                        in.readFully(bytes);</span>
<span class="fc" id="L847">                        value = bytes;</span>
<span class="fc" id="L848">                        break;</span>
                    default:
<span class="nc" id="L850">                        throw new IOException(</span>
<span class="nc" id="L851">                                String.format(</span>
                                        &quot;Unrecognized type: %s. This method is deprecated and&quot;
                                                + &quot; might not work for all supported types.&quot;,
<span class="nc" id="L854">                                        type));</span>
                }

<span class="fc" id="L857">                this.confData.put(key, value);</span>
            }
<span class="fc" id="L859">        }</span>
<span class="fc" id="L860">    }</span>

    @Override
    public void write(final DataOutputView out) throws IOException {
<span class="fc" id="L864">        synchronized (this.confData) {</span>
<span class="fc" id="L865">            out.writeInt(this.confData.size());</span>

<span class="fc bfc" id="L867" title="All 2 branches covered.">            for (Map.Entry&lt;String, Object&gt; entry : this.confData.entrySet()) {</span>
<span class="fc" id="L868">                String key = entry.getKey();</span>
<span class="fc" id="L869">                Object val = entry.getValue();</span>

<span class="fc" id="L871">                StringValue.writeString(key, out);</span>
<span class="fc" id="L872">                Class&lt;?&gt; clazz = val.getClass();</span>

<span class="fc bfc" id="L874" title="All 2 branches covered.">                if (clazz == String.class) {</span>
<span class="fc" id="L875">                    out.write(TYPE_STRING);</span>
<span class="fc" id="L876">                    StringValue.writeString((String) val, out);</span>
<span class="fc bfc" id="L877" title="All 2 branches covered.">                } else if (clazz == Integer.class) {</span>
<span class="fc" id="L878">                    out.write(TYPE_INT);</span>
<span class="fc" id="L879">                    out.writeInt((Integer) val);</span>
<span class="fc bfc" id="L880" title="All 2 branches covered.">                } else if (clazz == Long.class) {</span>
<span class="fc" id="L881">                    out.write(TYPE_LONG);</span>
<span class="fc" id="L882">                    out.writeLong((Long) val);</span>
<span class="fc bfc" id="L883" title="All 2 branches covered.">                } else if (clazz == Float.class) {</span>
<span class="fc" id="L884">                    out.write(TYPE_FLOAT);</span>
<span class="fc" id="L885">                    out.writeFloat((Float) val);</span>
<span class="fc bfc" id="L886" title="All 2 branches covered.">                } else if (clazz == Double.class) {</span>
<span class="fc" id="L887">                    out.write(TYPE_DOUBLE);</span>
<span class="fc" id="L888">                    out.writeDouble((Double) val);</span>
<span class="fc bfc" id="L889" title="All 2 branches covered.">                } else if (clazz == byte[].class) {</span>
<span class="fc" id="L890">                    out.write(TYPE_BYTES);</span>
<span class="fc" id="L891">                    byte[] bytes = (byte[]) val;</span>
<span class="fc" id="L892">                    out.writeInt(bytes.length);</span>
<span class="fc" id="L893">                    out.write(bytes);</span>
<span class="pc bpc" id="L894" title="1 of 2 branches missed.">                } else if (clazz == Boolean.class) {</span>
<span class="fc" id="L895">                    out.write(TYPE_BOOLEAN);</span>
<span class="fc" id="L896">                    out.writeBoolean((Boolean) val);</span>
                } else {
<span class="nc" id="L898">                    throw new IllegalArgumentException(</span>
                            &quot;Unrecognized type. This method is deprecated and might not work&quot;
                                    + &quot; for all supported types.&quot;);
                }
<span class="fc" id="L902">            }</span>
<span class="fc" id="L903">        }</span>
<span class="fc" id="L904">    }</span>

    // --------------------------------------------------------------------------------------------

    @Override
    public int hashCode() {
<span class="fc" id="L910">        int hash = 0;</span>
<span class="fc bfc" id="L911" title="All 2 branches covered.">        for (String s : this.confData.keySet()) {</span>
<span class="fc" id="L912">            hash ^= s.hashCode();</span>
<span class="fc" id="L913">        }</span>
<span class="fc" id="L914">        return hash;</span>
    }

    @Override
    public boolean equals(Object obj) {
<span class="pc bpc" id="L919" title="1 of 2 branches missed.">        if (this == obj) {</span>
<span class="nc" id="L920">            return true;</span>
<span class="pc bpc" id="L921" title="1 of 2 branches missed.">        } else if (obj instanceof Configuration) {</span>
<span class="fc" id="L922">            Map&lt;String, Object&gt; otherConf = ((Configuration) obj).confData;</span>

<span class="fc bfc" id="L924" title="All 2 branches covered.">            for (Map.Entry&lt;String, Object&gt; e : this.confData.entrySet()) {</span>
<span class="fc" id="L925">                Object thisVal = e.getValue();</span>
<span class="fc" id="L926">                Object otherVal = otherConf.get(e.getKey());</span>

<span class="fc bfc" id="L928" title="All 2 branches covered.">                if (!thisVal.getClass().equals(byte[].class)) {</span>
<span class="pc bpc" id="L929" title="1 of 2 branches missed.">                    if (!thisVal.equals(otherVal)) {</span>
<span class="nc" id="L930">                        return false;</span>
                    }
<span class="pc bpc" id="L932" title="1 of 2 branches missed.">                } else if (otherVal.getClass().equals(byte[].class)) {</span>
<span class="pc bpc" id="L933" title="1 of 2 branches missed.">                    if (!Arrays.equals((byte[]) thisVal, (byte[]) otherVal)) {</span>
<span class="nc" id="L934">                        return false;</span>
                    }
                } else {
<span class="nc" id="L937">                    return false;</span>
                }
<span class="fc" id="L939">            }</span>

<span class="fc" id="L941">            return true;</span>
        } else {
<span class="nc" id="L943">            return false;</span>
        }
    }

    @Override
    public String toString() {
<span class="nc" id="L949">        return this.confData.toString();</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.7.202105040129</span></div></body></html>