<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>PojoComparator.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Flink : Core</a> &gt; <a href="index.source.html" class="el_package">org.apache.flink.api.java.typeutils.runtime</a> &gt; <span class="el_source">PojoComparator.java</span></div><h1>PojoComparator.java</h1><pre class="source lang-java linenums">/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * &quot;License&quot;); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.apache.flink.api.java.typeutils.runtime;

import org.apache.flink.annotation.Internal;
import org.apache.flink.api.common.typeutils.CompositeTypeComparator;
import org.apache.flink.api.common.typeutils.TypeComparator;
import org.apache.flink.api.common.typeutils.TypeSerializer;
import org.apache.flink.core.memory.DataInputView;
import org.apache.flink.core.memory.DataOutputView;
import org.apache.flink.core.memory.MemorySegment;
import org.apache.flink.types.NullKeyFieldException;
import org.apache.flink.util.InstantiationUtil;

import java.io.IOException;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.lang.reflect.Field;
import java.util.List;

@Internal
public final class PojoComparator&lt;T&gt; extends CompositeTypeComparator&lt;T&gt;
        implements java.io.Serializable {

    private static final long serialVersionUID = 1L;

    // Reflection fields for the comp fields
    private transient Field[] keyFields;

    private final TypeComparator&lt;Object&gt;[] comparators;

    private final int[] normalizedKeyLengths;

    private final int numLeadingNormalizableKeys;

    private final int normalizableKeyPrefixLen;

    private final boolean invertNormKey;

    private TypeSerializer&lt;T&gt; serializer;

    private final Class&lt;T&gt; type;

    @SuppressWarnings(&quot;unchecked&quot;)
    public PojoComparator(
            Field[] keyFields,
            TypeComparator&lt;?&gt;[] comparators,
            TypeSerializer&lt;T&gt; serializer,
<span class="fc" id="L65">            Class&lt;T&gt; type) {</span>
<span class="fc" id="L66">        this.keyFields = keyFields;</span>
<span class="fc" id="L67">        this.comparators = (TypeComparator&lt;Object&gt;[]) comparators;</span>

<span class="fc" id="L69">        this.type = type;</span>
<span class="fc" id="L70">        this.serializer = serializer;</span>

        // set up auxiliary fields for normalized key support
<span class="fc" id="L73">        this.normalizedKeyLengths = new int[keyFields.length];</span>
<span class="fc" id="L74">        int nKeys = 0;</span>
<span class="fc" id="L75">        int nKeyLen = 0;</span>
<span class="fc" id="L76">        boolean inverted = false;</span>

<span class="fc bfc" id="L78" title="All 2 branches covered.">        for (Field keyField : keyFields) {</span>
<span class="fc" id="L79">            keyField.setAccessible(true);</span>
        }

<span class="fc bfc" id="L82" title="All 2 branches covered.">        for (int i = 0; i &lt; this.comparators.length; i++) {</span>
<span class="fc" id="L83">            TypeComparator&lt;?&gt; k = this.comparators[i];</span>
<span class="pc bpc" id="L84" title="1 of 2 branches missed.">            if (k == null) {</span>
<span class="nc" id="L85">                throw new IllegalArgumentException(&quot;One of the passed comparators is null&quot;);</span>
            }
<span class="pc bpc" id="L87" title="1 of 2 branches missed.">            if (keyFields[i] == null) {</span>
<span class="nc" id="L88">                throw new IllegalArgumentException(&quot;One of the passed reflection fields is null&quot;);</span>
            }

            // as long as the leading keys support normalized keys, we can build up the composite
            // key
<span class="fc bfc" id="L93" title="All 2 branches covered.">            if (k.supportsNormalizedKey()) {</span>
<span class="fc bfc" id="L94" title="All 2 branches covered.">                if (i == 0) {</span>
                    // the first comparator decides whether we need to invert the key direction
<span class="fc" id="L96">                    inverted = k.invertNormalizedKey();</span>
<span class="pc bpc" id="L97" title="1 of 2 branches missed.">                } else if (k.invertNormalizedKey() != inverted) {</span>
                    // if a successor does not agree on the inversion direction, it cannot be part
                    // of the normalized key
<span class="nc" id="L100">                    break;</span>
                }

<span class="fc" id="L103">                nKeys++;</span>
<span class="fc" id="L104">                final int len = k.getNormalizeKeyLen();</span>
<span class="pc bpc" id="L105" title="1 of 2 branches missed.">                if (len &lt; 0) {</span>
<span class="nc" id="L106">                    throw new RuntimeException(</span>
                            &quot;Comparator &quot;
<span class="nc" id="L108">                                    + k.getClass().getName()</span>
                                    + &quot; specifies an invalid length for the normalized key: &quot;
                                    + len);
                }
<span class="fc" id="L112">                this.normalizedKeyLengths[i] = len;</span>
<span class="fc" id="L113">                nKeyLen += this.normalizedKeyLengths[i];</span>

<span class="fc bfc" id="L115" title="All 2 branches covered.">                if (nKeyLen &lt; 0) {</span>
                    // overflow, which means we are out of budget for normalized key space anyways
<span class="fc" id="L117">                    nKeyLen = Integer.MAX_VALUE;</span>
<span class="fc" id="L118">                    break;</span>
                }
            } else {
                break;
            }
        }
<span class="fc" id="L124">        this.numLeadingNormalizableKeys = nKeys;</span>
<span class="fc" id="L125">        this.normalizableKeyPrefixLen = nKeyLen;</span>
<span class="fc" id="L126">        this.invertNormKey = inverted;</span>
<span class="fc" id="L127">    }</span>

    @SuppressWarnings(&quot;unchecked&quot;)
<span class="nc" id="L130">    private PojoComparator(PojoComparator&lt;T&gt; toClone) {</span>
<span class="nc" id="L131">        this.keyFields = toClone.keyFields;</span>
<span class="nc" id="L132">        this.comparators = new TypeComparator[toClone.comparators.length];</span>

<span class="nc bnc" id="L134" title="All 2 branches missed.">        for (int i = 0; i &lt; toClone.comparators.length; i++) {</span>
<span class="nc" id="L135">            this.comparators[i] = toClone.comparators[i].duplicate();</span>
        }

<span class="nc" id="L138">        this.normalizedKeyLengths = toClone.normalizedKeyLengths;</span>
<span class="nc" id="L139">        this.numLeadingNormalizableKeys = toClone.numLeadingNormalizableKeys;</span>
<span class="nc" id="L140">        this.normalizableKeyPrefixLen = toClone.normalizableKeyPrefixLen;</span>
<span class="nc" id="L141">        this.invertNormKey = toClone.invertNormKey;</span>

<span class="nc" id="L143">        this.type = toClone.type;</span>

        try {
<span class="nc" id="L146">            this.serializer =</span>
                    (TypeSerializer&lt;T&gt;)
<span class="nc" id="L148">                            InstantiationUtil.deserializeObject(</span>
<span class="nc" id="L149">                                    InstantiationUtil.serializeObject(toClone.serializer),</span>
<span class="nc" id="L150">                                    Thread.currentThread().getContextClassLoader());</span>
<span class="nc" id="L151">        } catch (IOException | ClassNotFoundException e) {</span>
<span class="nc" id="L152">            throw new RuntimeException(&quot;Cannot copy serializer&quot;, e);</span>
<span class="nc" id="L153">        }</span>
<span class="nc" id="L154">    }</span>

    private void writeObject(ObjectOutputStream out) throws IOException, ClassNotFoundException {
<span class="nc" id="L157">        out.defaultWriteObject();</span>
<span class="nc" id="L158">        out.writeInt(keyFields.length);</span>
<span class="nc bnc" id="L159" title="All 2 branches missed.">        for (Field field : keyFields) {</span>
<span class="nc" id="L160">            FieldSerializer.serializeField(field, out);</span>
        }
<span class="nc" id="L162">    }</span>

    private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {
<span class="nc" id="L165">        in.defaultReadObject();</span>
<span class="nc" id="L166">        int numKeyFields = in.readInt();</span>
<span class="nc" id="L167">        keyFields = new Field[numKeyFields];</span>
<span class="nc bnc" id="L168" title="All 2 branches missed.">        for (int i = 0; i &lt; numKeyFields; i++) {</span>
<span class="nc" id="L169">            keyFields[i] = FieldSerializer.deserializeField(in);</span>
        }
<span class="nc" id="L171">    }</span>

    public Field[] getKeyFields() {
<span class="nc" id="L174">        return this.keyFields;</span>
    }

    @SuppressWarnings({&quot;rawtypes&quot;, &quot;unchecked&quot;})
    @Override
    public void getFlatComparator(List&lt;TypeComparator&gt; flatComparators) {
<span class="nc bnc" id="L180" title="All 2 branches missed.">        for (int i = 0; i &lt; comparators.length; i++) {</span>
<span class="nc bnc" id="L181" title="All 2 branches missed.">            if (comparators[i] instanceof CompositeTypeComparator) {</span>
<span class="nc" id="L182">                ((CompositeTypeComparator) comparators[i]).getFlatComparator(flatComparators);</span>
            } else {
<span class="nc" id="L184">                flatComparators.add(comparators[i]);</span>
            }
        }
<span class="nc" id="L187">    }</span>

    /** This method is handling the IllegalAccess exceptions of Field.get() */
    public final Object accessField(Field field, Object object) {
        try {
<span class="fc" id="L192">            object = field.get(object);</span>
<span class="nc" id="L193">        } catch (NullPointerException npex) {</span>
<span class="nc" id="L194">            throw new NullKeyFieldException(</span>
                    &quot;Unable to access field &quot; + field + &quot; on object &quot; + object);
<span class="nc" id="L196">        } catch (IllegalAccessException iaex) {</span>
<span class="nc" id="L197">            throw new RuntimeException(</span>
                    &quot;This should not happen since we call setAccesssible(true) in the ctor.&quot;
                            + &quot; fields: &quot;
                            + field
                            + &quot; obj: &quot;
                            + object);
<span class="fc" id="L203">        }</span>
<span class="fc" id="L204">        return object;</span>
    }

    @Override
    public int hash(T value) {
<span class="fc" id="L209">        int i = 0;</span>
<span class="fc" id="L210">        int code = 0;</span>
<span class="fc bfc" id="L211" title="All 2 branches covered.">        for (; i &lt; this.keyFields.length; i++) {</span>
<span class="fc" id="L212">            code *= TupleComparatorBase.HASH_SALT[i &amp; 0x1F];</span>
            try {
<span class="fc" id="L214">                code += this.comparators[i].hash(accessField(keyFields[i], value));</span>
<span class="nc" id="L215">            } catch (NullPointerException npe) {</span>
<span class="nc" id="L216">                throw new RuntimeException(</span>
                        &quot;A NullPointerException occurred while accessing a key field in a POJO. &quot;
                                + &quot;Most likely, the value grouped/joined on is null. Field name: &quot;
<span class="nc" id="L219">                                + keyFields[i].getName(),</span>
                        npe);
<span class="fc" id="L221">            }</span>
        }
<span class="fc" id="L223">        return code;</span>
    }

    @Override
    public void setReference(T toCompare) {
<span class="nc" id="L228">        int i = 0;</span>
<span class="nc bnc" id="L229" title="All 2 branches missed.">        for (; i &lt; this.keyFields.length; i++) {</span>
<span class="nc" id="L230">            this.comparators[i].setReference(accessField(keyFields[i], toCompare));</span>
        }
<span class="nc" id="L232">    }</span>

    @Override
    public boolean equalToReference(T candidate) {
<span class="nc" id="L236">        int i = 0;</span>
<span class="nc bnc" id="L237" title="All 2 branches missed.">        for (; i &lt; this.keyFields.length; i++) {</span>
<span class="nc bnc" id="L238" title="All 2 branches missed.">            if (!this.comparators[i].equalToReference(accessField(keyFields[i], candidate))) {</span>
<span class="nc" id="L239">                return false;</span>
            }
        }
<span class="nc" id="L242">        return true;</span>
    }

    @Override
    public int compareToReference(TypeComparator&lt;T&gt; referencedComparator) {
<span class="nc" id="L247">        PojoComparator&lt;T&gt; other = (PojoComparator&lt;T&gt;) referencedComparator;</span>

<span class="nc" id="L249">        int i = 0;</span>
        try {
<span class="nc bnc" id="L251" title="All 2 branches missed.">            for (; i &lt; this.keyFields.length; i++) {</span>
<span class="nc" id="L252">                int cmp = this.comparators[i].compareToReference(other.comparators[i]);</span>
<span class="nc bnc" id="L253" title="All 2 branches missed.">                if (cmp != 0) {</span>
<span class="nc" id="L254">                    return cmp;</span>
                }
            }
<span class="nc" id="L257">            return 0;</span>
<span class="nc" id="L258">        } catch (NullPointerException npex) {</span>
<span class="nc" id="L259">            throw new NullKeyFieldException(this.keyFields[i].toString());</span>
        }
    }

    @Override
    public int compare(T first, T second) {
<span class="nc" id="L265">        int i = 0;</span>
<span class="nc bnc" id="L266" title="All 2 branches missed.">        for (; i &lt; keyFields.length; i++) {</span>
<span class="nc" id="L267">            int cmp =</span>
<span class="nc" id="L268">                    comparators[i].compare(</span>
<span class="nc" id="L269">                            accessField(keyFields[i], first), accessField(keyFields[i], second));</span>
<span class="nc bnc" id="L270" title="All 2 branches missed.">            if (cmp != 0) {</span>
<span class="nc" id="L271">                return cmp;</span>
            }
        }

<span class="nc" id="L275">        return 0;</span>
    }

    @Override
    public int compareSerialized(DataInputView firstSource, DataInputView secondSource)
            throws IOException {
<span class="nc" id="L281">        T first = this.serializer.createInstance();</span>
<span class="nc" id="L282">        T second = this.serializer.createInstance();</span>

<span class="nc" id="L284">        first = this.serializer.deserialize(first, firstSource);</span>
<span class="nc" id="L285">        second = this.serializer.deserialize(second, secondSource);</span>

<span class="nc" id="L287">        return this.compare(first, second);</span>
    }

    @Override
    public boolean supportsNormalizedKey() {
<span class="pc bpc" id="L292" title="1 of 2 branches missed.">        return this.numLeadingNormalizableKeys &gt; 0;</span>
    }

    @Override
    public int getNormalizeKeyLen() {
<span class="fc" id="L297">        return this.normalizableKeyPrefixLen;</span>
    }

    @Override
    public boolean isNormalizedKeyPrefixOnly(int keyBytes) {
<span class="nc bnc" id="L302" title="All 6 branches missed.">        return this.numLeadingNormalizableKeys &lt; this.keyFields.length</span>
                || this.normalizableKeyPrefixLen == Integer.MAX_VALUE
                || this.normalizableKeyPrefixLen &gt; keyBytes;
    }

    @Override
    public void putNormalizedKey(T value, MemorySegment target, int offset, int numBytes) {
<span class="nc" id="L309">        int i = 0;</span>
<span class="nc bnc" id="L310" title="All 4 branches missed.">        for (; i &lt; this.numLeadingNormalizableKeys &amp;&amp; numBytes &gt; 0; i++) {</span>
<span class="nc" id="L311">            int len = this.normalizedKeyLengths[i];</span>
<span class="nc bnc" id="L312" title="All 2 branches missed.">            len = numBytes &gt;= len ? len : numBytes;</span>
<span class="nc" id="L313">            this.comparators[i].putNormalizedKey(</span>
<span class="nc" id="L314">                    accessField(keyFields[i], value), target, offset, len);</span>
<span class="nc" id="L315">            numBytes -= len;</span>
<span class="nc" id="L316">            offset += len;</span>
        }
<span class="nc" id="L318">    }</span>

    @Override
    public boolean invertNormalizedKey() {
<span class="fc" id="L322">        return this.invertNormKey;</span>
    }

    @Override
    public boolean supportsSerializationWithKeyNormalization() {
<span class="nc" id="L327">        return false;</span>
    }

    @Override
    public void writeWithKeyNormalization(T record, DataOutputView target) throws IOException {
<span class="nc" id="L332">        throw new UnsupportedOperationException();</span>
    }

    @Override
    public T readWithKeyDenormalization(T reuse, DataInputView source) throws IOException {
<span class="nc" id="L337">        throw new UnsupportedOperationException();</span>
    }

    @Override
    public PojoComparator&lt;T&gt; duplicate() {
<span class="nc" id="L342">        return new PojoComparator&lt;T&gt;(this);</span>
    }

    @Override
    public int extractKeys(Object record, Object[] target, int index) {
<span class="nc" id="L347">        int localIndex = index;</span>
<span class="nc bnc" id="L348" title="All 2 branches missed.">        for (int i = 0; i &lt; comparators.length; i++) {</span>
<span class="nc" id="L349">            localIndex +=</span>
<span class="nc" id="L350">                    comparators[i].extractKeys(</span>
<span class="nc" id="L351">                            accessField(keyFields[i], record), target, localIndex);</span>
        }
<span class="nc" id="L353">        return localIndex - index;</span>
    }

    // --------------------------------------------------------------------------------------------
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.7.202105040129</span></div></body></html>