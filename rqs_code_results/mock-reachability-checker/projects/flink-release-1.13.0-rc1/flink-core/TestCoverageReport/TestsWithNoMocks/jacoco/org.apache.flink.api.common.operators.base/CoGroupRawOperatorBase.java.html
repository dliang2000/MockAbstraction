<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>CoGroupRawOperatorBase.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Flink : Core</a> &gt; <a href="index.source.html" class="el_package">org.apache.flink.api.common.operators.base</a> &gt; <span class="el_source">CoGroupRawOperatorBase.java</span></div><h1>CoGroupRawOperatorBase.java</h1><pre class="source lang-java linenums">/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * &quot;License&quot;); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.flink.api.common.operators.base;

import org.apache.flink.annotation.Internal;
import org.apache.flink.api.common.ExecutionConfig;
import org.apache.flink.api.common.InvalidProgramException;
import org.apache.flink.api.common.functions.CoGroupFunction;
import org.apache.flink.api.common.functions.RuntimeContext;
import org.apache.flink.api.common.functions.util.CopyingListCollector;
import org.apache.flink.api.common.functions.util.FunctionUtils;
import org.apache.flink.api.common.operators.BinaryOperatorInformation;
import org.apache.flink.api.common.operators.DualInputOperator;
import org.apache.flink.api.common.operators.Ordering;
import org.apache.flink.api.common.operators.util.UserCodeClassWrapper;
import org.apache.flink.api.common.operators.util.UserCodeObjectWrapper;
import org.apache.flink.api.common.operators.util.UserCodeWrapper;
import org.apache.flink.api.common.typeinfo.TypeInformation;
import org.apache.flink.api.common.typeutils.CompositeType;
import org.apache.flink.api.common.typeutils.TypeComparator;
import org.apache.flink.api.common.typeutils.TypeSerializer;
import org.apache.flink.util.Collector;

import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.Comparator;
import java.util.Iterator;
import java.util.List;

/** @see org.apache.flink.api.common.functions.CoGroupFunction */
@Internal
public class CoGroupRawOperatorBase&lt;IN1, IN2, OUT, FT extends CoGroupFunction&lt;IN1, IN2, OUT&gt;&gt;
        extends DualInputOperator&lt;IN1, IN2, OUT, FT&gt; {

    /** The ordering for the order inside a group from input one. */
    private Ordering groupOrder1;

    /** The ordering for the order inside a group from input two. */
    private Ordering groupOrder2;

    // --------------------------------------------------------------------------------------------
    private boolean combinableFirst;

    private boolean combinableSecond;

    public CoGroupRawOperatorBase(
            UserCodeWrapper&lt;FT&gt; udf,
            BinaryOperatorInformation&lt;IN1, IN2, OUT&gt; operatorInfo,
            int[] keyPositions1,
            int[] keyPositions2,
            String name) {
<span class="nc" id="L69">        super(udf, operatorInfo, keyPositions1, keyPositions2, name);</span>
<span class="nc" id="L70">        this.combinableFirst = false;</span>
<span class="nc" id="L71">        this.combinableSecond = false;</span>
<span class="nc" id="L72">    }</span>

    public CoGroupRawOperatorBase(
            FT udf,
            BinaryOperatorInformation&lt;IN1, IN2, OUT&gt; operatorInfo,
            int[] keyPositions1,
            int[] keyPositions2,
            String name) {
<span class="nc" id="L80">        this(new UserCodeObjectWrapper&lt;FT&gt;(udf), operatorInfo, keyPositions1, keyPositions2, name);</span>
<span class="nc" id="L81">    }</span>

    public CoGroupRawOperatorBase(
            Class&lt;? extends FT&gt; udf,
            BinaryOperatorInformation&lt;IN1, IN2, OUT&gt; operatorInfo,
            int[] keyPositions1,
            int[] keyPositions2,
            String name) {
<span class="nc" id="L89">        this(new UserCodeClassWrapper&lt;FT&gt;(udf), operatorInfo, keyPositions1, keyPositions2, name);</span>
<span class="nc" id="L90">    }</span>

    // --------------------------------------------------------------------------------------------
    /**
     * Sets the order of the elements within a group for the given input.
     *
     * @param inputNum The number of the input (here either &lt;i&gt;0&lt;/i&gt; or &lt;i&gt;1&lt;/i&gt;).
     * @param order The order for the elements in a group.
     */
    public void setGroupOrder(int inputNum, Ordering order) {
<span class="nc bnc" id="L100" title="All 2 branches missed.">        if (inputNum == 0) {</span>
<span class="nc" id="L101">            this.groupOrder1 = order;</span>
<span class="nc bnc" id="L102" title="All 2 branches missed.">        } else if (inputNum == 1) {</span>
<span class="nc" id="L103">            this.groupOrder2 = order;</span>
        } else {
<span class="nc" id="L105">            throw new IndexOutOfBoundsException();</span>
        }
<span class="nc" id="L107">    }</span>

    /**
     * Sets the order of the elements within a group for the first input.
     *
     * @param order The order for the elements in a group.
     */
    public void setGroupOrderForInputOne(Ordering order) {
<span class="nc" id="L115">        setGroupOrder(0, order);</span>
<span class="nc" id="L116">    }</span>

    /**
     * Sets the order of the elements within a group for the second input.
     *
     * @param order The order for the elements in a group.
     */
    public void setGroupOrderForInputTwo(Ordering order) {
<span class="nc" id="L124">        setGroupOrder(1, order);</span>
<span class="nc" id="L125">    }</span>

    /**
     * Gets the value order for an input, i.e. the order of elements within a group. If no such
     * order has been set, this method returns null.
     *
     * @param inputNum The number of the input (here either &lt;i&gt;0&lt;/i&gt; or &lt;i&gt;1&lt;/i&gt;).
     * @return The group order.
     */
    public Ordering getGroupOrder(int inputNum) {
<span class="nc bnc" id="L135" title="All 2 branches missed.">        if (inputNum == 0) {</span>
<span class="nc" id="L136">            return this.groupOrder1;</span>
<span class="nc bnc" id="L137" title="All 2 branches missed.">        } else if (inputNum == 1) {</span>
<span class="nc" id="L138">            return this.groupOrder2;</span>
        } else {
<span class="nc" id="L140">            throw new IndexOutOfBoundsException();</span>
        }
    }

    /**
     * Gets the order of elements within a group for the first input. If no such order has been set,
     * this method returns null.
     *
     * @return The group order for the first input.
     */
    public Ordering getGroupOrderForInputOne() {
<span class="nc" id="L151">        return getGroupOrder(0);</span>
    }

    /**
     * Gets the order of elements within a group for the second input. If no such order has been
     * set, this method returns null.
     *
     * @return The group order for the second input.
     */
    public Ordering getGroupOrderForInputTwo() {
<span class="nc" id="L161">        return getGroupOrder(1);</span>
    }

    // --------------------------------------------------------------------------------------------
    public boolean isCombinableFirst() {
<span class="nc" id="L166">        return this.combinableFirst;</span>
    }

    public void setCombinableFirst(boolean combinableFirst) {
<span class="nc" id="L170">        this.combinableFirst = combinableFirst;</span>
<span class="nc" id="L171">    }</span>

    public boolean isCombinableSecond() {
<span class="nc" id="L174">        return this.combinableSecond;</span>
    }

    public void setCombinableSecond(boolean combinableSecond) {
<span class="nc" id="L178">        this.combinableSecond = combinableSecond;</span>
<span class="nc" id="L179">    }</span>

    // ------------------------------------------------------------------------
    @Override
    protected List&lt;OUT&gt; executeOnCollections(
            List&lt;IN1&gt; input1, List&lt;IN2&gt; input2, RuntimeContext ctx, ExecutionConfig executionConfig)
            throws Exception {
        // --------------------------------------------------------------------
        // Setup
        // --------------------------------------------------------------------
<span class="nc" id="L189">        TypeInformation&lt;IN1&gt; inputType1 = getOperatorInfo().getFirstInputType();</span>
<span class="nc" id="L190">        TypeInformation&lt;IN2&gt; inputType2 = getOperatorInfo().getSecondInputType();</span>

<span class="nc" id="L192">        int[] inputKeys1 = getKeyColumns(0);</span>
<span class="nc" id="L193">        int[] inputKeys2 = getKeyColumns(1);</span>

<span class="nc" id="L195">        boolean[] inputSortDirections1 = new boolean[inputKeys1.length];</span>
<span class="nc" id="L196">        boolean[] inputSortDirections2 = new boolean[inputKeys2.length];</span>

<span class="nc" id="L198">        Arrays.fill(inputSortDirections1, true);</span>
<span class="nc" id="L199">        Arrays.fill(inputSortDirections2, true);</span>

<span class="nc" id="L201">        final TypeSerializer&lt;IN1&gt; inputSerializer1 = inputType1.createSerializer(executionConfig);</span>
<span class="nc" id="L202">        final TypeSerializer&lt;IN2&gt; inputSerializer2 = inputType2.createSerializer(executionConfig);</span>

<span class="nc" id="L204">        final TypeComparator&lt;IN1&gt; inputComparator1 =</span>
<span class="nc" id="L205">                getTypeComparator(executionConfig, inputType1, inputKeys1, inputSortDirections1);</span>
<span class="nc" id="L206">        final TypeComparator&lt;IN2&gt; inputComparator2 =</span>
<span class="nc" id="L207">                getTypeComparator(executionConfig, inputType2, inputKeys2, inputSortDirections2);</span>

<span class="nc" id="L209">        SimpleListIterable&lt;IN1&gt; iterator1 =</span>
                new SimpleListIterable&lt;IN1&gt;(input1, inputComparator1, inputSerializer1);
<span class="nc" id="L211">        SimpleListIterable&lt;IN2&gt; iterator2 =</span>
                new SimpleListIterable&lt;IN2&gt;(input2, inputComparator2, inputSerializer2);

        // --------------------------------------------------------------------
        // Run UDF
        // --------------------------------------------------------------------
<span class="nc" id="L217">        CoGroupFunction&lt;IN1, IN2, OUT&gt; function = userFunction.getUserCodeObject();</span>

<span class="nc" id="L219">        FunctionUtils.setFunctionRuntimeContext(function, ctx);</span>
<span class="nc" id="L220">        FunctionUtils.openFunction(function, parameters);</span>

<span class="nc" id="L222">        List&lt;OUT&gt; result = new ArrayList&lt;OUT&gt;();</span>
<span class="nc" id="L223">        Collector&lt;OUT&gt; resultCollector =</span>
                new CopyingListCollector&lt;OUT&gt;(
                        result,
<span class="nc" id="L226">                        getOperatorInfo().getOutputType().createSerializer(executionConfig));</span>

<span class="nc" id="L228">        function.coGroup(iterator1, iterator2, resultCollector);</span>

<span class="nc" id="L230">        FunctionUtils.closeFunction(function);</span>

<span class="nc" id="L232">        return result;</span>
    }

    private &lt;T&gt; TypeComparator&lt;T&gt; getTypeComparator(
            ExecutionConfig executionConfig,
            TypeInformation&lt;T&gt; inputType,
            int[] inputKeys,
            boolean[] inputSortDirections) {
<span class="nc bnc" id="L240" title="All 2 branches missed.">        if (!(inputType instanceof CompositeType)) {</span>
<span class="nc" id="L241">            throw new InvalidProgramException(&quot;Input types of coGroup must be composite types.&quot;);</span>
        }

<span class="nc" id="L244">        return ((CompositeType&lt;T&gt;) inputType)</span>
<span class="nc" id="L245">                .createComparator(inputKeys, inputSortDirections, 0, executionConfig);</span>
    }

    public static class SimpleListIterable&lt;IN&gt; implements Iterable&lt;IN&gt; {
        private List&lt;IN&gt; values;
        private TypeSerializer&lt;IN&gt; serializer;
        private boolean copy;

        public SimpleListIterable(
                List&lt;IN&gt; values, final TypeComparator&lt;IN&gt; comparator, TypeSerializer&lt;IN&gt; serializer)
<span class="nc" id="L255">                throws IOException {</span>
<span class="nc" id="L256">            this.values = values;</span>
<span class="nc" id="L257">            this.serializer = serializer;</span>

<span class="nc" id="L259">            Collections.sort(</span>
                    values,
<span class="nc" id="L261">                    new Comparator&lt;IN&gt;() {</span>
                        @Override
                        public int compare(IN o1, IN o2) {
<span class="nc" id="L264">                            return comparator.compare(o1, o2);</span>
                        }
                    });
<span class="nc" id="L267">        }</span>

        @Override
        public Iterator&lt;IN&gt; iterator() {
<span class="nc" id="L271">            return new SimpleListIterator&lt;IN&gt;(values, serializer);</span>
        }

        protected class SimpleListIterator&lt;IN&gt; implements Iterator&lt;IN&gt; {
            private final List&lt;IN&gt; values;
            private final TypeSerializer&lt;IN&gt; serializer;
<span class="nc" id="L277">            private int pos = 0;</span>

<span class="nc" id="L279">            public SimpleListIterator(List&lt;IN&gt; values, TypeSerializer&lt;IN&gt; serializer) {</span>
<span class="nc" id="L280">                this.values = values;</span>
<span class="nc" id="L281">                this.serializer = serializer;</span>
<span class="nc" id="L282">            }</span>

            @Override
            public boolean hasNext() {
<span class="nc bnc" id="L286" title="All 2 branches missed.">                return pos &lt; values.size();</span>
            }

            @Override
            public IN next() {
<span class="nc" id="L291">                IN current = values.get(pos++);</span>
<span class="nc" id="L292">                return serializer.copy(current);</span>
            }

            @Override
            public void remove() { // unused
<span class="nc" id="L297">            }</span>
        }
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.7.202105040129</span></div></body></html>