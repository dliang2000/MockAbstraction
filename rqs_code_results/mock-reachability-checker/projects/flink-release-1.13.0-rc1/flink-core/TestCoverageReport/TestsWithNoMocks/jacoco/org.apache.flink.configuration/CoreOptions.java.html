<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>CoreOptions.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Flink : Core</a> &gt; <a href="index.source.html" class="el_package">org.apache.flink.configuration</a> &gt; <span class="el_source">CoreOptions.java</span></div><h1>CoreOptions.java</h1><pre class="source lang-java linenums">/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * &quot;License&quot;); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.apache.flink.configuration;

import org.apache.flink.annotation.PublicEvolving;
import org.apache.flink.annotation.docs.ConfigGroup;
import org.apache.flink.annotation.docs.ConfigGroups;
import org.apache.flink.annotation.docs.Documentation;
import org.apache.flink.configuration.description.Description;

import org.apache.flink.shaded.guava18.com.google.common.base.Splitter;
import org.apache.flink.shaded.guava18.com.google.common.collect.Iterables;

import static org.apache.flink.configuration.ConfigOptions.key;

/** The set of configuration options for core parameters. */
@PublicEvolving
@ConfigGroups(groups = {@ConfigGroup(name = &quot;Environment&quot;, keyPrefix = &quot;env&quot;)})
<span class="nc" id="L35">public class CoreOptions {</span>

    // ------------------------------------------------------------------------
    //  Classloading Parameters
    // ------------------------------------------------------------------------

    /**
     * Defines the class resolution strategy when loading classes from user code, meaning whether to
     * first check the user code jar ({@code &quot;child-first&quot;}) or the application classpath ({@code
     * &quot;parent-first&quot;})
     *
     * &lt;p&gt;The default settings indicate to load classes first from the user code jar, which means
     * that user code jars can include and load different dependencies than Flink uses
     * (transitively).
     *
     * &lt;p&gt;Exceptions to the rules are defined via {@link #ALWAYS_PARENT_FIRST_LOADER_PATTERNS}.
     */
    @Documentation.Section(Documentation.Sections.EXPERT_CLASS_LOADING)
<span class="fc" id="L53">    public static final ConfigOption&lt;String&gt; CLASSLOADER_RESOLVE_ORDER =</span>
<span class="fc" id="L54">            ConfigOptions.key(&quot;classloader.resolve-order&quot;)</span>
<span class="fc" id="L55">                    .defaultValue(&quot;child-first&quot;)</span>
<span class="fc" id="L56">                    .withDescription(</span>
                            &quot;Defines the class resolution strategy when loading classes from user code, meaning whether to&quot;
                                    + &quot; first check the user code jar (\&quot;child-first\&quot;) or the application classpath (\&quot;parent-first\&quot;).&quot;
                                    + &quot; The default settings indicate to load classes first from the user code jar, which means that user code&quot;
                                    + &quot; jars can include and load different dependencies than Flink uses (transitively).&quot;);

    /**
     * The namespace patterns for classes that are loaded with a preference from the parent
     * classloader, meaning the application class path, rather than any user code jar file. This
     * option only has an effect when {@link #CLASSLOADER_RESOLVE_ORDER} is set to {@code
     * &quot;child-first&quot;}.
     *
     * &lt;p&gt;It is important that all classes whose objects move between Flink's runtime and any user
     * code (including Flink connectors that run as part of the user code) are covered by these
     * patterns here. Otherwise it is be possible that the Flink runtime and the user code load two
     * different copies of a class through the different class loaders. That leads to errors like &quot;X
     * cannot be cast to X&quot; exceptions, where both class names are equal, or &quot;X cannot be assigned
     * to Y&quot;, where X should be a subclass of Y.
     *
     * &lt;p&gt;The following classes are loaded parent-first, to avoid any duplication:
     *
     * &lt;ul&gt;
     *   &lt;li&gt;All core Java classes (java.*), because they must never be duplicated.
     *   &lt;li&gt;All core Scala classes (scala.*). Currently Scala is used in the Flink runtime and in
     *       the user code, and some Scala classes cross the boundary, such as the &lt;i&gt;FunctionX&lt;/i&gt;
     *       classes. That may change if Scala eventually lives purely as part of the user code.
     *   &lt;li&gt;All Flink classes (org.apache.flink.*). Note that this means that connectors and
     *       formats (flink-avro, etc) are loaded parent-first as well if they are in the core
     *       classpath.
     *   &lt;li&gt;Java annotations and loggers, defined by the following list:
     *       javax.annotation;org.slf4j;org.apache.log4j;org.apache.logging;org.apache.commons.logging;ch.qos.logback.
     *       This is done for convenience, to avoid duplication of annotations and multiple log
     *       bindings.
     * &lt;/ul&gt;
     */
    @Documentation.Section(Documentation.Sections.EXPERT_CLASS_LOADING)
<span class="fc" id="L92">    public static final ConfigOption&lt;String&gt; ALWAYS_PARENT_FIRST_LOADER_PATTERNS =</span>
<span class="fc" id="L93">            ConfigOptions.key(&quot;classloader.parent-first-patterns.default&quot;)</span>
<span class="fc" id="L94">                    .defaultValue(</span>
                            &quot;java.;scala.;org.apache.flink.;com.esotericsoftware.kryo;org.apache.hadoop.;javax.annotation.;org.slf4j;org.apache.log4j;org.apache.logging;org.apache.commons.logging;ch.qos.logback;org.xml;javax.xml;org.apache.xerces;org.w3c&quot;)
<span class="fc" id="L96">                    .withDeprecatedKeys(&quot;classloader.parent-first-patterns&quot;)</span>
<span class="fc" id="L97">                    .withDescription(</span>
                            &quot;A (semicolon-separated) list of patterns that specifies which classes should always be&quot;
                                    + &quot; resolved through the parent ClassLoader first. A pattern is a simple prefix that is checked against&quot;
                                    + &quot; the fully qualified class name. This setting should generally not be modified. To add another pattern we&quot;
                                    + &quot; recommend to use \&quot;classloader.parent-first-patterns.additional\&quot; instead.&quot;);

    @Documentation.Section(Documentation.Sections.EXPERT_CLASS_LOADING)
<span class="fc" id="L104">    public static final ConfigOption&lt;String&gt; ALWAYS_PARENT_FIRST_LOADER_PATTERNS_ADDITIONAL =</span>
<span class="fc" id="L105">            ConfigOptions.key(&quot;classloader.parent-first-patterns.additional&quot;)</span>
<span class="fc" id="L106">                    .defaultValue(&quot;&quot;)</span>
<span class="fc" id="L107">                    .withDescription(</span>
                            &quot;A (semicolon-separated) list of patterns that specifies which classes should always be&quot;
                                    + &quot; resolved through the parent ClassLoader first. A pattern is a simple prefix that is checked against&quot;
                                    + &quot; the fully qualified class name. These patterns are appended to \&quot;&quot;
<span class="fc" id="L111">                                    + ALWAYS_PARENT_FIRST_LOADER_PATTERNS.key()</span>
                                    + &quot;\&quot;.&quot;);

    @Documentation.Section(Documentation.Sections.EXPERT_CLASS_LOADING)
<span class="fc" id="L115">    public static final ConfigOption&lt;Boolean&gt; FAIL_ON_USER_CLASS_LOADING_METASPACE_OOM =</span>
<span class="fc" id="L116">            ConfigOptions.key(&quot;classloader.fail-on-metaspace-oom-error&quot;)</span>
<span class="fc" id="L117">                    .booleanType()</span>
<span class="fc" id="L118">                    .defaultValue(true)</span>
<span class="fc" id="L119">                    .withDescription(</span>
                            &quot;Fail Flink JVM processes if 'OutOfMemoryError: Metaspace' is &quot;
                                    + &quot;thrown while trying to load a user code class.&quot;);

    public static String[] getParentFirstLoaderPatterns(Configuration config) {
<span class="fc" id="L124">        String base = config.getString(ALWAYS_PARENT_FIRST_LOADER_PATTERNS);</span>
<span class="fc" id="L125">        String append = config.getString(ALWAYS_PARENT_FIRST_LOADER_PATTERNS_ADDITIONAL);</span>
<span class="fc" id="L126">        return parseParentFirstLoaderPatterns(base, append);</span>
    }

    @Documentation.Section(Documentation.Sections.EXPERT_CLASS_LOADING)
<span class="fc" id="L130">    public static final ConfigOption&lt;Boolean&gt; CHECK_LEAKED_CLASSLOADER =</span>
<span class="fc" id="L131">            ConfigOptions.key(&quot;classloader.check-leaked-classloader&quot;)</span>
<span class="fc" id="L132">                    .booleanType()</span>
<span class="fc" id="L133">                    .defaultValue(true)</span>
<span class="fc" id="L134">                    .withDescription(</span>
                            &quot;Fails attempts at loading classes if the user classloader of a job is used after it has &quot;
                                    + &quot;terminated.\n&quot;
                                    + &quot;This is usually caused by the classloader being leaked by lingering threads or misbehaving libraries, &quot;
                                    + &quot;which may also result in the classloader being used by other jobs.\n&quot;
                                    + &quot;This check should only be disabled if such a leak prevents further jobs from running.&quot;);

    /**
     * Plugin-specific option of {@link #ALWAYS_PARENT_FIRST_LOADER_PATTERNS}. Plugins use this
     * parent first list instead of the global version.
     */
    @Documentation.ExcludeFromDocumentation(
            &quot;Plugin classloader list is considered an implementation detail. &quot;
                    + &quot;Configuration only included in case to mitigate unintended side-effects of this young feature.&quot;)
<span class="fc" id="L148">    public static final ConfigOption&lt;String&gt; PLUGIN_ALWAYS_PARENT_FIRST_LOADER_PATTERNS =</span>
<span class="fc" id="L149">            ConfigOptions.key(&quot;plugin.classloader.parent-first-patterns.default&quot;)</span>
<span class="fc" id="L150">                    .stringType()</span>
<span class="fc" id="L151">                    .defaultValue(</span>
                            &quot;java.;scala.;org.apache.flink.;javax.annotation.;org.slf4j;org.apache.log4j;org.apache&quot;
                                    + &quot;.logging;org.apache.commons.logging;ch.qos.logback&quot;)
<span class="fc" id="L154">                    .withDescription(</span>
                            &quot;A (semicolon-separated) list of patterns that specifies which classes should always be&quot;
                                    + &quot; resolved through the plugin parent ClassLoader first. A pattern is a simple prefix that is checked &quot;
                                    + &quot; against the fully qualified class name. This setting should generally not be modified. To add another &quot;
                                    + &quot; pattern we recommend to use \&quot;plugin.classloader.parent-first-patterns.additional\&quot; instead.&quot;);

    @Documentation.ExcludeFromDocumentation(
            &quot;Plugin classloader list is considered an implementation detail. &quot;
                    + &quot;Configuration only included in case to mitigate unintended side-effects of this young feature.&quot;)
<span class="fc" id="L163">    public static final ConfigOption&lt;String&gt; PLUGIN_ALWAYS_PARENT_FIRST_LOADER_PATTERNS_ADDITIONAL =</span>
<span class="fc" id="L164">            ConfigOptions.key(&quot;plugin.classloader.parent-first-patterns.additional&quot;)</span>
<span class="fc" id="L165">                    .stringType()</span>
<span class="fc" id="L166">                    .defaultValue(&quot;&quot;)</span>
<span class="fc" id="L167">                    .withDescription(</span>
                            &quot;A (semicolon-separated) list of patterns that specifies which classes should always be&quot;
                                    + &quot; resolved through the plugin parent ClassLoader first. A pattern is a simple prefix that is checked &quot;
                                    + &quot; against the fully qualified class name. These patterns are appended to \&quot;&quot;
<span class="fc" id="L171">                                    + PLUGIN_ALWAYS_PARENT_FIRST_LOADER_PATTERNS.key()</span>
                                    + &quot;\&quot;.&quot;);

    public static String[] getPluginParentFirstLoaderPatterns(Configuration config) {
<span class="fc" id="L175">        String base = config.getString(PLUGIN_ALWAYS_PARENT_FIRST_LOADER_PATTERNS);</span>
<span class="fc" id="L176">        String append = config.getString(PLUGIN_ALWAYS_PARENT_FIRST_LOADER_PATTERNS_ADDITIONAL);</span>
<span class="fc" id="L177">        return parseParentFirstLoaderPatterns(base, append);</span>
    }

    private static String[] parseParentFirstLoaderPatterns(String base, String append) {
<span class="fc" id="L181">        Splitter splitter = Splitter.on(';').omitEmptyStrings();</span>
<span class="fc" id="L182">        return Iterables.toArray(</span>
<span class="fc" id="L183">                Iterables.concat(splitter.split(base), splitter.split(append)), String.class);</span>
    }

    // ------------------------------------------------------------------------
    //  process parameters
    // ------------------------------------------------------------------------

<span class="fc" id="L190">    public static final ConfigOption&lt;String&gt; FLINK_JVM_OPTIONS =</span>
<span class="fc" id="L191">            ConfigOptions.key(&quot;env.java.opts&quot;)</span>
<span class="fc" id="L192">                    .stringType()</span>
<span class="fc" id="L193">                    .defaultValue(&quot;&quot;)</span>
<span class="fc" id="L194">                    .withDescription(</span>
<span class="fc" id="L195">                            Description.builder()</span>
<span class="fc" id="L196">                                    .text(</span>
                                            &quot;Java options to start the JVM of all Flink processes with.&quot;)
<span class="fc" id="L198">                                    .build());</span>

<span class="fc" id="L200">    public static final ConfigOption&lt;String&gt; FLINK_JM_JVM_OPTIONS =</span>
<span class="fc" id="L201">            ConfigOptions.key(&quot;env.java.opts.jobmanager&quot;)</span>
<span class="fc" id="L202">                    .stringType()</span>
<span class="fc" id="L203">                    .defaultValue(&quot;&quot;)</span>
<span class="fc" id="L204">                    .withDescription(</span>
<span class="fc" id="L205">                            Description.builder()</span>
<span class="fc" id="L206">                                    .text(&quot;Java options to start the JVM of the JobManager with.&quot;)</span>
<span class="fc" id="L207">                                    .build());</span>

<span class="fc" id="L209">    public static final ConfigOption&lt;String&gt; FLINK_TM_JVM_OPTIONS =</span>
<span class="fc" id="L210">            ConfigOptions.key(&quot;env.java.opts.taskmanager&quot;)</span>
<span class="fc" id="L211">                    .stringType()</span>
<span class="fc" id="L212">                    .defaultValue(&quot;&quot;)</span>
<span class="fc" id="L213">                    .withDescription(</span>
<span class="fc" id="L214">                            Description.builder()</span>
<span class="fc" id="L215">                                    .text(&quot;Java options to start the JVM of the TaskManager with.&quot;)</span>
<span class="fc" id="L216">                                    .build());</span>

<span class="fc" id="L218">    public static final ConfigOption&lt;String&gt; FLINK_HS_JVM_OPTIONS =</span>
<span class="fc" id="L219">            ConfigOptions.key(&quot;env.java.opts.historyserver&quot;)</span>
<span class="fc" id="L220">                    .stringType()</span>
<span class="fc" id="L221">                    .defaultValue(&quot;&quot;)</span>
<span class="fc" id="L222">                    .withDescription(</span>
<span class="fc" id="L223">                            Description.builder()</span>
<span class="fc" id="L224">                                    .text(</span>
                                            &quot;Java options to start the JVM of the HistoryServer with.&quot;)
<span class="fc" id="L226">                                    .build());</span>

<span class="fc" id="L228">    public static final ConfigOption&lt;String&gt; FLINK_CLI_JVM_OPTIONS =</span>
<span class="fc" id="L229">            ConfigOptions.key(&quot;env.java.opts.client&quot;)</span>
<span class="fc" id="L230">                    .stringType()</span>
<span class="fc" id="L231">                    .defaultValue(&quot;&quot;)</span>
<span class="fc" id="L232">                    .withDescription(</span>
<span class="fc" id="L233">                            Description.builder()</span>
<span class="fc" id="L234">                                    .text(&quot;Java options to start the JVM of the Flink Client with.&quot;)</span>
<span class="fc" id="L235">                                    .build());</span>

    /**
     * This options is here only for documentation generation, it is only evaluated in the shell
     * scripts.
     */
    @SuppressWarnings(&quot;unused&quot;)
<span class="fc" id="L242">    public static final ConfigOption&lt;String&gt; FLINK_LOG_DIR =</span>
<span class="fc" id="L243">            ConfigOptions.key(&quot;env.log.dir&quot;)</span>
<span class="fc" id="L244">                    .noDefaultValue()</span>
<span class="fc" id="L245">                    .withDescription(</span>
                            &quot;Defines the directory where the Flink logs are saved. It has to be an absolute path.&quot;
                                    + &quot; (Defaults to the log directory under Flink’s home)&quot;);

    /**
     * The config parameter defining the directory for Flink PID file. see: {@code
     * bin/config.sh#KEY_ENV_PID_DIR} and {@code bin/config.sh#DEFAULT_ENV_PID_DIR}
     */
<span class="fc" id="L253">    public static final ConfigOption&lt;String&gt; FLINK_PID_DIR =</span>
<span class="fc" id="L254">            ConfigOptions.key(&quot;env.pid.dir&quot;)</span>
<span class="fc" id="L255">                    .defaultValue(&quot;/tmp&quot;)</span>
<span class="fc" id="L256">                    .withDescription(</span>
                            &quot;Defines the directory where the flink-&lt;host&gt;-&lt;process&gt;.pid files are saved.&quot;);

    /**
     * This options is here only for documentation generation, it is only evaluated in the shell
     * scripts.
     */
    @SuppressWarnings(&quot;unused&quot;)
<span class="fc" id="L264">    public static final ConfigOption&lt;Integer&gt; FLINK_LOG_MAX =</span>
<span class="fc" id="L265">            ConfigOptions.key(&quot;env.log.max&quot;)</span>
<span class="fc" id="L266">                    .defaultValue(5)</span>
<span class="fc" id="L267">                    .withDescription(&quot;The maximum number of old log files to keep.&quot;);</span>

    /**
     * This options is here only for documentation generation, it is only evaluated in the shell
     * scripts.
     */
    @SuppressWarnings(&quot;unused&quot;)
<span class="fc" id="L274">    public static final ConfigOption&lt;String&gt; FLINK_SSH_OPTIONS =</span>
<span class="fc" id="L275">            ConfigOptions.key(&quot;env.ssh.opts&quot;)</span>
<span class="fc" id="L276">                    .noDefaultValue()</span>
<span class="fc" id="L277">                    .withDescription(</span>
                            &quot;Additional command line options passed to SSH clients when starting or stopping JobManager,&quot;
                                    + &quot; TaskManager, and Zookeeper services (start-cluster.sh, stop-cluster.sh, start-zookeeper-quorum.sh,&quot;
                                    + &quot; stop-zookeeper-quorum.sh).&quot;);

    /**
     * This options is here only for documentation generation, it is only evaluated in the shell
     * scripts.
     */
    @SuppressWarnings(&quot;unused&quot;)
<span class="fc" id="L287">    public static final ConfigOption&lt;String&gt; FLINK_HADOOP_CONF_DIR =</span>
<span class="fc" id="L288">            ConfigOptions.key(&quot;env.hadoop.conf.dir&quot;)</span>
<span class="fc" id="L289">                    .noDefaultValue()</span>
<span class="fc" id="L290">                    .withDescription(</span>
                            &quot;Path to hadoop configuration directory. It is required to read HDFS and/or YARN&quot;
                                    + &quot; configuration. You can also set it via environment variable.&quot;);

    /**
     * This options is here only for documentation generation, it is only evaluated in the shell
     * scripts.
     */
    @SuppressWarnings(&quot;unused&quot;)
<span class="fc" id="L299">    public static final ConfigOption&lt;String&gt; FLINK_YARN_CONF_DIR =</span>
<span class="fc" id="L300">            ConfigOptions.key(&quot;env.yarn.conf.dir&quot;)</span>
<span class="fc" id="L301">                    .noDefaultValue()</span>
<span class="fc" id="L302">                    .withDescription(</span>
                            &quot;Path to yarn configuration directory. It is required to run flink on YARN. You can also&quot;
                                    + &quot; set it via environment variable.&quot;);

    /**
     * This options is here only for documentation generation, it is only evaluated in the shell
     * scripts.
     */
    @SuppressWarnings(&quot;unused&quot;)
<span class="fc" id="L311">    public static final ConfigOption&lt;String&gt; FLINK_HBASE_CONF_DIR =</span>
<span class="fc" id="L312">            ConfigOptions.key(&quot;env.hbase.conf.dir&quot;)</span>
<span class="fc" id="L313">                    .noDefaultValue()</span>
<span class="fc" id="L314">                    .withDescription(</span>
                            &quot;Path to hbase configuration directory. It is required to read HBASE configuration.&quot;
                                    + &quot; You can also set it via environment variable.&quot;);

    // ------------------------------------------------------------------------
    //  generic io
    // ------------------------------------------------------------------------

    /**
     * The config parameter defining the directories for temporary files, separated by &quot;,&quot;, &quot;|&quot;, or
     * the system's {@link java.io.File#pathSeparator}.
     */
    @Documentation.OverrideDefault(
            &quot;'LOCAL_DIRS' on Yarn. '_FLINK_TMP_DIR' on Mesos. System.getProperty(\&quot;java.io.tmpdir\&quot;) in standalone.&quot;)
    @Documentation.Section(Documentation.Sections.COMMON_MISCELLANEOUS)
<span class="fc" id="L329">    public static final ConfigOption&lt;String&gt; TMP_DIRS =</span>
<span class="fc" id="L330">            key(&quot;io.tmp.dirs&quot;)</span>
<span class="fc" id="L331">                    .defaultValue(System.getProperty(&quot;java.io.tmpdir&quot;))</span>
<span class="fc" id="L332">                    .withDeprecatedKeys(&quot;taskmanager.tmp.dirs&quot;)</span>
<span class="fc" id="L333">                    .withDescription(</span>
                            &quot;Directories for temporary files, separated by\&quot;,\&quot;, \&quot;|\&quot;, or the system's java.io.File.pathSeparator.&quot;);

    // ------------------------------------------------------------------------
    //  program
    // ------------------------------------------------------------------------

<span class="fc" id="L340">    public static final ConfigOption&lt;Integer&gt; DEFAULT_PARALLELISM =</span>
<span class="fc" id="L341">            ConfigOptions.key(&quot;parallelism.default&quot;)</span>
<span class="fc" id="L342">                    .defaultValue(1)</span>
<span class="fc" id="L343">                    .withDescription(&quot;Default parallelism for jobs.&quot;);</span>

    // ------------------------------------------------------------------------
    //  file systems
    // ------------------------------------------------------------------------

    /** The default filesystem scheme, used for paths that do not declare a scheme explicitly. */
    @Documentation.Section(Documentation.Sections.COMMON_MISCELLANEOUS)
<span class="fc" id="L351">    public static final ConfigOption&lt;String&gt; DEFAULT_FILESYSTEM_SCHEME =</span>
<span class="fc" id="L352">            ConfigOptions.key(&quot;fs.default-scheme&quot;)</span>
<span class="fc" id="L353">                    .noDefaultValue()</span>
<span class="fc" id="L354">                    .withDescription(</span>
                            &quot;The default filesystem scheme, used for paths that do not declare a scheme explicitly.&quot;
                                    + &quot; May contain an authority, e.g. host:port in case of an HDFS NameNode.&quot;);

    @Documentation.Section(Documentation.Sections.COMMON_MISCELLANEOUS)
<span class="fc" id="L359">    public static final ConfigOption&lt;String&gt; ALLOWED_FALLBACK_FILESYSTEMS =</span>
<span class="fc" id="L360">            ConfigOptions.key(&quot;fs.allowed-fallback-filesystems&quot;)</span>
<span class="fc" id="L361">                    .stringType()</span>
<span class="fc" id="L362">                    .defaultValue(&quot;&quot;)</span>
<span class="fc" id="L363">                    .withDescription(</span>
                            &quot;A (semicolon-separated) list of file schemes, for which Hadoop can be used instead &quot;
                                    + &quot;of an appropriate Flink plugin. (example: s3;wasb)&quot;);

    /** Specifies whether file output writers should overwrite existing files by default. */
    @Documentation.Section(Documentation.Sections.DEPRECATED_FILE_SINKS)
<span class="fc" id="L369">    public static final ConfigOption&lt;Boolean&gt; FILESYTEM_DEFAULT_OVERRIDE =</span>
<span class="fc" id="L370">            key(&quot;fs.overwrite-files&quot;)</span>
<span class="fc" id="L371">                    .defaultValue(false)</span>
<span class="fc" id="L372">                    .withDescription(</span>
                            &quot;Specifies whether file output writers should overwrite existing files by default. Set to&quot;
                                    + &quot; \&quot;true\&quot; to overwrite by default,\&quot;false\&quot; otherwise.&quot;);

    /**
     * Specifies whether the file systems should always create a directory for the output, even with
     * a parallelism of one.
     */
    @Documentation.Section(Documentation.Sections.DEPRECATED_FILE_SINKS)
<span class="fc" id="L381">    public static final ConfigOption&lt;Boolean&gt; FILESYSTEM_OUTPUT_ALWAYS_CREATE_DIRECTORY =</span>
<span class="fc" id="L382">            key(&quot;fs.output.always-create-directory&quot;)</span>
<span class="fc" id="L383">                    .defaultValue(false)</span>
<span class="fc" id="L384">                    .withDescription(</span>
                            &quot;File writers running with a parallelism larger than one create a directory for the output&quot;
                                    + &quot; file path and put the different result files (one per parallel writer task) into that directory.&quot;
                                    + &quot; If this option is set to \&quot;true\&quot;, writers with a parallelism of 1 will also create a&quot;
                                    + &quot; directory and place a single result file into it. If the option is set to \&quot;false\&quot;,&quot;
                                    + &quot; the writer will directly create the file directly at the output path, without creating a containing&quot;
                                    + &quot; directory.&quot;);

    /**
     * The total number of input plus output connections that a file system for the given scheme may
     * open. Unlimited be default.
     */
    public static ConfigOption&lt;Integer&gt; fileSystemConnectionLimit(String scheme) {
<span class="fc" id="L397">        return ConfigOptions.key(&quot;fs.&quot; + scheme + &quot;.limit.total&quot;).defaultValue(-1);</span>
    }

    /**
     * The total number of input connections that a file system for the given scheme may open.
     * Unlimited be default.
     */
    public static ConfigOption&lt;Integer&gt; fileSystemConnectionLimitIn(String scheme) {
<span class="fc" id="L405">        return ConfigOptions.key(&quot;fs.&quot; + scheme + &quot;.limit.input&quot;).defaultValue(-1);</span>
    }

    /**
     * The total number of output connections that a file system for the given scheme may open.
     * Unlimited be default.
     */
    public static ConfigOption&lt;Integer&gt; fileSystemConnectionLimitOut(String scheme) {
<span class="fc" id="L413">        return ConfigOptions.key(&quot;fs.&quot; + scheme + &quot;.limit.output&quot;).defaultValue(-1);</span>
    }

    /**
     * If any connection limit is configured, this option can be optionally set to define after
     * which time (in milliseconds) stream opening fails with a timeout exception, if no stream
     * connection becomes available. Unlimited timeout be default.
     */
    public static ConfigOption&lt;Long&gt; fileSystemConnectionLimitTimeout(String scheme) {
<span class="fc" id="L422">        return ConfigOptions.key(&quot;fs.&quot; + scheme + &quot;.limit.timeout&quot;).defaultValue(0L);</span>
    }

    /**
     * If any connection limit is configured, this option can be optionally set to define after
     * which time (in milliseconds) inactive streams are reclaimed. This option can help to prevent
     * that inactive streams make up the full pool of limited connections, and no further
     * connections can be established. Unlimited timeout be default.
     */
    public static ConfigOption&lt;Long&gt; fileSystemConnectionLimitStreamInactivityTimeout(
            String scheme) {
<span class="fc" id="L433">        return ConfigOptions.key(&quot;fs.&quot; + scheme + &quot;.limit.stream-timeout&quot;).defaultValue(0L);</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.7.202105040129</span></div></body></html>