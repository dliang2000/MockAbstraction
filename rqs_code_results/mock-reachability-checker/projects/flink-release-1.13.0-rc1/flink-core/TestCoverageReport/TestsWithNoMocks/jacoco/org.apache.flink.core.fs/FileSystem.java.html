<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>FileSystem.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Flink : Core</a> &gt; <a href="index.source.html" class="el_package">org.apache.flink.core.fs</a> &gt; <span class="el_source">FileSystem.java</span></div><h1>FileSystem.java</h1><pre class="source lang-java linenums">/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * &quot;License&quot;); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*
 * This file is based on source code from the Hadoop Project (http://hadoop.apache.org/), licensed by the Apache
 * Software Foundation (ASF) under the Apache License, Version 2.0. See the NOTICE file distributed with this work for
 * additional information regarding copyright ownership.
 */

package org.apache.flink.core.fs;

import org.apache.flink.annotation.Internal;
import org.apache.flink.annotation.Public;
import org.apache.flink.configuration.Configuration;
import org.apache.flink.configuration.CoreOptions;
import org.apache.flink.configuration.IllegalConfigurationException;
import org.apache.flink.core.fs.local.LocalFileSystem;
import org.apache.flink.core.fs.local.LocalFileSystemFactory;
import org.apache.flink.core.plugin.PluginManager;
import org.apache.flink.util.ExceptionUtils;
import org.apache.flink.util.TemporaryClassLoaderContext;

import org.apache.flink.shaded.guava18.com.google.common.base.Splitter;
import org.apache.flink.shaded.guava18.com.google.common.collect.ImmutableMultimap;
import org.apache.flink.shaded.guava18.com.google.common.collect.Iterators;
import org.apache.flink.shaded.guava18.com.google.common.collect.Multimap;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import javax.annotation.Nullable;

import java.io.File;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.net.URI;
import java.net.URISyntaxException;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.ServiceLoader;
import java.util.Set;
import java.util.concurrent.locks.ReentrantLock;
import java.util.function.Supplier;

import static org.apache.flink.util.Preconditions.checkNotNull;

/**
 * Abstract base class of all file systems used by Flink. This class may be extended to implement
 * distributed file systems, or local file systems. The abstraction by this file system is very
 * simple, and the set of available operations quite limited, to support the common denominator of a
 * wide range of file systems. For example, appending to or mutating existing files is not
 * supported.
 *
 * &lt;p&gt;Flink implements and supports some file system types directly (for example the default
 * machine-local file system). Other file system types are accessed by an implementation that
 * bridges to the suite of file systems supported by Hadoop (such as for example HDFS).
 *
 * &lt;h2&gt;Scope and Purpose&lt;/h2&gt;
 *
 * &lt;p&gt;The purpose of this abstraction is used to expose a common and well defined interface for
 * access to files. This abstraction is used both by Flink's fault tolerance mechanism (storing
 * state and recovery data) and by reusable built-in connectors (file sources / sinks).
 *
 * &lt;p&gt;The purpose of this abstraction is &lt;b&gt;not&lt;/b&gt; to give user programs an abstraction with
 * extreme flexibility and control across all possible file systems. That mission would be a folly,
 * as the differences in characteristics of even the most common file systems are already quite
 * large. It is expected that user programs that need specialized functionality of certain file
 * systems in their functions, operations, sources, or sinks instantiate the specialized file system
 * adapters directly.
 *
 * &lt;h2&gt;Data Persistence Contract&lt;/h2&gt;
 *
 * &lt;p&gt;The FileSystem's {@link FSDataOutputStream output streams} are used to persistently store
 * data, both for results of streaming applications and for fault tolerance and recovery. It is
 * therefore crucial that the persistence semantics of these streams are well defined.
 *
 * &lt;h3&gt;Definition of Persistence Guarantees&lt;/h3&gt;
 *
 * &lt;p&gt;Data written to an output stream is considered persistent, if two requirements are met:
 *
 * &lt;ol&gt;
 *   &lt;li&gt;&lt;b&gt;Visibility Requirement:&lt;/b&gt; It must be guaranteed that all other processes, machines,
 *       virtual machines, containers, etc. that are able to access the file see the data
 *       consistently when given the absolute file path. This requirement is similar to the
 *       &lt;i&gt;close-to-open&lt;/i&gt; semantics defined by POSIX, but restricted to the file itself (by its
 *       absolute path).
 *   &lt;li&gt;&lt;b&gt;Durability Requirement:&lt;/b&gt; The file system's specific durability/persistence
 *       requirements must be met. These are specific to the particular file system. For example the
 *       {@link LocalFileSystem} does not provide any durability guarantees for crashes of both
 *       hardware and operating system, while replicated distributed file systems (like HDFS)
 *       typically guarantee durability in the presence of at most &lt;i&gt;n&lt;/i&gt; concurrent node
 *       failures, where &lt;i&gt;n&lt;/i&gt; is the replication factor.
 * &lt;/ol&gt;
 *
 * &lt;p&gt;Updates to the file's parent directory (such that the file shows up when listing the directory
 * contents) are not required to be complete for the data in the file stream to be considered
 * persistent. This relaxation is important for file systems where updates to directory contents are
 * only eventually consistent.
 *
 * &lt;p&gt;The {@link FSDataOutputStream} has to guarantee data persistence for the written bytes once
 * the call to {@link FSDataOutputStream#close()} returns.
 *
 * &lt;h3&gt;Examples&lt;/h3&gt;
 *
 * &lt;h4&gt;Fault-tolerant distributed file systems&lt;/h4&gt;
 *
 * &lt;p&gt;For &lt;b&gt;fault-tolerant distributed file systems&lt;/b&gt;, data is considered persistent once it has
 * been received and acknowledged by the file system, typically by having been replicated to a
 * quorum of machines (&lt;i&gt;durability requirement&lt;/i&gt;). In addition the absolute file path must be
 * visible to all other machines that will potentially access the file (&lt;i&gt;visibility
 * requirement&lt;/i&gt;).
 *
 * &lt;p&gt;Whether data has hit non-volatile storage on the storage nodes depends on the specific
 * guarantees of the particular file system.
 *
 * &lt;p&gt;The metadata updates to the file's parent directory are not required to have reached a
 * consistent state. It is permissible that some machines see the file when listing the parent
 * directory's contents while others do not, as long as access to the file by its absolute path is
 * possible on all nodes.
 *
 * &lt;h4&gt;Local file systems&lt;/h4&gt;
 *
 * &lt;p&gt;A &lt;b&gt;local file system&lt;/b&gt; must support the POSIX &lt;i&gt;close-to-open&lt;/i&gt; semantics. Because the
 * local file system does not have any fault tolerance guarantees, no further requirements exist.
 *
 * &lt;p&gt;The above implies specifically that data may still be in the OS cache when considered
 * persistent from the local file system's perspective. Crashes that cause the OS cache to loose
 * data are considered fatal to the local machine and are not covered by the local file system's
 * guarantees as defined by Flink.
 *
 * &lt;p&gt;That means that computed results, checkpoints, and savepoints that are written only to the
 * local filesystem are not guaranteed to be recoverable from the local machine's failure, making
 * local file systems unsuitable for production setups.
 *
 * &lt;h2&gt;Updating File Contents&lt;/h2&gt;
 *
 * &lt;p&gt;Many file systems either do not support overwriting contents of existing files at all, or do
 * not support consistent visibility of the updated contents in that case. For that reason, Flink's
 * FileSystem does not support appending to existing files, or seeking within output streams so that
 * previously written data could be overwritten.
 *
 * &lt;h2&gt;Overwriting Files&lt;/h2&gt;
 *
 * &lt;p&gt;Overwriting files is in general possible. A file is overwritten by deleting it and creating a
 * new file. However, certain filesystems cannot make that change synchronously visible to all
 * parties that have access to the file. For example &lt;a
 * href=&quot;https://aws.amazon.com/documentation/s3/&quot;&gt;Amazon S3&lt;/a&gt; guarantees only &lt;i&gt;eventual
 * consistency&lt;/i&gt; in the visibility of the file replacement: Some machines may see the old file,
 * some machines may see the new file.
 *
 * &lt;p&gt;To avoid these consistency issues, the implementations of failure/recovery mechanisms in Flink
 * strictly avoid writing to the same file path more than once.
 *
 * &lt;h2&gt;Thread Safety&lt;/h2&gt;
 *
 * &lt;p&gt;Implementations of {@code FileSystem} must be thread-safe: The same instance of FileSystem is
 * frequently shared across multiple threads in Flink and must be able to concurrently create
 * input/output streams and list file metadata.
 *
 * &lt;p&gt;The {@link FSDataInputStream} and {@link FSDataOutputStream} implementations are strictly
 * &lt;b&gt;not thread-safe&lt;/b&gt;. Instances of the streams should also not be passed between threads in
 * between read or write operations, because there are no guarantees about the visibility of
 * operations across threads (many operations do not create memory fences).
 *
 * &lt;h2&gt;Streams Safety Net&lt;/h2&gt;
 *
 * &lt;p&gt;When application code obtains a FileSystem (via {@link FileSystem#get(URI)} or via {@link
 * Path#getFileSystem()}), the FileSystem instantiates a safety net for that FileSystem. The safety
 * net ensures that all streams created from the FileSystem are closed when the application task
 * finishes (or is canceled or failed). That way, the task's threads do not leak connections.
 *
 * &lt;p&gt;Internal runtime code can explicitly obtain a FileSystem that does not use the safety net via
 * {@link FileSystem#getUnguardedFileSystem(URI)}.
 *
 * @see FSDataInputStream
 * @see FSDataOutputStream
 */
@Public
<span class="fc" id="L199">public abstract class FileSystem {</span>

    /**
     * The possible write modes. The write mode decides what happens if a file should be created,
     * but already exists.
     */
<span class="fc" id="L205">    public enum WriteMode {</span>

        /**
         * Creates the target file only if no file exists at that path already. Does not overwrite
         * existing files and directories.
         */
<span class="fc" id="L211">        NO_OVERWRITE,</span>

        /**
         * Creates a new target file regardless of any existing files or directories. Existing files
         * and directories will be deleted (recursively) automatically before creating the new file.
         */
<span class="fc" id="L217">        OVERWRITE</span>
    }

    // ------------------------------------------------------------------------

    /** Logger for all FileSystem work. */
<span class="fc" id="L223">    private static final Logger LOG = LoggerFactory.getLogger(FileSystem.class);</span>

    /**
     * This lock guards the methods {@link #initOutPathLocalFS(Path, WriteMode, boolean)} and {@link
     * #initOutPathDistFS(Path, WriteMode, boolean)} which are otherwise susceptible to races.
     */
<span class="fc" id="L229">    private static final ReentrantLock OUTPUT_DIRECTORY_INIT_LOCK = new ReentrantLock(true);</span>

    /** Object used to protect calls to specific methods. */
<span class="fc" id="L232">    private static final ReentrantLock LOCK = new ReentrantLock(true);</span>

    /** Cache for file systems, by scheme + authority. */
<span class="fc" id="L235">    private static final HashMap&lt;FSKey, FileSystem&gt; CACHE = new HashMap&lt;&gt;();</span>

    /**
     * Mapping of file system schemes to the corresponding factories, populated in {@link
     * FileSystem#initialize(Configuration, PluginManager)}.
     */
<span class="fc" id="L241">    private static final HashMap&lt;String, FileSystemFactory&gt; FS_FACTORIES = new HashMap&lt;&gt;();</span>

    /** The default factory that is used when no scheme matches. */
<span class="fc" id="L244">    private static final FileSystemFactory FALLBACK_FACTORY = loadHadoopFsFactory();</span>

    /** All known plugins for a given scheme, do not fallback for those. */
    private static final Multimap&lt;String, String&gt; DIRECTLY_SUPPORTED_FILESYSTEM =
<span class="fc" id="L248">            ImmutableMultimap.&lt;String, String&gt;builder()</span>
<span class="fc" id="L249">                    .put(&quot;wasb&quot;, &quot;flink-fs-azure-hadoop&quot;)</span>
<span class="fc" id="L250">                    .put(&quot;wasbs&quot;, &quot;flink-fs-azure-hadoop&quot;)</span>
<span class="fc" id="L251">                    .put(&quot;oss&quot;, &quot;flink-oss-fs-hadoop&quot;)</span>
<span class="fc" id="L252">                    .put(&quot;s3&quot;, &quot;flink-s3-fs-hadoop&quot;)</span>
<span class="fc" id="L253">                    .put(&quot;s3&quot;, &quot;flink-s3-fs-presto&quot;)</span>
<span class="fc" id="L254">                    .put(&quot;s3a&quot;, &quot;flink-s3-fs-hadoop&quot;)</span>
<span class="fc" id="L255">                    .put(&quot;s3p&quot;, &quot;flink-s3-fs-presto&quot;)</span>
                    // mapr deliberately omitted for now (no dedicated plugin)
<span class="fc" id="L257">                    .build();</span>

    /** Exceptions for DIRECTLY_SUPPORTED_FILESYSTEM. */
<span class="fc" id="L260">    private static final Set&lt;String&gt; ALLOWED_FALLBACK_FILESYSTEMS = new HashSet&lt;&gt;();</span>

    /**
     * The default filesystem scheme to be used, configured during process-wide initialization. This
     * value defaults to the local file systems scheme {@code 'file:///'} or {@code 'file:/'}.
     */
    private static URI defaultScheme;

    // ------------------------------------------------------------------------
    //  Initialization
    // ------------------------------------------------------------------------

    /**
     * Initializes the shared file system settings.
     *
     * &lt;p&gt;The given configuration is passed to each file system factory to initialize the respective
     * file systems. Because the configuration of file systems may be different subsequent to the
     * call of this method, this method clears the file system instance cache.
     *
     * &lt;p&gt;This method also reads the default file system URI from the configuration key {@link
     * CoreOptions#DEFAULT_FILESYSTEM_SCHEME}. All calls to {@link FileSystem#get(URI)} where the
     * URI has no scheme will be interpreted as relative to that URI. As an example, assume the
     * default file system URI is set to {@code 'hdfs://localhost:9000/'}. A file path of {@code
     * '/user/USERNAME/in.txt'} is interpreted as {@code
     * 'hdfs://localhost:9000/user/USERNAME/in.txt'}.
     *
     * @deprecated use {@link #initialize(Configuration, PluginManager)} instead.
     * @param config the configuration from where to fetch the parameter.
     */
    @Deprecated
    public static void initialize(Configuration config) throws IllegalConfigurationException {
<span class="fc" id="L291">        initializeWithoutPlugins(config);</span>
<span class="fc" id="L292">    }</span>

    private static void initializeWithoutPlugins(Configuration config)
            throws IllegalConfigurationException {
<span class="fc" id="L296">        initialize(config, null);</span>
<span class="fc" id="L297">    }</span>

    /**
     * Initializes the shared file system settings.
     *
     * &lt;p&gt;The given configuration is passed to each file system factory to initialize the respective
     * file systems. Because the configuration of file systems may be different subsequent to the
     * call of this method, this method clears the file system instance cache.
     *
     * &lt;p&gt;This method also reads the default file system URI from the configuration key {@link
     * CoreOptions#DEFAULT_FILESYSTEM_SCHEME}. All calls to {@link FileSystem#get(URI)} where the
     * URI has no scheme will be interpreted as relative to that URI. As an example, assume the
     * default file system URI is set to {@code 'hdfs://localhost:9000/'}. A file path of {@code
     * '/user/USERNAME/in.txt'} is interpreted as {@code
     * 'hdfs://localhost:9000/user/USERNAME/in.txt'}.
     *
     * @param config the configuration from where to fetch the parameter.
     * @param pluginManager optional plugin manager that is used to initialized filesystems provided
     *     as plugins.
     */
    public static void initialize(Configuration config, PluginManager pluginManager)
            throws IllegalConfigurationException {

<span class="fc" id="L320">        LOCK.lock();</span>
        try {
            // make sure file systems are re-instantiated after re-configuration
<span class="fc" id="L323">            CACHE.clear();</span>
<span class="fc" id="L324">            FS_FACTORIES.clear();</span>

<span class="fc" id="L326">            Collection&lt;Supplier&lt;Iterator&lt;FileSystemFactory&gt;&gt;&gt; factorySuppliers = new ArrayList&lt;&gt;(2);</span>
<span class="fc" id="L327">            factorySuppliers.add(() -&gt; ServiceLoader.load(FileSystemFactory.class).iterator());</span>

<span class="pc bpc" id="L329" title="1 of 2 branches missed.">            if (pluginManager != null) {</span>
<span class="nc" id="L330">                factorySuppliers.add(</span>
                        () -&gt;
<span class="nc" id="L332">                                Iterators.transform(</span>
<span class="nc" id="L333">                                        pluginManager.load(FileSystemFactory.class),</span>
                                        PluginFileSystemFactory::of));
            }

<span class="fc" id="L337">            final List&lt;FileSystemFactory&gt; fileSystemFactories =</span>
<span class="fc" id="L338">                    loadFileSystemFactories(factorySuppliers);</span>

            // configure all file system factories
<span class="fc bfc" id="L341" title="All 2 branches covered.">            for (FileSystemFactory factory : fileSystemFactories) {</span>
<span class="fc" id="L342">                factory.configure(config);</span>
<span class="fc" id="L343">                String scheme = factory.getScheme();</span>

<span class="fc" id="L345">                FileSystemFactory fsf =</span>
<span class="fc" id="L346">                        ConnectionLimitingFactory.decorateIfLimited(factory, scheme, config);</span>
<span class="fc" id="L347">                FS_FACTORIES.put(scheme, fsf);</span>
<span class="fc" id="L348">            }</span>

            // configure the default (fallback) factory
<span class="fc" id="L351">            FALLBACK_FACTORY.configure(config);</span>

            // also read the default file system scheme
<span class="fc" id="L354">            final String stringifiedUri =</span>
<span class="fc" id="L355">                    config.getString(CoreOptions.DEFAULT_FILESYSTEM_SCHEME, null);</span>
<span class="fc bfc" id="L356" title="All 2 branches covered.">            if (stringifiedUri == null) {</span>
<span class="fc" id="L357">                defaultScheme = null;</span>
            } else {
                try {
<span class="fc" id="L360">                    defaultScheme = new URI(stringifiedUri);</span>
<span class="nc" id="L361">                } catch (URISyntaxException e) {</span>
<span class="nc" id="L362">                    throw new IllegalConfigurationException(</span>
                            &quot;The default file system scheme ('&quot;
                                    + CoreOptions.DEFAULT_FILESYSTEM_SCHEME
                                    + &quot;') is invalid: &quot;
                                    + stringifiedUri,
                            e);
<span class="fc" id="L368">                }</span>
            }

<span class="fc" id="L371">            ALLOWED_FALLBACK_FILESYSTEMS.clear();</span>
<span class="fc" id="L372">            final Iterable&lt;String&gt; allowedFallbackFilesystems =</span>
<span class="fc" id="L373">                    Splitter.on(';')</span>
<span class="fc" id="L374">                            .omitEmptyStrings()</span>
<span class="fc" id="L375">                            .trimResults()</span>
<span class="fc" id="L376">                            .split(config.getString(CoreOptions.ALLOWED_FALLBACK_FILESYSTEMS));</span>
<span class="fc" id="L377">            allowedFallbackFilesystems.forEach(ALLOWED_FALLBACK_FILESYSTEMS::add);</span>
        } finally {
<span class="fc" id="L379">            LOCK.unlock();</span>
        }
<span class="fc" id="L381">    }</span>

    // ------------------------------------------------------------------------
    //  Obtaining File System Instances
    // ------------------------------------------------------------------------

    /**
     * Returns a reference to the {@link FileSystem} instance for accessing the local file system.
     *
     * @return a reference to the {@link FileSystem} instance for accessing the local file system.
     */
    public static FileSystem getLocalFileSystem() {
<span class="fc" id="L393">        return FileSystemSafetyNet.wrapWithSafetyNetWhenActivated(</span>
<span class="fc" id="L394">                LocalFileSystem.getSharedInstance());</span>
    }

    /**
     * Returns a reference to the {@link FileSystem} instance for accessing the file system
     * identified by the given {@link URI}.
     *
     * @param uri the {@link URI} identifying the file system
     * @return a reference to the {@link FileSystem} instance for accessing the file system
     *     identified by the given {@link URI}.
     * @throws IOException thrown if a reference to the file system instance could not be obtained
     */
    public static FileSystem get(URI uri) throws IOException {
<span class="fc" id="L407">        return FileSystemSafetyNet.wrapWithSafetyNetWhenActivated(getUnguardedFileSystem(uri));</span>
    }

    @Internal
    public static FileSystem getUnguardedFileSystem(final URI fsUri) throws IOException {
<span class="fc" id="L412">        checkNotNull(fsUri, &quot;file system URI&quot;);</span>

<span class="fc" id="L414">        LOCK.lock();</span>
        try {
            final URI uri;

<span class="fc bfc" id="L418" title="All 2 branches covered.">            if (fsUri.getScheme() != null) {</span>
<span class="fc" id="L419">                uri = fsUri;</span>
            } else {
                // Apply the default fs scheme
<span class="fc" id="L422">                final URI defaultUri = getDefaultFsUri();</span>
<span class="fc" id="L423">                URI rewrittenUri = null;</span>

                try {
<span class="fc" id="L426">                    rewrittenUri =</span>
                            new URI(
<span class="fc" id="L428">                                    defaultUri.getScheme(),</span>
                                    null,
<span class="fc" id="L430">                                    defaultUri.getHost(),</span>
<span class="fc" id="L431">                                    defaultUri.getPort(),</span>
<span class="fc" id="L432">                                    fsUri.getPath(),</span>
                                    null,
                                    null);
<span class="fc" id="L435">                } catch (URISyntaxException e) {</span>
                    // for local URIs, we make one more try to repair the path by making it absolute
<span class="pc bpc" id="L437" title="1 of 2 branches missed.">                    if (defaultUri.getScheme().equals(&quot;file&quot;)) {</span>
                        try {
<span class="fc" id="L439">                            rewrittenUri =</span>
                                    new URI(
                                            &quot;file&quot;,
                                            null,
<span class="fc" id="L443">                                            new Path(new File(fsUri.getPath()).getAbsolutePath())</span>
<span class="fc" id="L444">                                                    .toUri()</span>
<span class="fc" id="L445">                                                    .getPath(),</span>
                                            null);
<span class="nc" id="L447">                        } catch (URISyntaxException ignored) {</span>
                            // could not help it...
<span class="fc" id="L449">                        }</span>
                    }
<span class="fc" id="L451">                }</span>

<span class="pc bpc" id="L453" title="1 of 2 branches missed.">                if (rewrittenUri != null) {</span>
<span class="fc" id="L454">                    uri = rewrittenUri;</span>
                } else {
<span class="nc" id="L456">                    throw new IOException(</span>
                            &quot;The file system URI '&quot;
                                    + fsUri
                                    + &quot;' declares no scheme and cannot be interpreted relative to the default file system URI (&quot;
                                    + defaultUri
                                    + &quot;).&quot;);
                }
            }

            // print a helpful pointer for malformed local URIs (happens a lot to new users)
<span class="fc bfc" id="L466" title="All 2 branches covered.">            if (uri.getScheme().equals(&quot;file&quot;)</span>
<span class="fc bfc" id="L467" title="All 2 branches covered.">                    &amp;&amp; uri.getAuthority() != null</span>
<span class="pc bpc" id="L468" title="1 of 2 branches missed.">                    &amp;&amp; !uri.getAuthority().isEmpty()) {</span>
<span class="fc" id="L469">                String supposedUri = &quot;file:///&quot; + uri.getAuthority() + uri.getPath();</span>

<span class="fc" id="L471">                throw new IOException(</span>
                        &quot;Found local file path with authority '&quot;
<span class="fc" id="L473">                                + uri.getAuthority()</span>
                                + &quot;' in path '&quot;
<span class="fc" id="L475">                                + uri.toString()</span>
                                + &quot;'. Hint: Did you forget a slash? (correct path would be '&quot;
                                + supposedUri
                                + &quot;')&quot;);
            }

<span class="fc" id="L481">            final FSKey key = new FSKey(uri.getScheme(), uri.getAuthority());</span>

            // See if there is a file system object in the cache
            {
<span class="fc" id="L485">                FileSystem cached = CACHE.get(key);</span>
<span class="fc bfc" id="L486" title="All 2 branches covered.">                if (cached != null) {</span>
<span class="fc" id="L487">                    return cached;</span>
                }
            }

            // this &quot;default&quot; initialization makes sure that the FileSystem class works
            // even when not configured with an explicit Flink configuration, like on
            // JobManager or TaskManager setup
<span class="fc bfc" id="L494" title="All 2 branches covered.">            if (FS_FACTORIES.isEmpty()) {</span>
<span class="fc" id="L495">                initializeWithoutPlugins(new Configuration());</span>
            }

            // Try to create a new file system
            final FileSystem fs;
<span class="fc" id="L500">            final FileSystemFactory factory = FS_FACTORIES.get(uri.getScheme());</span>

<span class="fc bfc" id="L502" title="All 2 branches covered.">            if (factory != null) {</span>
<span class="fc" id="L503">                ClassLoader classLoader = factory.getClassLoader();</span>
<span class="fc" id="L504">                try (TemporaryClassLoaderContext ignored =</span>
<span class="fc" id="L505">                        TemporaryClassLoaderContext.of(classLoader)) {</span>
<span class="fc" id="L506">                    fs = factory.create(uri);</span>
                }
<span class="fc bfc" id="L508" title="All 2 branches covered.">            } else if (!ALLOWED_FALLBACK_FILESYSTEMS.contains(uri.getScheme())</span>
<span class="fc bfc" id="L509" title="All 2 branches covered.">                    &amp;&amp; DIRECTLY_SUPPORTED_FILESYSTEM.containsKey(uri.getScheme())) {</span>
<span class="fc" id="L510">                final Collection&lt;String&gt; plugins =</span>
<span class="fc" id="L511">                        DIRECTLY_SUPPORTED_FILESYSTEM.get(uri.getScheme());</span>
<span class="fc" id="L512">                throw new UnsupportedFileSystemSchemeException(</span>
<span class="fc" id="L513">                        String.format(</span>
                                &quot;Could not find a file system implementation for scheme '%s'. The scheme is &quot;
                                        + &quot;directly supported by Flink through the following plugin%s: %s. Please ensure that each &quot;
                                        + &quot;plugin resides within its own subfolder within the plugins directory. See https://ci.apache&quot;
                                        + &quot;.org/projects/flink/flink-docs-stable/ops/plugins.html for more information. If you want to &quot;
                                        + &quot;use a Hadoop file system for that scheme, please add the scheme to the configuration fs&quot;
                                        + &quot;.allowed-fallback-filesystems. For a full list of supported file systems, &quot;
                                        + &quot;please see https://ci.apache.org/projects/flink/flink-docs-stable/ops/filesystems/.&quot;,
<span class="fc" id="L521">                                uri.getScheme(),</span>
<span class="pc bpc" id="L522" title="1 of 2 branches missed.">                                plugins.size() == 1 ? &quot;&quot; : &quot;s&quot;,</span>
<span class="fc" id="L523">                                String.join(&quot;, &quot;, plugins)));</span>
            } else {
                try {
<span class="nc" id="L526">                    fs = FALLBACK_FACTORY.create(uri);</span>
<span class="fc" id="L527">                } catch (UnsupportedFileSystemSchemeException e) {</span>
<span class="fc" id="L528">                    throw new UnsupportedFileSystemSchemeException(</span>
                            &quot;Could not find a file system implementation for scheme '&quot;
<span class="fc" id="L530">                                    + uri.getScheme()</span>
                                    + &quot;'. The scheme is not directly supported by Flink and no Hadoop file system to &quot;
                                    + &quot;support this scheme could be loaded. For a full list of supported file systems, &quot;
                                    + &quot;please see https://ci.apache.org/projects/flink/flink-docs-stable/ops/filesystems/.&quot;,
                            e);
<span class="nc" id="L535">                }</span>
            }

<span class="fc" id="L538">            CACHE.put(key, fs);</span>
<span class="fc" id="L539">            return fs;</span>
        } finally {
<span class="fc" id="L541">            LOCK.unlock();</span>
        }
    }

    /**
     * Gets the default file system URI that is used for paths and file systems that do not specify
     * and explicit scheme.
     *
     * &lt;p&gt;As an example, assume the default file system URI is set to {@code
     * 'hdfs://someserver:9000/'}. A file path of {@code '/user/USERNAME/in.txt'} is interpreted as
     * {@code 'hdfs://someserver:9000/user/USERNAME/in.txt'}.
     *
     * @return The default file system URI
     */
    public static URI getDefaultFsUri() {
<span class="fc bfc" id="L556" title="All 2 branches covered.">        return defaultScheme != null ? defaultScheme : LocalFileSystem.getLocalFsURI();</span>
    }

    // ------------------------------------------------------------------------
    //  File System Methods
    // ------------------------------------------------------------------------

    /**
     * Returns the path of the file system's current working directory.
     *
     * @return the path of the file system's current working directory
     */
    public abstract Path getWorkingDirectory();

    /**
     * Returns the path of the user's home directory in this file system.
     *
     * @return the path of the user's home directory in this file system.
     */
    public abstract Path getHomeDirectory();

    /**
     * Returns a URI whose scheme and authority identify this file system.
     *
     * @return a URI whose scheme and authority identify this file system
     */
    public abstract URI getUri();

    /**
     * Return a file status object that represents the path.
     *
     * @param f The path we want information from
     * @return a FileStatus object
     * @throws FileNotFoundException when the path does not exist; IOException see specific
     *     implementation
     */
    public abstract FileStatus getFileStatus(Path f) throws IOException;

    /**
     * Return an array containing hostnames, offset and size of portions of the given file. For a
     * nonexistent file or regions, null will be returned. This call is most helpful with DFS, where
     * it returns hostnames of machines that contain the given file. The FileSystem will simply
     * return an elt containing 'localhost'.
     */
    public abstract BlockLocation[] getFileBlockLocations(FileStatus file, long start, long len)
            throws IOException;

    /**
     * Opens an FSDataInputStream at the indicated Path.
     *
     * @param f the file name to open
     * @param bufferSize the size of the buffer to be used.
     */
    public abstract FSDataInputStream open(Path f, int bufferSize) throws IOException;

    /**
     * Opens an FSDataInputStream at the indicated Path.
     *
     * @param f the file to open
     */
    public abstract FSDataInputStream open(Path f) throws IOException;

    /**
     * Creates a new {@link RecoverableWriter}. A recoverable writer creates streams that can
     * persist and recover their intermediate state. Persisting and recovering intermediate state is
     * a core building block for writing to files that span multiple checkpoints.
     *
     * &lt;p&gt;The returned object can act as a shared factory to open and recover multiple streams.
     *
     * &lt;p&gt;This method is optional on file systems and various file system implementations may not
     * support this method, throwing an {@code UnsupportedOperationException}.
     *
     * @return A RecoverableWriter for this file system.
     * @throws IOException Thrown, if the recoverable writer cannot be instantiated.
     */
    public RecoverableWriter createRecoverableWriter() throws IOException {
<span class="nc" id="L632">        throw new UnsupportedOperationException(</span>
                &quot;This file system does not support recoverable writers.&quot;);
    }

    /**
     * Return the number of bytes that large input files should be optimally be split into to
     * minimize I/O time.
     *
     * @return the number of bytes that large input files should be optimally be split into to
     *     minimize I/O time
     * @deprecated This value is no longer used and is meaningless.
     */
    @Deprecated
    public long getDefaultBlockSize() {
<span class="nc" id="L646">        return 32 * 1024 * 1024; // 32 MB;</span>
    }

    /**
     * List the statuses of the files/directories in the given path if the path is a directory.
     *
     * @param f given path
     * @return the statuses of the files/directories in the given path
     * @throws IOException
     */
    public abstract FileStatus[] listStatus(Path f) throws IOException;

    /**
     * Check if exists.
     *
     * @param f source file
     */
    public boolean exists(final Path f) throws IOException {
        try {
<span class="nc bnc" id="L665" title="All 2 branches missed.">            return (getFileStatus(f) != null);</span>
<span class="nc" id="L666">        } catch (FileNotFoundException e) {</span>
<span class="nc" id="L667">            return false;</span>
        }
    }

    /**
     * Delete a file.
     *
     * @param f the path to delete
     * @param recursive if path is a directory and set to &lt;code&gt;true&lt;/code&gt;, the directory is
     *     deleted else throws an exception. In case of a file the recursive can be set to either
     *     &lt;code&gt;true&lt;/code&gt; or &lt;code&gt;false&lt;/code&gt;
     * @return &lt;code&gt;true&lt;/code&gt; if delete is successful, &lt;code&gt;false&lt;/code&gt; otherwise
     * @throws IOException
     */
    public abstract boolean delete(Path f, boolean recursive) throws IOException;

    /**
     * Make the given file and all non-existent parents into directories. Has the semantics of Unix
     * 'mkdir -p'. Existence of the directory hierarchy is not an error.
     *
     * @param f the directory/directories to be created
     * @return &lt;code&gt;true&lt;/code&gt; if at least one new directory has been created, &lt;code&gt;false&lt;/code&gt;
     *     otherwise
     * @throws IOException thrown if an I/O error occurs while creating the directory
     */
    public abstract boolean mkdirs(Path f) throws IOException;

    /**
     * Opens an FSDataOutputStream at the indicated Path.
     *
     * &lt;p&gt;This method is deprecated, because most of its parameters are ignored by most file
     * systems. To control for example the replication factor and block size in the Hadoop
     * Distributed File system, make sure that the respective Hadoop configuration file is either
     * linked from the Flink configuration, or in the classpath of either Flink or the user code.
     *
     * @param f the file name to open
     * @param overwrite if a file with this name already exists, then if true, the file will be
     *     overwritten, and if false an error will be thrown.
     * @param bufferSize the size of the buffer to be used.
     * @param replication required block replication for the file.
     * @param blockSize the size of the file blocks
     * @throws IOException Thrown, if the stream could not be opened because of an I/O, or because a
     *     file already exists at that path and the write mode indicates to not overwrite the file.
     * @deprecated Deprecated because not well supported across types of file systems. Control the
     *     behavior of specific file systems via configurations instead.
     */
    @Deprecated
    public FSDataOutputStream create(
            Path f, boolean overwrite, int bufferSize, short replication, long blockSize)
            throws IOException {

<span class="nc bnc" id="L718" title="All 2 branches missed.">        return create(f, overwrite ? WriteMode.OVERWRITE : WriteMode.NO_OVERWRITE);</span>
    }

    /**
     * Opens an FSDataOutputStream at the indicated Path.
     *
     * @param f the file name to open
     * @param overwrite if a file with this name already exists, then if true, the file will be
     *     overwritten, and if false an error will be thrown.
     * @throws IOException Thrown, if the stream could not be opened because of an I/O, or because a
     *     file already exists at that path and the write mode indicates to not overwrite the file.
     * @deprecated Use {@link #create(Path, WriteMode)} instead.
     */
    @Deprecated
    public FSDataOutputStream create(Path f, boolean overwrite) throws IOException {
<span class="nc bnc" id="L733" title="All 2 branches missed.">        return create(f, overwrite ? WriteMode.OVERWRITE : WriteMode.NO_OVERWRITE);</span>
    }

    /**
     * Opens an FSDataOutputStream to a new file at the given path.
     *
     * &lt;p&gt;If the file already exists, the behavior depends on the given {@code WriteMode}. If the
     * mode is set to {@link WriteMode#NO_OVERWRITE}, then this method fails with an exception.
     *
     * @param f The file path to write to
     * @param overwriteMode The action to take if a file or directory already exists at the given
     *     path.
     * @return The stream to the new file at the target path.
     * @throws IOException Thrown, if the stream could not be opened because of an I/O, or because a
     *     file already exists at that path and the write mode indicates to not overwrite the file.
     */
    public abstract FSDataOutputStream create(Path f, WriteMode overwriteMode) throws IOException;

    /**
     * Renames the file/directory src to dst.
     *
     * @param src the file/directory to rename
     * @param dst the new name of the file/directory
     * @return &lt;code&gt;true&lt;/code&gt; if the renaming was successful, &lt;code&gt;false&lt;/code&gt; otherwise
     * @throws IOException
     */
    public abstract boolean rename(Path src, Path dst) throws IOException;

    /**
     * Returns true if this is a distributed file system. A distributed file system here means that
     * the file system is shared among all Flink processes that participate in a cluster or job and
     * that all these processes can see the same files.
     *
     * @return True, if this is a distributed file system, false otherwise.
     */
    public abstract boolean isDistributedFS();

    /**
     * Gets a description of the characteristics of this file system.
     *
     * @deprecated this method is not used anymore.
     */
    @Deprecated
    public abstract FileSystemKind getKind();

    // ------------------------------------------------------------------------
    //  output directory initialization
    // ------------------------------------------------------------------------

    /**
     * Initializes output directories on local file systems according to the given write mode.
     *
     * &lt;ul&gt;
     *   &lt;li&gt;WriteMode.NO_OVERWRITE &amp;amp; parallel output:
     *       &lt;ul&gt;
     *         &lt;li&gt;A directory is created if the output path does not exist.
     *         &lt;li&gt;An existing directory is reused, files contained in the directory are NOT
     *             deleted.
     *         &lt;li&gt;An existing file raises an exception.
     *       &lt;/ul&gt;
     *   &lt;li&gt;WriteMode.NO_OVERWRITE &amp;amp; NONE parallel output:
     *       &lt;ul&gt;
     *         &lt;li&gt;An existing file or directory raises an exception.
     *       &lt;/ul&gt;
     *   &lt;li&gt;WriteMode.OVERWRITE &amp;amp; parallel output:
     *       &lt;ul&gt;
     *         &lt;li&gt;A directory is created if the output path does not exist.
     *         &lt;li&gt;An existing directory is reused, files contained in the directory are NOT
     *             deleted.
     *         &lt;li&gt;An existing file is deleted and replaced by a new directory.
     *       &lt;/ul&gt;
     *   &lt;li&gt;WriteMode.OVERWRITE &amp;amp; NONE parallel output:
     *       &lt;ul&gt;
     *         &lt;li&gt;An existing file or directory (and all its content) is deleted
     *       &lt;/ul&gt;
     * &lt;/ul&gt;
     *
     * &lt;p&gt;Files contained in an existing directory are not deleted, because multiple instances of a
     * DataSinkTask might call this function at the same time and hence might perform concurrent
     * delete operations on the file system (possibly deleting output files of concurrently running
     * tasks). Since concurrent DataSinkTasks are not aware of each other, coordination of delete
     * and create operations would be difficult.
     *
     * @param outPath Output path that should be prepared.
     * @param writeMode Write mode to consider.
     * @param createDirectory True, to initialize a directory at the given path, false to prepare
     *     space for a file.
     * @return True, if the path was successfully prepared, false otherwise.
     * @throws IOException Thrown, if any of the file system access operations failed.
     */
    public boolean initOutPathLocalFS(Path outPath, WriteMode writeMode, boolean createDirectory)
            throws IOException {
<span class="pc bpc" id="L825" title="1 of 2 branches missed.">        if (isDistributedFS()) {</span>
<span class="nc" id="L826">            return false;</span>
        }

        // NOTE: We actually need to lock here (process wide). Otherwise, multiple threads that
        // concurrently work in this method (multiple output formats writing locally) might end
        // up deleting each other's directories and leave non-retrievable files, without necessarily
        // causing an exception. That results in very subtle issues, like output files looking as if
        // they are not getting created.

        // we acquire the lock interruptibly here, to make sure that concurrent threads waiting
        // here can cancel faster
        try {
<span class="fc" id="L838">            OUTPUT_DIRECTORY_INIT_LOCK.lockInterruptibly();</span>
<span class="nc" id="L839">        } catch (InterruptedException e) {</span>
            // restore the interruption state
<span class="nc" id="L841">            Thread.currentThread().interrupt();</span>

            // leave the method - we don't have the lock anyways
<span class="nc" id="L844">            throw new IOException(</span>
                    &quot;The thread was interrupted while trying to initialize the output directory&quot;);
<span class="fc" id="L846">        }</span>

        try {
            FileStatus status;
            try {
<span class="fc" id="L851">                status = getFileStatus(outPath);</span>
<span class="fc" id="L852">            } catch (FileNotFoundException e) {</span>
                // okay, the file is not there
<span class="fc" id="L854">                status = null;</span>
<span class="fc" id="L855">            }</span>

            // check if path exists
<span class="fc bfc" id="L858" title="All 2 branches covered.">            if (status != null) {</span>
                // path exists, check write mode
<span class="pc bpc" id="L860" title="1 of 3 branches missed.">                switch (writeMode) {</span>
                    case NO_OVERWRITE:
<span class="fc bfc" id="L862" title="All 4 branches covered.">                        if (status.isDir() &amp;&amp; createDirectory) {</span>
<span class="fc" id="L863">                            return true;</span>
                        } else {
                            // file may not be overwritten
<span class="fc" id="L866">                            throw new IOException(</span>
                                    &quot;File or directory &quot;
                                            + outPath
                                            + &quot; already exists. Existing files and directories &quot;
                                            + &quot;are not overwritten in &quot;
<span class="fc" id="L871">                                            + WriteMode.NO_OVERWRITE.name()</span>
                                            + &quot; mode. Use &quot;
<span class="fc" id="L873">                                            + WriteMode.OVERWRITE.name()</span>
                                            + &quot; mode to overwrite existing files and directories.&quot;);
                        }

                    case OVERWRITE:
<span class="fc bfc" id="L878" title="All 2 branches covered.">                        if (status.isDir()) {</span>
<span class="fc bfc" id="L879" title="All 2 branches covered.">                            if (createDirectory) {</span>
                                // directory exists and does not need to be created
<span class="fc" id="L881">                                return true;</span>
                            } else {
                                // we will write in a single file, delete directory
                                try {
<span class="fc" id="L885">                                    delete(outPath, true);</span>
<span class="nc" id="L886">                                } catch (IOException e) {</span>
<span class="nc" id="L887">                                    throw new IOException(</span>
                                            &quot;Could not remove existing directory '&quot;
                                                    + outPath
                                                    + &quot;' to allow overwrite by result file&quot;,
                                            e);
<span class="fc" id="L892">                                }</span>
                            }
                        } else {
                            // delete file
                            try {
<span class="fc" id="L897">                                delete(outPath, false);</span>
<span class="nc" id="L898">                            } catch (IOException e) {</span>
<span class="nc" id="L899">                                throw new IOException(</span>
                                        &quot;Could not remove existing file '&quot;
                                                + outPath
                                                + &quot;' to allow overwrite by result file/directory&quot;,
                                        e);
<span class="fc" id="L904">                            }</span>
                        }
                        break;

                    default:
<span class="nc" id="L909">                        throw new IllegalArgumentException(&quot;Invalid write mode: &quot; + writeMode);</span>
                }
            }

<span class="fc bfc" id="L913" title="All 2 branches covered.">            if (createDirectory) {</span>
                // Output directory needs to be created
<span class="pc bpc" id="L915" title="1 of 2 branches missed.">                if (!exists(outPath)) {</span>
<span class="fc" id="L916">                    mkdirs(outPath);</span>
                }

                // double check that the output directory exists
                try {
<span class="fc" id="L921">                    return getFileStatus(outPath).isDir();</span>
<span class="nc" id="L922">                } catch (FileNotFoundException e) {</span>
<span class="nc" id="L923">                    return false;</span>
                }
            } else {
                // check that the output path does not exist and an output file
                // can be created by the output format.
<span class="pc bpc" id="L928" title="1 of 2 branches missed.">                return !exists(outPath);</span>
            }
        } finally {
<span class="fc" id="L931">            OUTPUT_DIRECTORY_INIT_LOCK.unlock();</span>
        }
    }

    /**
     * Initializes output directories on distributed file systems according to the given write mode.
     *
     * &lt;p&gt;WriteMode.NO_OVERWRITE &amp;amp; parallel output: - A directory is created if the output path
     * does not exist. - An existing file or directory raises an exception.
     *
     * &lt;p&gt;WriteMode.NO_OVERWRITE &amp;amp; NONE parallel output: - An existing file or directory raises
     * an exception.
     *
     * &lt;p&gt;WriteMode.OVERWRITE &amp;amp; parallel output: - A directory is created if the output path
     * does not exist. - An existing directory and its content is deleted and a new directory is
     * created. - An existing file is deleted and replaced by a new directory.
     *
     * &lt;p&gt;WriteMode.OVERWRITE &amp;amp; NONE parallel output: - An existing file or directory is deleted
     * and replaced by a new directory.
     *
     * @param outPath Output path that should be prepared.
     * @param writeMode Write mode to consider.
     * @param createDirectory True, to initialize a directory at the given path, false otherwise.
     * @return True, if the path was successfully prepared, false otherwise.
     * @throws IOException Thrown, if any of the file system access operations failed.
     */
    public boolean initOutPathDistFS(Path outPath, WriteMode writeMode, boolean createDirectory)
            throws IOException {
<span class="nc bnc" id="L959" title="All 2 branches missed.">        if (!isDistributedFS()) {</span>
<span class="nc" id="L960">            return false;</span>
        }

        // NOTE: We actually need to lock here (process wide). Otherwise, multiple threads that
        // concurrently work in this method (multiple output formats writing locally) might end
        // up deleting each other's directories and leave non-retrievable files, without necessarily
        // causing an exception. That results in very subtle issues, like output files looking as if
        // they are not getting created.

        // we acquire the lock interruptibly here, to make sure that concurrent threads waiting
        // here can cancel faster
        try {
<span class="nc" id="L972">            OUTPUT_DIRECTORY_INIT_LOCK.lockInterruptibly();</span>
<span class="nc" id="L973">        } catch (InterruptedException e) {</span>
            // restore the interruption state
<span class="nc" id="L975">            Thread.currentThread().interrupt();</span>

            // leave the method - we don't have the lock anyways
<span class="nc" id="L978">            throw new IOException(</span>
                    &quot;The thread was interrupted while trying to initialize the output directory&quot;);
<span class="nc" id="L980">        }</span>

        try {
            // check if path exists
<span class="nc bnc" id="L984" title="All 2 branches missed.">            if (exists(outPath)) {</span>
                // path exists, check write mode
<span class="nc bnc" id="L986" title="All 3 branches missed.">                switch (writeMode) {</span>
                    case NO_OVERWRITE:
                        // file or directory may not be overwritten
<span class="nc" id="L989">                        throw new IOException(</span>
                                &quot;File or directory already exists. Existing files and directories are not overwritten in &quot;
<span class="nc" id="L991">                                        + WriteMode.NO_OVERWRITE.name()</span>
                                        + &quot; mode. Use &quot;
<span class="nc" id="L993">                                        + WriteMode.OVERWRITE.name()</span>
                                        + &quot; mode to overwrite existing files and directories.&quot;);

                    case OVERWRITE:
                        // output path exists. We delete it and all contained files in case of a
                        // directory.
                        try {
<span class="nc" id="L1000">                            delete(outPath, true);</span>
<span class="nc" id="L1001">                        } catch (IOException e) {</span>
                            // Some other thread might already have deleted the path.
                            // If - for some other reason - the path could not be deleted,
                            // this will be handled later.
<span class="nc" id="L1005">                        }</span>
<span class="nc" id="L1006">                        break;</span>

                    default:
<span class="nc" id="L1009">                        throw new IllegalArgumentException(&quot;Invalid write mode: &quot; + writeMode);</span>
                }
            }

<span class="nc bnc" id="L1013" title="All 2 branches missed.">            if (createDirectory) {</span>
                // Output directory needs to be created
                try {
<span class="nc bnc" id="L1016" title="All 2 branches missed.">                    if (!exists(outPath)) {</span>
<span class="nc" id="L1017">                        mkdirs(outPath);</span>
                    }
<span class="nc" id="L1019">                } catch (IOException ioe) {</span>
                    // Some other thread might already have created the directory.
                    // If - for some other reason - the directory could not be created
                    // and the path does not exist, this will be handled later.
<span class="nc" id="L1023">                }</span>

                // double check that the output directory exists
<span class="nc bnc" id="L1026" title="All 4 branches missed.">                return exists(outPath) &amp;&amp; getFileStatus(outPath).isDir();</span>
            } else {
                // single file case: check that the output path does not exist and
                // an output file can be created by the output format.
<span class="nc bnc" id="L1030" title="All 2 branches missed.">                return !exists(outPath);</span>
            }
        } finally {
<span class="nc" id="L1033">            OUTPUT_DIRECTORY_INIT_LOCK.unlock();</span>
        }
    }

    // ------------------------------------------------------------------------

    /**
     * Loads the factories for the file systems directly supported by Flink. Aside from the {@link
     * LocalFileSystem}, these file systems are loaded via Java's service framework.
     *
     * @return A map from the file system scheme to corresponding file system factory.
     */
    private static List&lt;FileSystemFactory&gt; loadFileSystemFactories(
            Collection&lt;Supplier&lt;Iterator&lt;FileSystemFactory&gt;&gt;&gt; factoryIteratorsSuppliers) {

<span class="fc" id="L1048">        final ArrayList&lt;FileSystemFactory&gt; list = new ArrayList&lt;&gt;();</span>

        // by default, we always have the local file system factory
<span class="fc" id="L1051">        list.add(new LocalFileSystemFactory());</span>

<span class="fc" id="L1053">        LOG.debug(&quot;Loading extension file systems via services&quot;);</span>

        for (Supplier&lt;Iterator&lt;FileSystemFactory&gt;&gt; factoryIteratorsSupplier :
<span class="fc bfc" id="L1056" title="All 2 branches covered.">                factoryIteratorsSuppliers) {</span>
            try {
<span class="fc" id="L1058">                addAllFactoriesToList(factoryIteratorsSupplier.get(), list);</span>
<span class="nc" id="L1059">            } catch (Throwable t) {</span>
                // catching Throwable here to handle various forms of class loading
                // and initialization errors
<span class="nc" id="L1062">                ExceptionUtils.rethrowIfFatalErrorOrOOM(t);</span>
<span class="nc" id="L1063">                LOG.error(&quot;Failed to load additional file systems via services&quot;, t);</span>
<span class="fc" id="L1064">            }</span>
<span class="fc" id="L1065">        }</span>

<span class="fc" id="L1067">        return Collections.unmodifiableList(list);</span>
    }

    private static void addAllFactoriesToList(
            Iterator&lt;FileSystemFactory&gt; iter, List&lt;FileSystemFactory&gt; list) {
        // we explicitly use an iterator here (rather than for-each) because that way
        // we can catch errors in individual service instantiations

<span class="fc bfc" id="L1075" title="All 2 branches covered.">        while (iter.hasNext()) {</span>
            try {
<span class="fc" id="L1077">                FileSystemFactory factory = iter.next();</span>
<span class="fc" id="L1078">                list.add(factory);</span>
<span class="fc" id="L1079">                LOG.debug(</span>
                        &quot;Added file system {}:{}&quot;,
<span class="fc" id="L1081">                        factory.getScheme(),</span>
<span class="fc" id="L1082">                        factory.getClass().getSimpleName());</span>
<span class="nc" id="L1083">            } catch (Throwable t) {</span>
                // catching Throwable here to handle various forms of class loading
                // and initialization errors
<span class="nc" id="L1086">                ExceptionUtils.rethrowIfFatalErrorOrOOM(t);</span>
<span class="nc" id="L1087">                LOG.error(&quot;Failed to load a file system via services&quot;, t);</span>
<span class="pc" id="L1088">            }</span>
        }
<span class="fc" id="L1090">    }</span>

    /**
     * Utility loader for the Hadoop file system factory. We treat the Hadoop FS factory in a
     * special way, because we use it as a catch all for file systems schemes not supported directly
     * in Flink.
     *
     * &lt;p&gt;This method does a set of eager checks for availability of certain classes, to be able to
     * give better error messages.
     */
    private static FileSystemFactory loadHadoopFsFactory() {
<span class="fc" id="L1101">        final ClassLoader cl = FileSystem.class.getClassLoader();</span>

        // first, see if the Flink runtime classes are available
        final Class&lt;? extends FileSystemFactory&gt; factoryClass;
        try {
<span class="fc" id="L1106">            factoryClass =</span>
<span class="nc" id="L1107">                    Class.forName(&quot;org.apache.flink.runtime.fs.hdfs.HadoopFsFactory&quot;, false, cl)</span>
<span class="nc" id="L1108">                            .asSubclass(FileSystemFactory.class);</span>
<span class="fc" id="L1109">        } catch (ClassNotFoundException e) {</span>
<span class="fc" id="L1110">            LOG.info(</span>
                    &quot;No Flink runtime dependency present. &quot;
                            + &quot;The extended set of supported File Systems via Hadoop is not available.&quot;);
<span class="fc" id="L1113">            return new UnsupportedSchemeFactory(</span>
                    &quot;Flink runtime classes missing in classpath/dependencies.&quot;);
<span class="nc" id="L1115">        } catch (Exception | LinkageError e) {</span>
<span class="nc" id="L1116">            LOG.warn(&quot;Flink's Hadoop file system factory could not be loaded&quot;, e);</span>
<span class="nc" id="L1117">            return new UnsupportedSchemeFactory(</span>
                    &quot;Flink's Hadoop file system factory could not be loaded&quot;, e);
<span class="nc" id="L1119">        }</span>

        // check (for eager and better exception messages) if the Hadoop classes are available here
        try {
<span class="nc" id="L1123">            Class.forName(&quot;org.apache.hadoop.conf.Configuration&quot;, false, cl);</span>
<span class="nc" id="L1124">            Class.forName(&quot;org.apache.hadoop.fs.FileSystem&quot;, false, cl);</span>
<span class="nc" id="L1125">        } catch (ClassNotFoundException e) {</span>
<span class="nc" id="L1126">            LOG.info(</span>
                    &quot;Hadoop is not in the classpath/dependencies. &quot;
                            + &quot;The extended set of supported File Systems via Hadoop is not available.&quot;);
<span class="nc" id="L1129">            return new UnsupportedSchemeFactory(&quot;Hadoop is not in the classpath/dependencies.&quot;);</span>
<span class="nc" id="L1130">        }</span>

        // Create the factory.
        try {
<span class="nc" id="L1134">            return factoryClass.newInstance();</span>
<span class="nc" id="L1135">        } catch (Exception | LinkageError e) {</span>
<span class="nc" id="L1136">            LOG.warn(&quot;Flink's Hadoop file system factory could not be created&quot;, e);</span>
<span class="nc" id="L1137">            return new UnsupportedSchemeFactory(</span>
                    &quot;Flink's Hadoop file system factory could not be created&quot;, e);
        }
    }

    // ------------------------------------------------------------------------

    /** An identifier of a file system, via its scheme and its authority. */
    private static final class FSKey {

        /** The scheme of the file system. */
        private final String scheme;

        /** The authority of the file system. */
        @Nullable private final String authority;

        /**
         * Creates a file system key from a given scheme and an authority.
         *
         * @param scheme The scheme of the file system
         * @param authority The authority of the file system
         */
<span class="fc" id="L1159">        public FSKey(String scheme, @Nullable String authority) {</span>
<span class="fc" id="L1160">            this.scheme = checkNotNull(scheme, &quot;scheme&quot;);</span>
<span class="fc" id="L1161">            this.authority = authority;</span>
<span class="fc" id="L1162">        }</span>

        @Override
        public boolean equals(final Object obj) {
<span class="pc bpc" id="L1166" title="1 of 2 branches missed.">            if (obj == this) {</span>
<span class="nc" id="L1167">                return true;</span>
<span class="pc bpc" id="L1168" title="2 of 4 branches missed.">            } else if (obj != null &amp;&amp; obj.getClass() == FSKey.class) {</span>
<span class="fc" id="L1169">                final FSKey that = (FSKey) obj;</span>
<span class="pc bpc" id="L1170" title="3 of 8 branches missed.">                return this.scheme.equals(that.scheme)</span>
                        &amp;&amp; (this.authority == null
                                ? that.authority == null
                                : (that.authority != null
<span class="pc bpc" id="L1174" title="1 of 2 branches missed.">                                        &amp;&amp; this.authority.equals(that.authority)));</span>
            } else {
<span class="nc" id="L1176">                return false;</span>
            }
        }

        @Override
        public int hashCode() {
<span class="fc bfc" id="L1182" title="All 2 branches covered.">            return 31 * scheme.hashCode() + (authority == null ? 17 : authority.hashCode());</span>
        }

        @Override
        public String toString() {
<span class="nc bnc" id="L1187" title="All 2 branches missed.">            return scheme + &quot;://&quot; + (authority != null ? authority : &quot;&quot;);</span>
        }
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.7.202105040129</span></div></body></html>