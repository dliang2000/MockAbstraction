<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>FieldParser.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Flink : Core</a> &gt; <a href="index.source.html" class="el_package">org.apache.flink.types.parser</a> &gt; <span class="el_source">FieldParser.java</span></div><h1>FieldParser.java</h1><pre class="source lang-java linenums">/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * &quot;License&quot;); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.apache.flink.types.parser;

import org.apache.flink.annotation.PublicEvolving;
import org.apache.flink.types.BooleanValue;
import org.apache.flink.types.ByteValue;
import org.apache.flink.types.DoubleValue;
import org.apache.flink.types.FloatValue;
import org.apache.flink.types.IntValue;
import org.apache.flink.types.LongValue;
import org.apache.flink.types.ShortValue;
import org.apache.flink.types.StringValue;

import java.math.BigDecimal;
import java.math.BigInteger;
import java.nio.charset.Charset;
import java.nio.charset.StandardCharsets;
import java.util.HashMap;
import java.util.Map;

/**
 * A FieldParser is used parse a field from a sequence of bytes. Fields occur in a byte sequence and
 * are terminated by the end of the byte sequence or a delimiter.
 *
 * &lt;p&gt;The parsers do not throw exceptions in general, but set an error state. That way, they can be
 * used in functions that ignore invalid lines, rather than failing on them.
 *
 * @param &lt;T&gt; The type that is parsed.
 */
@PublicEvolving
<span class="fc" id="L48">public abstract class FieldParser&lt;T&gt; {</span>

    /** An enumeration of different types of errors that may occur. */
<span class="fc" id="L51">    public static enum ParseErrorState {</span>
        /** No error occurred. */
<span class="fc" id="L53">        NONE,</span>

        /** The domain of the numeric type is not large enough to hold the parsed value. */
<span class="fc" id="L56">        NUMERIC_VALUE_OVERFLOW_UNDERFLOW,</span>

        /** A stand-alone sign was encountered while parsing a numeric type. */
<span class="fc" id="L59">        NUMERIC_VALUE_ORPHAN_SIGN,</span>

        /** An illegal character was encountered while parsing a numeric type. */
<span class="fc" id="L62">        NUMERIC_VALUE_ILLEGAL_CHARACTER,</span>

        /** The field was not in a correct format for the numeric type. */
<span class="fc" id="L65">        NUMERIC_VALUE_FORMAT_ERROR,</span>

        /** A quoted string was not terminated until the line end. */
<span class="fc" id="L68">        UNTERMINATED_QUOTED_STRING,</span>

        /** The parser found characters between the end of the quoted string and the delimiter. */
<span class="fc" id="L71">        UNQUOTED_CHARS_AFTER_QUOTED_STRING,</span>

        /** The column is empty. */
<span class="fc" id="L74">        EMPTY_COLUMN,</span>

        /** Invalid Boolean value * */
<span class="fc" id="L77">        BOOLEAN_INVALID</span>
    }

<span class="fc" id="L80">    private Charset charset = StandardCharsets.UTF_8;</span>

<span class="fc" id="L82">    private ParseErrorState errorState = ParseErrorState.NONE;</span>

    /**
     * Parses the value of a field from the byte array, taking care of properly reset the state of
     * this parser. The start position within the byte array and the array's valid length is given.
     * The content of the value is delimited by a field delimiter.
     *
     * @param bytes The byte array that holds the value.
     * @param startPos The index where the field starts
     * @param limit The limit unto which the byte contents is valid for the parser. The limit is the
     *     position one after the last valid byte.
     * @param delim The field delimiter character
     * @param reuse An optional reusable field to hold the value
     * @return The index of the next delimiter, if the field was parsed correctly. A value less than
     *     0 otherwise.
     */
    public int resetErrorStateAndParse(
            byte[] bytes, int startPos, int limit, byte[] delim, T reuse) {
<span class="fc" id="L100">        resetParserState();</span>
<span class="fc" id="L101">        return parseField(bytes, startPos, limit, delim, reuse);</span>
    }

    /** Each parser's logic should be implemented inside this method */
    protected abstract int parseField(byte[] bytes, int startPos, int limit, byte[] delim, T reuse);

    /**
     * Reset the state of the parser. Called as the very first method inside {@link
     * FieldParser#resetErrorStateAndParse(byte[], int, int, byte[], Object)}, by default it just
     * reset its error state.
     */
    protected void resetParserState() {
<span class="fc" id="L113">        this.errorState = ParseErrorState.NONE;</span>
<span class="fc" id="L114">    }</span>

    /**
     * Gets the parsed field. This method returns the value parsed by the last successful invocation
     * of {@link #parseField(byte[], int, int, byte[], Object)}. It objects are mutable and reused,
     * it will return the object instance that was passed the parse function.
     *
     * @return The latest parsed field.
     */
    public abstract T getLastResult();

    /**
     * Returns an instance of the parsed value type.
     *
     * @return An instance of the parsed value type.
     */
    public abstract T createValue();

    /**
     * Checks if the delimiter starts at the given start position of the byte array.
     *
     * &lt;p&gt;Attention: This method assumes that enough characters follow the start position for the
     * delimiter check!
     *
     * @param bytes The byte array that holds the value.
     * @param startPos The index of the byte array where the check for the delimiter starts.
     * @param delim The delimiter to check for.
     * @return true if a delimiter starts at the given start position, false otherwise.
     */
    public static final boolean delimiterNext(byte[] bytes, int startPos, byte[] delim) {

<span class="fc bfc" id="L145" title="All 2 branches covered.">        for (int pos = 0; pos &lt; delim.length; pos++) {</span>
            // check each position
<span class="fc bfc" id="L147" title="All 2 branches covered.">            if (delim[pos] != bytes[startPos + pos]) {</span>
<span class="fc" id="L148">                return false;</span>
            }
        }
<span class="fc" id="L151">        return true;</span>
    }

    /**
     * Checks if the given bytes ends with the delimiter at the given end position.
     *
     * @param bytes The byte array that holds the value.
     * @param endPos The index of the byte array where the check for the delimiter ends.
     * @param delim The delimiter to check for.
     * @return true if a delimiter ends at the given end position, false otherwise.
     */
    public static final boolean endsWithDelimiter(byte[] bytes, int endPos, byte[] delim) {
<span class="fc bfc" id="L163" title="All 2 branches covered.">        if (endPos &lt; delim.length - 1) {</span>
<span class="fc" id="L164">            return false;</span>
        }
<span class="fc bfc" id="L166" title="All 2 branches covered.">        for (int pos = 0; pos &lt; delim.length; ++pos) {</span>
<span class="fc bfc" id="L167" title="All 2 branches covered.">            if (delim[pos] != bytes[endPos - delim.length + 1 + pos]) {</span>
<span class="fc" id="L168">                return false;</span>
            }
        }
<span class="fc" id="L171">        return true;</span>
    }

    /**
     * Sets the error state of the parser. Called by subclasses of the parser to set the type of
     * error when failing a parse.
     *
     * @param error The error state to set.
     */
    protected void setErrorState(ParseErrorState error) {
<span class="fc" id="L181">        this.errorState = error;</span>
<span class="fc" id="L182">    }</span>

    /**
     * Gets the error state of the parser, as a value of the enumeration {@link ParseErrorState}. If
     * no error occurred, the error state will be {@link ParseErrorState#NONE}.
     *
     * @return The current error state of the parser.
     */
    public ParseErrorState getErrorState() {
<span class="fc" id="L191">        return this.errorState;</span>
    }

    /**
     * Returns the end position of a string. Sets the error state if the column is empty.
     *
     * @return the end position of the string or -1 if an error occurred
     */
    protected final int nextStringEndPos(byte[] bytes, int startPos, int limit, byte[] delimiter) {
<span class="fc" id="L200">        int endPos = startPos;</span>

<span class="fc" id="L202">        final int delimLimit = limit - delimiter.length + 1;</span>

<span class="fc bfc" id="L204" title="All 2 branches covered.">        while (endPos &lt; limit) {</span>
<span class="fc bfc" id="L205" title="All 4 branches covered.">            if (endPos &lt; delimLimit &amp;&amp; delimiterNext(bytes, endPos, delimiter)) {</span>
<span class="fc" id="L206">                break;</span>
            }
<span class="fc" id="L208">            endPos++;</span>
        }

<span class="fc bfc" id="L211" title="All 2 branches covered.">        if (endPos == startPos) {</span>
<span class="fc" id="L212">            setErrorState(ParseErrorState.EMPTY_COLUMN);</span>
<span class="fc" id="L213">            return -1;</span>
        }
<span class="fc" id="L215">        return endPos;</span>
    }

    /**
     * Returns the length of a string. Throws an exception if the column is empty.
     *
     * @return the length of the string
     */
    protected static final int nextStringLength(
            byte[] bytes, int startPos, int length, char delimiter) {
<span class="nc bnc" id="L225" title="All 2 branches missed.">        if (length &lt;= 0) {</span>
<span class="nc" id="L226">            throw new IllegalArgumentException(&quot;Invalid input: Empty string&quot;);</span>
        }
<span class="nc" id="L228">        int limitedLength = 0;</span>
<span class="nc" id="L229">        final byte delByte = (byte) delimiter;</span>

<span class="nc bnc" id="L231" title="All 4 branches missed.">        while (limitedLength &lt; length &amp;&amp; bytes[startPos + limitedLength] != delByte) {</span>
<span class="nc" id="L232">            limitedLength++;</span>
        }

<span class="nc" id="L235">        return limitedLength;</span>
    }

    /**
     * Gets the character set used for this parser.
     *
     * @return the charset used for this parser.
     */
    public Charset getCharset() {
<span class="fc" id="L244">        return this.charset;</span>
    }

    /**
     * Sets the character set used for this parser.
     *
     * @param charset charset used for this parser.
     */
    public void setCharset(Charset charset) {
<span class="fc" id="L253">        this.charset = charset;</span>
<span class="fc" id="L254">    }</span>

    // --------------------------------------------------------------------------------------------
    //  Mapping from types to parsers
    // --------------------------------------------------------------------------------------------

    /**
     * Gets the parser for the type specified by the given class. Returns null, if no parser for
     * that class is known.
     *
     * @param type The class of the type to get the parser for.
     * @return The parser for the given type, or null, if no such parser exists.
     */
    public static &lt;T&gt; Class&lt;FieldParser&lt;T&gt;&gt; getParserForType(Class&lt;T&gt; type) {
<span class="fc" id="L268">        Class&lt;? extends FieldParser&lt;?&gt;&gt; parser = PARSERS.get(type);</span>
<span class="pc bpc" id="L269" title="1 of 2 branches missed.">        if (parser == null) {</span>
<span class="nc" id="L270">            return null;</span>
        } else {
            @SuppressWarnings(&quot;unchecked&quot;)
<span class="fc" id="L273">            Class&lt;FieldParser&lt;T&gt;&gt; typedParser = (Class&lt;FieldParser&lt;T&gt;&gt;) parser;</span>
<span class="fc" id="L274">            return typedParser;</span>
        }
    }

<span class="fc" id="L278">    private static final Map&lt;Class&lt;?&gt;, Class&lt;? extends FieldParser&lt;?&gt;&gt;&gt; PARSERS =</span>
            new HashMap&lt;Class&lt;?&gt;, Class&lt;? extends FieldParser&lt;?&gt;&gt;&gt;();

    static {
        // basic types
<span class="fc" id="L283">        PARSERS.put(Byte.class, ByteParser.class);</span>
<span class="fc" id="L284">        PARSERS.put(Short.class, ShortParser.class);</span>
<span class="fc" id="L285">        PARSERS.put(Integer.class, IntParser.class);</span>
<span class="fc" id="L286">        PARSERS.put(Long.class, LongParser.class);</span>
<span class="fc" id="L287">        PARSERS.put(String.class, StringParser.class);</span>
<span class="fc" id="L288">        PARSERS.put(Float.class, FloatParser.class);</span>
<span class="fc" id="L289">        PARSERS.put(Double.class, DoubleParser.class);</span>
<span class="fc" id="L290">        PARSERS.put(Boolean.class, BooleanParser.class);</span>
<span class="fc" id="L291">        PARSERS.put(BigDecimal.class, BigDecParser.class);</span>
<span class="fc" id="L292">        PARSERS.put(BigInteger.class, BigIntParser.class);</span>

        // value types
<span class="fc" id="L295">        PARSERS.put(ByteValue.class, ByteValueParser.class);</span>
<span class="fc" id="L296">        PARSERS.put(ShortValue.class, ShortValueParser.class);</span>
<span class="fc" id="L297">        PARSERS.put(IntValue.class, IntValueParser.class);</span>
<span class="fc" id="L298">        PARSERS.put(LongValue.class, LongValueParser.class);</span>
<span class="fc" id="L299">        PARSERS.put(StringValue.class, StringValueParser.class);</span>
<span class="fc" id="L300">        PARSERS.put(FloatValue.class, FloatValueParser.class);</span>
<span class="fc" id="L301">        PARSERS.put(DoubleValue.class, DoubleValueParser.class);</span>
<span class="fc" id="L302">        PARSERS.put(BooleanValue.class, BooleanValueParser.class);</span>

        // SQL date/time types
<span class="fc" id="L305">        PARSERS.put(java.sql.Time.class, SqlTimeParser.class);</span>
<span class="fc" id="L306">        PARSERS.put(java.sql.Date.class, SqlDateParser.class);</span>
<span class="fc" id="L307">        PARSERS.put(java.sql.Timestamp.class, SqlTimestampParser.class);</span>
<span class="fc" id="L308">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.7.202105040129</span></div></body></html>