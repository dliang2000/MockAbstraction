<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>ReduceOperatorBase.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Flink : Core</a> &gt; <a href="index.source.html" class="el_package">org.apache.flink.api.common.operators.base</a> &gt; <span class="el_source">ReduceOperatorBase.java</span></div><h1>ReduceOperatorBase.java</h1><pre class="source lang-java linenums">/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * &quot;License&quot;); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.apache.flink.api.common.operators.base;

import org.apache.flink.annotation.Internal;
import org.apache.flink.api.common.ExecutionConfig;
import org.apache.flink.api.common.InvalidProgramException;
import org.apache.flink.api.common.functions.Partitioner;
import org.apache.flink.api.common.functions.ReduceFunction;
import org.apache.flink.api.common.functions.RuntimeContext;
import org.apache.flink.api.common.functions.util.FunctionUtils;
import org.apache.flink.api.common.operators.SingleInputOperator;
import org.apache.flink.api.common.operators.UnaryOperatorInformation;
import org.apache.flink.api.common.operators.util.TypeComparable;
import org.apache.flink.api.common.operators.util.UserCodeClassWrapper;
import org.apache.flink.api.common.operators.util.UserCodeObjectWrapper;
import org.apache.flink.api.common.operators.util.UserCodeWrapper;
import org.apache.flink.api.common.typeinfo.AtomicType;
import org.apache.flink.api.common.typeinfo.TypeInformation;
import org.apache.flink.api.common.typeutils.CompositeType;
import org.apache.flink.api.common.typeutils.TypeComparator;
import org.apache.flink.api.common.typeutils.TypeSerializer;

import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

/**
 * Base data flow operator for Reduce user-defined functions. Accepts reduce functions and key
 * positions. The key positions are expected in the flattened common data model.
 *
 * @see org.apache.flink.api.common.functions.ReduceFunction
 * @param &lt;T&gt; The type (parameters and return type) of the reduce function.
 * @param &lt;FT&gt; The type of the reduce function.
 */
@Internal
public class ReduceOperatorBase&lt;T, FT extends ReduceFunction&lt;T&gt;&gt;
        extends SingleInputOperator&lt;T, T, FT&gt; {

    /**
     * An enumeration of hints, optionally usable to tell the system exactly how to execute the
     * combiner phase of a reduce. (Note: The final reduce phase (after combining) is currently
     * always executed by a sort-based strategy.)
     */
<span class="nc" id="L63">    public enum CombineHint {</span>

        /**
         * Leave the choice how to do the combine to the optimizer. (This currently defaults to
         * SORT.)
         */
<span class="nc" id="L69">        OPTIMIZER_CHOOSES,</span>

        /** Use a sort-based strategy. */
<span class="nc" id="L72">        SORT,</span>

        /**
         * Use a hash-based strategy. This should be faster in most cases, especially if the number
         * of different keys is small compared to the number of input elements (eg. 1/10).
         */
<span class="nc" id="L78">        HASH,</span>

        /** Disable the use of a combiner. */
<span class="nc" id="L81">        NONE</span>
    }

    private CombineHint hint;

    private Partitioner&lt;?&gt; customPartitioner;

    /**
     * Creates a grouped reduce data flow operator.
     *
     * @param udf The user-defined function, contained in the UserCodeWrapper.
     * @param operatorInfo The type information, describing input and output types of the reduce
     *     function.
     * @param keyPositions The positions of the key fields, in the common data model (flattened).
     * @param name The name of the operator (for logging and messages).
     */
    public ReduceOperatorBase(
            UserCodeWrapper&lt;FT&gt; udf,
            UnaryOperatorInformation&lt;T, T&gt; operatorInfo,
            int[] keyPositions,
            String name) {
<span class="nc" id="L102">        super(udf, operatorInfo, keyPositions, name);</span>
<span class="nc" id="L103">    }</span>

    /**
     * Creates a grouped reduce data flow operator.
     *
     * @param udf The user-defined function, as a function object.
     * @param operatorInfo The type information, describing input and output types of the reduce
     *     function.
     * @param keyPositions The positions of the key fields, in the common data model (flattened).
     * @param name The name of the operator (for logging and messages).
     */
    public ReduceOperatorBase(
            FT udf, UnaryOperatorInformation&lt;T, T&gt; operatorInfo, int[] keyPositions, String name) {
<span class="nc" id="L116">        super(new UserCodeObjectWrapper&lt;FT&gt;(udf), operatorInfo, keyPositions, name);</span>
<span class="nc" id="L117">    }</span>

    /**
     * Creates a grouped reduce data flow operator.
     *
     * @param udf The class representing the parameterless user-defined function.
     * @param operatorInfo The type information, describing input and output types of the reduce
     *     function.
     * @param keyPositions The positions of the key fields, in the common data model (flattened).
     * @param name The name of the operator (for logging and messages).
     */
    public ReduceOperatorBase(
            Class&lt;? extends FT&gt; udf,
            UnaryOperatorInformation&lt;T, T&gt; operatorInfo,
            int[] keyPositions,
            String name) {
<span class="nc" id="L133">        super(new UserCodeClassWrapper&lt;FT&gt;(udf), operatorInfo, keyPositions, name);</span>
<span class="nc" id="L134">    }</span>

    // --------------------------------------------------------------------------------------------
    //  Non-grouped reduce operations
    // --------------------------------------------------------------------------------------------

    /**
     * Creates a non-grouped reduce data flow operator (all-reduce).
     *
     * @param udf The user-defined function, contained in the UserCodeWrapper.
     * @param operatorInfo The type information, describing input and output types of the reduce
     *     function.
     * @param name The name of the operator (for logging and messages).
     */
    public ReduceOperatorBase(
            UserCodeWrapper&lt;FT&gt; udf, UnaryOperatorInformation&lt;T, T&gt; operatorInfo, String name) {
<span class="nc" id="L150">        super(udf, operatorInfo, name);</span>
<span class="nc" id="L151">    }</span>

    /**
     * Creates a non-grouped reduce data flow operator (all-reduce).
     *
     * @param udf The user-defined function, as a function object.
     * @param operatorInfo The type information, describing input and output types of the reduce
     *     function.
     * @param name The name of the operator (for logging and messages).
     */
    public ReduceOperatorBase(FT udf, UnaryOperatorInformation&lt;T, T&gt; operatorInfo, String name) {
<span class="nc" id="L162">        super(new UserCodeObjectWrapper&lt;FT&gt;(udf), operatorInfo, name);</span>
<span class="nc" id="L163">    }</span>

    /**
     * Creates a non-grouped reduce data flow operator (all-reduce).
     *
     * @param udf The class representing the parameterless user-defined function.
     * @param operatorInfo The type information, describing input and output types of the reduce
     *     function.
     * @param name The name of the operator (for logging and messages).
     */
    public ReduceOperatorBase(
            Class&lt;? extends FT&gt; udf, UnaryOperatorInformation&lt;T, T&gt; operatorInfo, String name) {
<span class="nc" id="L175">        super(new UserCodeClassWrapper&lt;FT&gt;(udf), operatorInfo, name);</span>
<span class="nc" id="L176">    }</span>

    // --------------------------------------------------------------------------------------------

    public void setCustomPartitioner(Partitioner&lt;?&gt; customPartitioner) {
<span class="nc bnc" id="L181" title="All 2 branches missed.">        if (customPartitioner != null) {</span>
<span class="nc" id="L182">            int[] keys = getKeyColumns(0);</span>
<span class="nc bnc" id="L183" title="All 4 branches missed.">            if (keys == null || keys.length == 0) {</span>
<span class="nc" id="L184">                throw new IllegalArgumentException(</span>
                        &quot;Cannot use custom partitioner for a non-grouped GroupReduce (AllGroupReduce)&quot;);
            }
<span class="nc bnc" id="L187" title="All 2 branches missed.">            if (keys.length &gt; 1) {</span>
<span class="nc" id="L188">                throw new IllegalArgumentException(</span>
                        &quot;Cannot use the key partitioner for composite keys (more than one key field)&quot;);
            }
        }
<span class="nc" id="L192">        this.customPartitioner = customPartitioner;</span>
<span class="nc" id="L193">    }</span>

    public Partitioner&lt;?&gt; getCustomPartitioner() {
<span class="nc" id="L196">        return customPartitioner;</span>
    }

    // --------------------------------------------------------------------------------------------

    @Override
    protected List&lt;T&gt; executeOnCollections(
            List&lt;T&gt; inputData, RuntimeContext ctx, ExecutionConfig executionConfig)
            throws Exception {
        // make sure we can handle empty inputs
<span class="nc bnc" id="L206" title="All 2 branches missed.">        if (inputData.isEmpty()) {</span>
<span class="nc" id="L207">            return Collections.emptyList();</span>
        }

<span class="nc" id="L210">        ReduceFunction&lt;T&gt; function = this.userFunction.getUserCodeObject();</span>

<span class="nc" id="L212">        UnaryOperatorInformation&lt;T, T&gt; operatorInfo = getOperatorInfo();</span>
<span class="nc" id="L213">        TypeInformation&lt;T&gt; inputType = operatorInfo.getInputType();</span>

<span class="nc" id="L215">        int[] inputColumns = getKeyColumns(0);</span>

<span class="nc bnc" id="L217" title="All 4 branches missed.">        if (!(inputType instanceof CompositeType) &amp;&amp; inputColumns.length &gt; 1) {</span>
<span class="nc" id="L218">            throw new InvalidProgramException(&quot;Grouping is only possible on composite types.&quot;);</span>
        }

<span class="nc" id="L221">        FunctionUtils.setFunctionRuntimeContext(function, ctx);</span>
<span class="nc" id="L222">        FunctionUtils.openFunction(function, this.parameters);</span>

<span class="nc" id="L224">        TypeSerializer&lt;T&gt; serializer =</span>
<span class="nc" id="L225">                getOperatorInfo().getInputType().createSerializer(executionConfig);</span>

<span class="nc bnc" id="L227" title="All 2 branches missed.">        if (inputColumns.length &gt; 0) {</span>
<span class="nc" id="L228">            boolean[] inputOrderings = new boolean[inputColumns.length];</span>
<span class="nc bnc" id="L229" title="All 2 branches missed.">            TypeComparator&lt;T&gt; inputComparator =</span>
                    inputType instanceof AtomicType
<span class="nc" id="L231">                            ? ((AtomicType&lt;T&gt;) inputType).createComparator(false, executionConfig)</span>
                            : ((CompositeType&lt;T&gt;) inputType)
<span class="nc" id="L233">                                    .createComparator(</span>
                                            inputColumns, inputOrderings, 0, executionConfig);

<span class="nc" id="L236">            Map&lt;TypeComparable&lt;T&gt;, T&gt; aggregateMap =</span>
<span class="nc" id="L237">                    new HashMap&lt;TypeComparable&lt;T&gt;, T&gt;(inputData.size() / 10);</span>

<span class="nc bnc" id="L239" title="All 2 branches missed.">            for (T next : inputData) {</span>
<span class="nc" id="L240">                TypeComparable&lt;T&gt; wrapper = new TypeComparable&lt;T&gt;(next, inputComparator);</span>

<span class="nc" id="L242">                T existing = aggregateMap.get(wrapper);</span>
                T result;

<span class="nc bnc" id="L245" title="All 2 branches missed.">                if (existing != null) {</span>
<span class="nc" id="L246">                    result = function.reduce(existing, serializer.copy(next));</span>
                } else {
<span class="nc" id="L248">                    result = next;</span>
                }

<span class="nc" id="L251">                result = serializer.copy(result);</span>

<span class="nc" id="L253">                aggregateMap.put(wrapper, result);</span>
<span class="nc" id="L254">            }</span>

<span class="nc" id="L256">            FunctionUtils.closeFunction(function);</span>
<span class="nc" id="L257">            return new ArrayList&lt;T&gt;(aggregateMap.values());</span>
        } else {
<span class="nc" id="L259">            T aggregate = inputData.get(0);</span>

<span class="nc" id="L261">            aggregate = serializer.copy(aggregate);</span>

<span class="nc bnc" id="L263" title="All 2 branches missed.">            for (int i = 1; i &lt; inputData.size(); i++) {</span>
<span class="nc" id="L264">                T next = function.reduce(aggregate, serializer.copy(inputData.get(i)));</span>
<span class="nc" id="L265">                aggregate = serializer.copy(next);</span>
            }

<span class="nc" id="L268">            FunctionUtils.setFunctionRuntimeContext(function, ctx);</span>

<span class="nc" id="L270">            return Collections.singletonList(aggregate);</span>
        }
    }

    public void setCombineHint(CombineHint hint) {
<span class="nc bnc" id="L275" title="All 2 branches missed.">        if (hint == null) {</span>
<span class="nc" id="L276">            throw new IllegalArgumentException(&quot;Reduce Hint must not be null.&quot;);</span>
        }
<span class="nc" id="L278">        this.hint = hint;</span>
<span class="nc" id="L279">    }</span>

    public CombineHint getCombineHint() {
<span class="nc" id="L282">        return hint;</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.7.202105040129</span></div></body></html>