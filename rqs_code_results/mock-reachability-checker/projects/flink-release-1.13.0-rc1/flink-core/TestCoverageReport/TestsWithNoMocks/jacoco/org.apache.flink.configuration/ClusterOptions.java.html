<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>ClusterOptions.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Flink : Core</a> &gt; <a href="index.source.html" class="el_package">org.apache.flink.configuration</a> &gt; <span class="el_source">ClusterOptions.java</span></div><h1>ClusterOptions.java</h1><pre class="source lang-java linenums">/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * &quot;License&quot;); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.apache.flink.configuration;

import org.apache.flink.annotation.PublicEvolving;
import org.apache.flink.annotation.docs.Documentation;
import org.apache.flink.configuration.description.Description;
import org.apache.flink.configuration.description.TextElement;

import java.util.ArrayList;
import java.util.List;

import static org.apache.flink.configuration.ConfigOptions.key;
import static org.apache.flink.configuration.description.LinkElement.link;
import static org.apache.flink.configuration.description.TextElement.code;
import static org.apache.flink.configuration.description.TextElement.text;

/** Options which control the cluster behaviour. */
@PublicEvolving
<span class="nc" id="L36">public class ClusterOptions {</span>

    @Documentation.Section(Documentation.Sections.EXPERT_FAULT_TOLERANCE)
<span class="nc" id="L39">    public static final ConfigOption&lt;Long&gt; INITIAL_REGISTRATION_TIMEOUT =</span>
<span class="nc" id="L40">            ConfigOptions.key(&quot;cluster.registration.initial-timeout&quot;)</span>
<span class="nc" id="L41">                    .defaultValue(100L)</span>
<span class="nc" id="L42">                    .withDescription(</span>
                            &quot;Initial registration timeout between cluster components in milliseconds.&quot;);

    @Documentation.Section(Documentation.Sections.EXPERT_FAULT_TOLERANCE)
<span class="nc" id="L46">    public static final ConfigOption&lt;Long&gt; MAX_REGISTRATION_TIMEOUT =</span>
<span class="nc" id="L47">            ConfigOptions.key(&quot;cluster.registration.max-timeout&quot;)</span>
<span class="nc" id="L48">                    .defaultValue(30000L)</span>
<span class="nc" id="L49">                    .withDescription(</span>
                            &quot;Maximum registration timeout between cluster components in milliseconds.&quot;);

    @Documentation.Section(Documentation.Sections.EXPERT_FAULT_TOLERANCE)
<span class="nc" id="L53">    public static final ConfigOption&lt;Long&gt; ERROR_REGISTRATION_DELAY =</span>
<span class="nc" id="L54">            ConfigOptions.key(&quot;cluster.registration.error-delay&quot;)</span>
<span class="nc" id="L55">                    .defaultValue(10000L)</span>
<span class="nc" id="L56">                    .withDescription(</span>
                            &quot;The pause made after an registration attempt caused an exception (other than timeout) in milliseconds.&quot;);

    @Documentation.Section(Documentation.Sections.EXPERT_FAULT_TOLERANCE)
<span class="nc" id="L60">    public static final ConfigOption&lt;Long&gt; REFUSED_REGISTRATION_DELAY =</span>
<span class="nc" id="L61">            ConfigOptions.key(&quot;cluster.registration.refused-registration-delay&quot;)</span>
<span class="nc" id="L62">                    .defaultValue(30000L)</span>
<span class="nc" id="L63">                    .withDescription(</span>
                            &quot;The pause made after the registration attempt was refused in milliseconds.&quot;);

    @Documentation.Section(Documentation.Sections.EXPERT_FAULT_TOLERANCE)
<span class="nc" id="L67">    public static final ConfigOption&lt;Long&gt; CLUSTER_SERVICES_SHUTDOWN_TIMEOUT =</span>
<span class="nc" id="L68">            ConfigOptions.key(&quot;cluster.services.shutdown-timeout&quot;)</span>
<span class="nc" id="L69">                    .defaultValue(30000L)</span>
<span class="nc" id="L70">                    .withDescription(</span>
                            &quot;The shutdown timeout for cluster services like executors in milliseconds.&quot;);

    @Documentation.Section(Documentation.Sections.EXPERT_FAULT_TOLERANCE)
<span class="nc" id="L74">    public static final ConfigOption&lt;Integer&gt; CLUSTER_IO_EXECUTOR_POOL_SIZE =</span>
<span class="nc" id="L75">            ConfigOptions.key(&quot;cluster.io-pool.size&quot;)</span>
<span class="nc" id="L76">                    .intType()</span>
<span class="nc" id="L77">                    .noDefaultValue()</span>
<span class="nc" id="L78">                    .withDescription(</span>
                            &quot;The size of the IO executor pool used by the cluster to execute blocking IO operations (Master as well as TaskManager processes). &quot;
                                    + &quot;By default it will use 4 * the number of CPU cores (hardware contexts) that the cluster process has access to. &quot;
                                    + &quot;Increasing the pool size allows to run more IO operations concurrently.&quot;);

    @Documentation.Section(Documentation.Sections.EXPERT_SCHEDULING)
<span class="nc" id="L84">    public static final ConfigOption&lt;Boolean&gt; EVENLY_SPREAD_OUT_SLOTS_STRATEGY =</span>
<span class="nc" id="L85">            ConfigOptions.key(&quot;cluster.evenly-spread-out-slots&quot;)</span>
<span class="nc" id="L86">                    .defaultValue(false)</span>
<span class="nc" id="L87">                    .withDescription(</span>
<span class="nc" id="L88">                            Description.builder()</span>
<span class="nc" id="L89">                                    .text(</span>
                                            &quot;Enable the slot spread out allocation strategy. This strategy tries to spread out &quot;
                                                    + &quot;the slots evenly across all available %s.&quot;,
<span class="nc" id="L92">                                            code(&quot;TaskExecutors&quot;))</span>
<span class="nc" id="L93">                                    .build());</span>

    @Documentation.Section(Documentation.Sections.EXPERT_CLUSTER)
<span class="nc" id="L96">    public static final ConfigOption&lt;Boolean&gt; HALT_ON_FATAL_ERROR =</span>
<span class="nc" id="L97">            key(&quot;cluster.processes.halt-on-fatal-error&quot;)</span>
<span class="nc" id="L98">                    .booleanType()</span>
<span class="nc" id="L99">                    .defaultValue(false)</span>
<span class="nc" id="L100">                    .withDescription(</span>
<span class="nc" id="L101">                            Description.builder()</span>
<span class="nc" id="L102">                                    .text(</span>
                                            &quot;Whether processes should halt on fatal errors instead of performing a graceful shutdown. &quot;
                                                    + &quot;In some environments (e.g. Java 8 with the G1 garbage collector), a regular graceful shutdown can lead &quot;
                                                    + &quot;to a JVM deadlock. See %s for details.&quot;,
<span class="nc" id="L106">                                            link(</span>
                                                    &quot;https://issues.apache.org/jira/browse/FLINK-16510&quot;,
                                                    &quot;FLINK-16510&quot;))
<span class="nc" id="L109">                                    .build());</span>

    @Documentation.Section(Documentation.Sections.EXPERT_CLUSTER)
<span class="nc" id="L112">    public static final ConfigOption&lt;UserSystemExitMode&gt; INTERCEPT_USER_SYSTEM_EXIT =</span>
<span class="nc" id="L113">            key(&quot;cluster.intercept-user-system-exit&quot;)</span>
<span class="nc" id="L114">                    .enumType(UserSystemExitMode.class)</span>
<span class="nc" id="L115">                    .defaultValue(UserSystemExitMode.DISABLED)</span>
<span class="nc" id="L116">                    .withDescription(UserSystemExitMode.getConfigDescription());</span>

    @Documentation.ExcludeFromDocumentation
<span class="nc" id="L119">    public static final ConfigOption&lt;Boolean&gt; ENABLE_DECLARATIVE_RESOURCE_MANAGEMENT =</span>
<span class="nc" id="L120">            ConfigOptions.key(&quot;cluster.declarative-resource-management.enabled&quot;)</span>
<span class="nc" id="L121">                    .booleanType()</span>
<span class="nc" id="L122">                    .defaultValue(true)</span>
<span class="nc" id="L123">                    .withDescription(</span>
                            &quot;Defines whether the cluster uses declarative resource management.&quot;);

    @Documentation.ExcludeFromDocumentation
<span class="nc" id="L127">    public static final ConfigOption&lt;Boolean&gt; ENABLE_FINE_GRAINED_RESOURCE_MANAGEMENT =</span>
<span class="nc" id="L128">            ConfigOptions.key(&quot;cluster.fine-grained-resource-management.enabled&quot;)</span>
<span class="nc" id="L129">                    .booleanType()</span>
<span class="nc" id="L130">                    .defaultValue(false)</span>
<span class="nc" id="L131">                    .withDescription(</span>
                            &quot;Defines whether the cluster uses fine-grained resource management.&quot;);

    public static boolean isDeclarativeResourceManagementEnabled(Configuration configuration) {
<span class="nc bnc" id="L135" title="All 2 branches missed.">        if (configuration.contains(ENABLE_DECLARATIVE_RESOURCE_MANAGEMENT)) {</span>
<span class="nc" id="L136">            return configuration.get(ENABLE_DECLARATIVE_RESOURCE_MANAGEMENT);</span>
        } else {
<span class="nc bnc" id="L138" title="All 2 branches missed.">            return !System.getProperties().containsKey(&quot;flink.tests.disable-declarative&quot;);</span>
        }
    }

    public static JobManagerOptions.SchedulerType getSchedulerType(Configuration configuration) {
<span class="nc bnc" id="L143" title="All 4 branches missed.">        if (isAdaptiveSchedulerEnabled(configuration) || isReactiveModeEnabled(configuration)) {</span>
<span class="nc" id="L144">            return JobManagerOptions.SchedulerType.Adaptive;</span>
        } else {
<span class="nc" id="L146">            return configuration.get(JobManagerOptions.SCHEDULER);</span>
        }
    }

    private static boolean isReactiveModeEnabled(Configuration configuration) {
<span class="nc bnc" id="L151" title="All 2 branches missed.">        return configuration.get(JobManagerOptions.SCHEDULER_MODE)</span>
                == SchedulerExecutionMode.REACTIVE;
    }

    public static boolean isAdaptiveSchedulerEnabled(Configuration configuration) {
<span class="nc bnc" id="L156" title="All 2 branches missed.">        if (configuration.contains(JobManagerOptions.SCHEDULER)) {</span>
<span class="nc bnc" id="L157" title="All 2 branches missed.">            return configuration.get(JobManagerOptions.SCHEDULER)</span>
                    == JobManagerOptions.SchedulerType.Adaptive;
        } else {
<span class="nc" id="L160">            return System.getProperties().containsKey(&quot;flink.tests.enable-adaptive-scheduler&quot;);</span>
        }
    }

    public static boolean isFineGrainedResourceManagementEnabled(Configuration configuration) {
        // TODO We need to bind fine-grained with declarative because in the first step we implement
        // the feature base on the declarative protocol. We would be able to support both protocols
        // and no longer need this binding after FLINK-20838.
<span class="nc bnc" id="L168" title="All 2 branches missed.">        if (!isDeclarativeResourceManagementEnabled(configuration)) {</span>
<span class="nc" id="L169">            return false;</span>
        }

<span class="nc bnc" id="L172" title="All 2 branches missed.">        if (configuration.contains(ENABLE_FINE_GRAINED_RESOURCE_MANAGEMENT)) {</span>
<span class="nc" id="L173">            return configuration.get(ENABLE_FINE_GRAINED_RESOURCE_MANAGEMENT);</span>
        } else {
<span class="nc" id="L175">            return System.getProperties().containsKey(&quot;flink.tests.enable-fine-grained&quot;);</span>
        }
    }

    /** The mode of how to handle user code attempting to exit JVM. */
<span class="nc" id="L180">    public enum UserSystemExitMode {</span>
<span class="nc" id="L181">        DISABLED(&quot;Flink is not monitoring or intercepting calls to System.exit()&quot;),</span>
<span class="nc" id="L182">        LOG(&quot;Log exit attempt with stack trace but still allowing exit to be performed&quot;),</span>
<span class="nc" id="L183">        THROW(&quot;Throw exception when exit is attempted disallowing JVM termination&quot;);</span>

        private final String description;

<span class="nc" id="L187">        UserSystemExitMode(String description) {</span>
<span class="nc" id="L188">            this.description = description;</span>
<span class="nc" id="L189">        }</span>

        public static Description getConfigDescription() {
<span class="nc" id="L192">            Description.DescriptionBuilder builder = Description.builder();</span>
<span class="nc" id="L193">            List&lt;TextElement&gt; modeDescriptions =</span>
<span class="nc" id="L194">                    new ArrayList&lt;&gt;(UserSystemExitMode.values().length);</span>
<span class="nc" id="L195">            builder.text(</span>
                    &quot;Flag to check user code exiting system by terminating JVM (e.g., System.exit())&quot;);
<span class="nc bnc" id="L197" title="All 2 branches missed.">            for (UserSystemExitMode mode : UserSystemExitMode.values()) {</span>
<span class="nc" id="L198">                modeDescriptions.add(</span>
<span class="nc" id="L199">                        text(String.format(&quot;%s - %s&quot;, mode.name(), mode.getDescription())));</span>
            }
<span class="nc" id="L201">            builder.list(modeDescriptions.toArray(new TextElement[modeDescriptions.size()]));</span>
<span class="nc" id="L202">            builder.linebreak();</span>
<span class="nc" id="L203">            builder.text(</span>
                    &quot;Note that this configuration option can interfere with %s: &quot;
                            + &quot;In intercepted user-code, a call to System.exit() will not cause the JVM to halt, when %s is configured.&quot;,
<span class="nc" id="L206">                    code(HALT_ON_FATAL_ERROR.key()), code(THROW.name()));</span>
<span class="nc" id="L207">            return builder.build();</span>
        }

        public String getDescription() {
<span class="nc" id="L211">            return description;</span>
        }
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.7.202105040129</span></div></body></html>