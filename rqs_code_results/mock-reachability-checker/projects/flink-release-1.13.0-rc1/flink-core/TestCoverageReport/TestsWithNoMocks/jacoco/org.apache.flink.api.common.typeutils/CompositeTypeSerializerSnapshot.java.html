<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>CompositeTypeSerializerSnapshot.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Flink : Core</a> &gt; <a href="index.source.html" class="el_package">org.apache.flink.api.common.typeutils</a> &gt; <span class="el_source">CompositeTypeSerializerSnapshot.java</span></div><h1>CompositeTypeSerializerSnapshot.java</h1><pre class="source lang-java linenums">/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * &quot;License&quot;); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.apache.flink.api.common.typeutils;

import org.apache.flink.annotation.Internal;
import org.apache.flink.annotation.PublicEvolving;
import org.apache.flink.api.common.typeutils.base.GenericArraySerializer;
import org.apache.flink.api.common.typeutils.base.ListSerializer;
import org.apache.flink.api.common.typeutils.base.MapSerializer;
import org.apache.flink.api.java.typeutils.runtime.EitherSerializer;
import org.apache.flink.core.memory.DataInputView;
import org.apache.flink.core.memory.DataOutputView;

import java.io.IOException;

import static org.apache.flink.api.common.typeutils.CompositeTypeSerializerUtil.IntermediateCompatibilityResult;
import static org.apache.flink.util.Preconditions.checkNotNull;

/**
 * A {@link CompositeTypeSerializerSnapshot} is a convenient serializer snapshot class that can be
 * used by simple serializers which 1) delegates its serialization to multiple nested serializers,
 * and 2) may contain some extra static information that needs to be persisted as part of its
 * snapshot.
 *
 * &lt;p&gt;Examples for this would be the {@link ListSerializer}, {@link MapSerializer}, {@link
 * EitherSerializer}, etc., in which case the serializer, called the &quot;outer&quot; serializer in this
 * context, has only some nested serializers that needs to be persisted as its snapshot, and nothing
 * else that needs to be persisted as the &quot;outer&quot; snapshot. An example which has non-empty outer
 * snapshots would be the {@link GenericArraySerializer}, which beyond the nested component
 * serializer, also contains a class of the component type that needs to be persisted.
 *
 * &lt;p&gt;Serializers that do have some outer snapshot needs to make sure to implement the methods
 * {@link #writeOuterSnapshot(DataOutputView)}, {@link #readOuterSnapshot(int, DataInputView,
 * ClassLoader)}, and {@link #resolveOuterSchemaCompatibility(TypeSerializer)} (TypeSerializer)}
 * when using this class as the base for its serializer snapshot class. By default, the base
 * implementations of these methods are empty, i.e. this class assumes that subclasses do not have
 * any outer snapshot that needs to be persisted.
 *
 * &lt;h2&gt;Snapshot Versioning&lt;/h2&gt;
 *
 * &lt;p&gt;This base class has its own versioning for the format in which it writes the outer snapshot
 * and the nested serializer snapshots. The version of the serialization format of this based class
 * is defined by {@link #getCurrentVersion()}. This is independent of the version in which
 * subclasses writes their outer snapshot, defined by {@link #getCurrentOuterSnapshotVersion()}.
 * This means that the outer snapshot's version can be maintained only taking into account changes
 * in how the outer snapshot is written. Any changes in the base format does not require upticks in
 * the outer snapshot's version.
 *
 * &lt;h2&gt;Serialization Format&lt;/h2&gt;
 *
 * &lt;p&gt;The current version of the serialization format of a {@link CompositeTypeSerializerSnapshot}
 * is as follows:
 *
 * &lt;pre&gt;{@code
 * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 * | CompositeTypeSerializerSnapshot | CompositeTypeSerializerSnapshot |          Outer snapshot         |
 * |           version               |          MAGIC_NUMBER           |              version            |
 * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 * |                                               Outer snapshot                                        |
 * |                                   #writeOuterSnapshot(DataOutputView out)                           |
 * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 * |      Delegate MAGIC_NUMBER      |         Delegate version        |     Num. nested serializers     |
 * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 * |                                     Nested serializer snapshots                                     |
 * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 * }&lt;/pre&gt;
 *
 * @param &lt;T&gt; The data type that the originating serializer of this snapshot serializes.
 * @param &lt;S&gt; The type of the originating serializer.
 */
@PublicEvolving
public abstract class CompositeTypeSerializerSnapshot&lt;T, S extends TypeSerializer&lt;T&gt;&gt;
        implements TypeSerializerSnapshot&lt;T&gt; {

    /**
     * Indicates schema compatibility of the serializer configuration persisted as the outer
     * snapshot.
     */
<span class="fc" id="L95">    protected enum OuterSchemaCompatibility {</span>
<span class="fc" id="L96">        COMPATIBLE_AS_IS,</span>
<span class="fc" id="L97">        COMPATIBLE_AFTER_MIGRATION,</span>
<span class="fc" id="L98">        INCOMPATIBLE</span>
    }

    /** Magic number for integrity checks during deserialization. */
    private static final int MAGIC_NUMBER = 911108;

    /**
     * Current version of the base serialization format.
     *
     * &lt;p&gt;NOTE: We start from version 3. This version is represented by the {@link
     * #getCurrentVersion()} method. Previously, this method was used to represent the outer
     * snapshot's version (now, represented by the {@link #getCurrentOuterSnapshotVersion()}
     * method).
     *
     * &lt;p&gt;To bridge this transition, we set the starting version of the base format to be at least
     * larger than the highest version of previously defined values in implementing subclasses,
     * which was {@link #HIGHEST_LEGACY_READ_VERSION}. This allows us to identify legacy
     * deserialization paths, which did not contain versioning for the base format, simply by
     * checking if the read version of the snapshot is smaller than or equal to {@link
     * #HIGHEST_LEGACY_READ_VERSION}.
     */
    private static final int VERSION = 3;

    private static final int HIGHEST_LEGACY_READ_VERSION = 2;

    private NestedSerializersSnapshotDelegate nestedSerializersSnapshotDelegate;

    private final Class&lt;S&gt; correspondingSerializerClass;

    /**
     * Constructor to be used for read instantiation.
     *
     * @param correspondingSerializerClass the expected class of the new serializer.
     */
    @SuppressWarnings(&quot;unchecked&quot;)
    public CompositeTypeSerializerSnapshot(
<span class="fc" id="L134">            Class&lt;? extends TypeSerializer&gt; correspondingSerializerClass) {</span>
<span class="fc" id="L135">        this.correspondingSerializerClass = (Class&lt;S&gt;) checkNotNull(correspondingSerializerClass);</span>
<span class="fc" id="L136">    }</span>

    /**
     * Constructor to be used for writing the snapshot.
     *
     * @param serializerInstance an instance of the originating serializer of this snapshot.
     */
    @SuppressWarnings(&quot;unchecked&quot;)
<span class="fc" id="L144">    public CompositeTypeSerializerSnapshot(S serializerInstance) {</span>
<span class="fc" id="L145">        checkNotNull(serializerInstance);</span>
<span class="fc" id="L146">        this.nestedSerializersSnapshotDelegate =</span>
<span class="fc" id="L147">                new NestedSerializersSnapshotDelegate(getNestedSerializers(serializerInstance));</span>
<span class="fc" id="L148">        this.correspondingSerializerClass = (Class&lt;S&gt;) serializerInstance.getClass();</span>
<span class="fc" id="L149">    }</span>

    @Override
    public final int getCurrentVersion() {
<span class="fc" id="L153">        return VERSION;</span>
    }

    @Override
    public final void writeSnapshot(DataOutputView out) throws IOException {
<span class="fc" id="L158">        internalWriteOuterSnapshot(out);</span>
<span class="fc" id="L159">        nestedSerializersSnapshotDelegate.writeNestedSerializerSnapshots(out);</span>
<span class="fc" id="L160">    }</span>

    @Override
    public final void readSnapshot(
            int readVersion, DataInputView in, ClassLoader userCodeClassLoader) throws IOException {
<span class="pc bpc" id="L165" title="1 of 2 branches missed.">        if (readVersion &gt; HIGHEST_LEGACY_READ_VERSION) {</span>
<span class="fc" id="L166">            internalReadOuterSnapshot(in, userCodeClassLoader);</span>
        } else {
<span class="nc" id="L168">            legacyInternalReadOuterSnapshot(readVersion, in, userCodeClassLoader);</span>
        }
<span class="fc" id="L170">        this.nestedSerializersSnapshotDelegate =</span>
<span class="fc" id="L171">                NestedSerializersSnapshotDelegate.readNestedSerializerSnapshots(</span>
                        in, userCodeClassLoader);
<span class="fc" id="L173">    }</span>

    public TypeSerializerSnapshot&lt;?&gt;[] getNestedSerializerSnapshots() {
<span class="nc" id="L176">        return nestedSerializersSnapshotDelegate.getNestedSerializerSnapshots();</span>
    }

    @Override
    public final TypeSerializerSchemaCompatibility&lt;T&gt; resolveSchemaCompatibility(
            TypeSerializer&lt;T&gt; newSerializer) {
<span class="fc" id="L182">        return internalResolveSchemaCompatibility(</span>
<span class="fc" id="L183">                newSerializer, nestedSerializersSnapshotDelegate.getNestedSerializerSnapshots());</span>
    }

    @Internal
    TypeSerializerSchemaCompatibility&lt;T&gt; internalResolveSchemaCompatibility(
            TypeSerializer&lt;T&gt; newSerializer, TypeSerializerSnapshot&lt;?&gt;[] snapshots) {
<span class="pc bpc" id="L189" title="1 of 2 branches missed.">        if (newSerializer.getClass() != correspondingSerializerClass) {</span>
<span class="nc" id="L190">            return TypeSerializerSchemaCompatibility.incompatible();</span>
        }

<span class="fc" id="L193">        S castedNewSerializer = correspondingSerializerClass.cast(newSerializer);</span>

<span class="fc" id="L195">        final OuterSchemaCompatibility outerSchemaCompatibility =</span>
<span class="fc" id="L196">                resolveOuterSchemaCompatibility(castedNewSerializer);</span>

<span class="fc" id="L198">        final TypeSerializer&lt;?&gt;[] newNestedSerializers = getNestedSerializers(castedNewSerializer);</span>
        // check that nested serializer arity remains identical; if not, short circuit result
<span class="fc bfc" id="L200" title="All 2 branches covered.">        if (newNestedSerializers.length != snapshots.length) {</span>
<span class="fc" id="L201">            return TypeSerializerSchemaCompatibility.incompatible();</span>
        }

<span class="fc" id="L204">        return constructFinalSchemaCompatibilityResult(</span>
                newNestedSerializers, snapshots, outerSchemaCompatibility);
    }

    @Internal
    void setNestedSerializersSnapshotDelegate(NestedSerializersSnapshotDelegate delegate) {
<span class="nc" id="L210">        this.nestedSerializersSnapshotDelegate = checkNotNull(delegate);</span>
<span class="nc" id="L211">    }</span>

    @Override
    public final TypeSerializer&lt;T&gt; restoreSerializer() {
        @SuppressWarnings(&quot;unchecked&quot;)
<span class="fc" id="L216">        TypeSerializer&lt;T&gt; serializer =</span>
                (TypeSerializer&lt;T&gt;)
<span class="fc" id="L218">                        createOuterSerializerWithNestedSerializers(</span>
<span class="fc" id="L219">                                nestedSerializersSnapshotDelegate.getRestoredNestedSerializers());</span>

<span class="fc" id="L221">        return serializer;</span>
    }

    // ------------------------------------------------------------------------------------------
    //  Outer serializer access methods
    // ------------------------------------------------------------------------------------------

    /**
     * Returns the version of the current outer snapshot's written binary format.
     *
     * @return the version of the current outer snapshot's written binary format.
     */
    protected abstract int getCurrentOuterSnapshotVersion();

    /**
     * Gets the nested serializers from the outer serializer.
     *
     * @param outerSerializer the outer serializer.
     * @return the nested serializers.
     */
    protected abstract TypeSerializer&lt;?&gt;[] getNestedSerializers(S outerSerializer);

    /**
     * Creates an instance of the outer serializer with a given array of its nested serializers.
     *
     * @param nestedSerializers array of nested serializers to create the outer serializer with.
     * @return an instance of the outer serializer.
     */
    protected abstract S createOuterSerializerWithNestedSerializers(
            TypeSerializer&lt;?&gt;[] nestedSerializers);

    // ------------------------------------------------------------------------------------------
    //  Outer snapshot methods; need to be overridden if outer snapshot is not empty,
    //  or in other words, the outer serializer has extra configuration beyond its nested
    // serializers.
    // ------------------------------------------------------------------------------------------

    /**
     * Writes the outer snapshot, i.e. any information beyond the nested serializers of the outer
     * serializer.
     *
     * &lt;p&gt;The base implementation of this methods writes nothing, i.e. it assumes that the outer
     * serializer only has nested serializers and no extra information. Otherwise, if the outer
     * serializer contains some extra information that needs to be persisted as part of the
     * serializer snapshot, this must be overridden. Note that this method and the corresponding
     * methods {@link #readOuterSnapshot(int, DataInputView, ClassLoader)}, {@link
     * #resolveOuterSchemaCompatibility(TypeSerializer)} needs to be implemented.
     *
     * @param out the {@link DataOutputView} to write the outer snapshot to.
     */
<span class="fc" id="L271">    protected void writeOuterSnapshot(DataOutputView out) throws IOException {}</span>

    /**
     * Reads the outer snapshot, i.e. any information beyond the nested serializers of the outer
     * serializer.
     *
     * &lt;p&gt;The base implementation of this methods reads nothing, i.e. it assumes that the outer
     * serializer only has nested serializers and no extra information. Otherwise, if the outer
     * serializer contains some extra information that has been persisted as part of the serializer
     * snapshot, this must be overridden. Note that this method and the corresponding methods {@link
     * #writeOuterSnapshot(DataOutputView)}, {@link
     * #resolveOuterSchemaCompatibility(TypeSerializer)} needs to be implemented.
     *
     * @param readOuterSnapshotVersion the read version of the outer snapshot.
     * @param in the {@link DataInputView} to read the outer snapshot from.
     * @param userCodeClassLoader the user code class loader.
     */
    protected void readOuterSnapshot(
            int readOuterSnapshotVersion, DataInputView in, ClassLoader userCodeClassLoader)
<span class="fc" id="L290">            throws IOException {}</span>

    /**
     * Checks whether the outer snapshot is compatible with a given new serializer.
     *
     * &lt;p&gt;The base implementation of this method just returns {@code true}, i.e. it assumes that the
     * outer serializer only has nested serializers and no extra information, and therefore the
     * result of the check must always be true. Otherwise, if the outer serializer contains some
     * extra information that has been persisted as part of the serializer snapshot, this must be
     * overridden. Note that this method and the corresponding methods {@link
     * #writeOuterSnapshot(DataOutputView)}, {@link #readOuterSnapshot(int, DataInputView,
     * ClassLoader)} needs to be implemented.
     *
     * @param newSerializer the new serializer, which contains the new outer information to check
     *     against.
     * @return a flag indicating whether or not the new serializer's outer information is compatible
     *     with the one written in this snapshot.
     * @deprecated this method is deprecated, and will be removed in the future. Please implement
     *     {@link #resolveOuterSchemaCompatibility(TypeSerializer)} instead.
     */
    @Deprecated
    protected boolean isOuterSnapshotCompatible(S newSerializer) {
<span class="fc" id="L312">        return true;</span>
    }

    /**
     * Checks the schema compatibility of the given new serializer based on the outer snapshot.
     *
     * &lt;p&gt;The base implementation of this method assumes that the outer serializer only has nested
     * serializers and no extra information, and therefore the result of the check is {@link
     * OuterSchemaCompatibility#COMPATIBLE_AS_IS}. Otherwise, if the outer serializer contains some
     * extra information that has been persisted as part of the serializer snapshot, this must be
     * overridden. Note that this method and the corresponding methods {@link
     * #writeOuterSnapshot(DataOutputView)}, {@link #readOuterSnapshot(int, DataInputView,
     * ClassLoader)} needs to be implemented.
     *
     * @param newSerializer the new serializer, which contains the new outer information to check
     *     against.
     * @return a {@link OuterSchemaCompatibility} indicating whether or the new serializer's outer
     *     information is compatible, requires migration, or incompatible with the one written in
     *     this snapshot.
     */
    protected OuterSchemaCompatibility resolveOuterSchemaCompatibility(S newSerializer) {
<span class="pc bpc" id="L333" title="1 of 2 branches missed.">        return (isOuterSnapshotCompatible(newSerializer))</span>
                ? OuterSchemaCompatibility.COMPATIBLE_AS_IS
                : OuterSchemaCompatibility.INCOMPATIBLE;
    }

    // ------------------------------------------------------------------------------------------
    //  Utilities
    // ------------------------------------------------------------------------------------------

    private void internalWriteOuterSnapshot(DataOutputView out) throws IOException {
<span class="fc" id="L343">        out.writeInt(MAGIC_NUMBER);</span>
<span class="fc" id="L344">        out.writeInt(getCurrentOuterSnapshotVersion());</span>

<span class="fc" id="L346">        writeOuterSnapshot(out);</span>
<span class="fc" id="L347">    }</span>

    private void internalReadOuterSnapshot(DataInputView in, ClassLoader userCodeClassLoader)
            throws IOException {
<span class="fc" id="L351">        final int magicNumber = in.readInt();</span>
<span class="pc bpc" id="L352" title="1 of 2 branches missed.">        if (magicNumber != MAGIC_NUMBER) {</span>
<span class="nc" id="L353">            throw new IOException(</span>
<span class="nc" id="L354">                    String.format(</span>
                            &quot;Corrupt data, magic number mismatch. Expected %8x, found %8x&quot;,
<span class="nc" id="L356">                            MAGIC_NUMBER, magicNumber));</span>
        }

<span class="fc" id="L359">        final int outerSnapshotVersion = in.readInt();</span>
<span class="fc" id="L360">        readOuterSnapshot(outerSnapshotVersion, in, userCodeClassLoader);</span>
<span class="fc" id="L361">    }</span>

    private void legacyInternalReadOuterSnapshot(
            int legacyReadVersion, DataInputView in, ClassLoader userCodeClassLoader)
            throws IOException {

        // legacy versions did not contain the pre-fixed magic numbers; just read the outer snapshot
<span class="nc" id="L368">        readOuterSnapshot(legacyReadVersion, in, userCodeClassLoader);</span>
<span class="nc" id="L369">    }</span>

    private TypeSerializerSchemaCompatibility&lt;T&gt; constructFinalSchemaCompatibilityResult(
            TypeSerializer&lt;?&gt;[] newNestedSerializers,
            TypeSerializerSnapshot&lt;?&gt;[] nestedSerializerSnapshots,
            OuterSchemaCompatibility outerSchemaCompatibility) {

<span class="fc" id="L376">        IntermediateCompatibilityResult&lt;T&gt; nestedSerializersCompatibilityResult =</span>
<span class="fc" id="L377">                CompositeTypeSerializerUtil.constructIntermediateCompatibilityResult(</span>
                        newNestedSerializers, nestedSerializerSnapshots);

<span class="fc bfc" id="L380" title="All 2 branches covered.">        if (outerSchemaCompatibility == OuterSchemaCompatibility.INCOMPATIBLE</span>
<span class="fc bfc" id="L381" title="All 2 branches covered.">                || nestedSerializersCompatibilityResult.isIncompatible()) {</span>
<span class="fc" id="L382">            return TypeSerializerSchemaCompatibility.incompatible();</span>
        }

<span class="fc bfc" id="L385" title="All 2 branches covered.">        if (outerSchemaCompatibility == OuterSchemaCompatibility.COMPATIBLE_AFTER_MIGRATION</span>
<span class="fc bfc" id="L386" title="All 2 branches covered.">                || nestedSerializersCompatibilityResult.isCompatibleAfterMigration()) {</span>
<span class="fc" id="L387">            return TypeSerializerSchemaCompatibility.compatibleAfterMigration();</span>
        }

<span class="fc bfc" id="L390" title="All 2 branches covered.">        if (nestedSerializersCompatibilityResult.isCompatibleWithReconfiguredSerializer()) {</span>
            @SuppressWarnings(&quot;unchecked&quot;)
<span class="fc" id="L392">            TypeSerializer&lt;T&gt; reconfiguredCompositeSerializer =</span>
<span class="fc" id="L393">                    createOuterSerializerWithNestedSerializers(</span>
<span class="fc" id="L394">                            nestedSerializersCompatibilityResult.getNestedSerializers());</span>
<span class="fc" id="L395">            return TypeSerializerSchemaCompatibility.compatibleWithReconfiguredSerializer(</span>
                    reconfiguredCompositeSerializer);
        }

<span class="fc" id="L399">        return TypeSerializerSchemaCompatibility.compatibleAsIs();</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.7.202105040129</span></div></body></html>