<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>ExceptionUtils.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Flink : Core</a> &gt; <a href="index.source.html" class="el_package">org.apache.flink.util</a> &gt; <span class="el_source">ExceptionUtils.java</span></div><h1>ExceptionUtils.java</h1><pre class="source lang-java linenums">/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * &quot;License&quot;); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

//
// The function &quot;stringifyException&quot; is based on source code from the Hadoop Project
// (http://hadoop.apache.org/),
// licensed by the Apache Software Foundation (ASF) under the Apache License, Version 2.0.
// See the NOTICE file distributed with this work for additional information regarding copyright
// ownership.
//

package org.apache.flink.util;

import org.apache.flink.annotation.Internal;
import org.apache.flink.util.function.RunnableWithException;

import javax.annotation.Nullable;

import java.io.IOException;
import java.io.PrintWriter;
import java.io.StringWriter;
import java.lang.reflect.Field;
import java.util.Optional;
import java.util.concurrent.CompletionException;
import java.util.concurrent.ExecutionException;
import java.util.function.Function;
import java.util.function.Predicate;

import static org.apache.flink.util.Preconditions.checkNotNull;

/** A collection of utility functions for dealing with exceptions and exception workflows. */
@Internal
public final class ExceptionUtils {

    /** The stringified representation of a null exception reference. */
    public static final String STRINGIFIED_NULL_EXCEPTION = &quot;(null)&quot;;

    /**
     * Makes a string representation of the exception's stack trace, or &quot;(null)&quot;, if the exception
     * is null.
     *
     * &lt;p&gt;This method makes a best effort and never fails.
     *
     * @param e The exception to stringify.
     * @return A string with exception name and call stack.
     */
    public static String stringifyException(final Throwable e) {
<span class="pc bpc" id="L63" title="1 of 2 branches missed.">        if (e == null) {</span>
<span class="fc" id="L64">            return STRINGIFIED_NULL_EXCEPTION;</span>
        }

        try {
<span class="nc" id="L68">            StringWriter stm = new StringWriter();</span>
<span class="nc" id="L69">            PrintWriter wrt = new PrintWriter(stm);</span>
<span class="nc" id="L70">            e.printStackTrace(wrt);</span>
<span class="nc" id="L71">            wrt.close();</span>
<span class="nc" id="L72">            return stm.toString();</span>
<span class="nc" id="L73">        } catch (Throwable t) {</span>
<span class="nc" id="L74">            return e.getClass().getName() + &quot; (error while printing stack trace)&quot;;</span>
        }
    }

    /**
     * Checks whether the given exception indicates a situation that may leave the JVM in a
     * corrupted state, meaning a state where continued normal operation can only be guaranteed via
     * clean process restart.
     *
     * &lt;p&gt;Currently considered fatal exceptions are Virtual Machine errors indicating that the JVM
     * is corrupted, like {@link InternalError}, {@link UnknownError}, and {@link
     * java.util.zip.ZipError} (a special case of InternalError). The {@link ThreadDeath} exception
     * is also treated as a fatal error, because when a thread is forcefully stopped, there is a
     * high chance that parts of the system are in an inconsistent state.
     *
     * @param t The exception to check.
     * @return True, if the exception is considered fatal to the JVM, false otherwise.
     */
    public static boolean isJvmFatalError(Throwable t) {
<span class="pc bpc" id="L93" title="1 of 6 branches missed.">        return (t instanceof InternalError)</span>
                || (t instanceof UnknownError)
                || (t instanceof ThreadDeath);
    }

    /**
     * Checks whether the given exception indicates a situation that may leave the JVM in a
     * corrupted state, or an out-of-memory error.
     *
     * &lt;p&gt;See {@link ExceptionUtils#isJvmFatalError(Throwable)} for a list of fatal JVM errors. This
     * method additionally classifies the {@link OutOfMemoryError} as fatal, because it may occur in
     * any thread (not the one that allocated the majority of the memory) and thus is often not
     * recoverable by destroying the particular thread that threw the exception.
     *
     * @param t The exception to check.
     * @return True, if the exception is fatal to the JVM or and OutOfMemoryError, false otherwise.
     */
    public static boolean isJvmFatalOrOutOfMemoryError(Throwable t) {
<span class="nc bnc" id="L111" title="All 4 branches missed.">        return isJvmFatalError(t) || t instanceof OutOfMemoryError;</span>
    }

    /**
     * Tries to enrich OutOfMemoryErrors being part of the passed root Throwable's cause tree.
     *
     * &lt;p&gt;This method improves error messages for direct and metaspace {@link OutOfMemoryError}. It
     * adds description about the possible causes and ways of resolution.
     *
     * @param root The Throwable of which the cause tree shall be traversed.
     * @param jvmMetaspaceOomNewErrorMessage The message being used for JVM metaspace-related
     *     OutOfMemoryErrors. Passing &lt;code&gt;null&lt;/code&gt; will disable handling this class of error.
     * @param jvmDirectOomNewErrorMessage The message being used for direct memory-related
     *     OutOfMemoryErrors. Passing &lt;code&gt;null&lt;/code&gt; will disable handling this class of error.
     * @param jvmHeapSpaceOomNewErrorMessage The message being used for Heap space-related
     *     OutOfMemoryErrors. Passing &lt;code&gt;null&lt;/code&gt; will disable handling this class of error.
     */
    public static void tryEnrichOutOfMemoryError(
            @Nullable Throwable root,
            @Nullable String jvmMetaspaceOomNewErrorMessage,
            @Nullable String jvmDirectOomNewErrorMessage,
            @Nullable String jvmHeapSpaceOomNewErrorMessage) {
<span class="fc" id="L133">        updateDetailMessage(</span>
                root,
                t -&gt; {
<span class="nc bnc" id="L136" title="All 2 branches missed.">                    if (isMetaspaceOutOfMemoryError(t)) {</span>
<span class="nc" id="L137">                        return jvmMetaspaceOomNewErrorMessage;</span>
<span class="nc bnc" id="L138" title="All 2 branches missed.">                    } else if (isDirectOutOfMemoryError(t)) {</span>
<span class="nc" id="L139">                        return jvmDirectOomNewErrorMessage;</span>
<span class="nc bnc" id="L140" title="All 2 branches missed.">                    } else if (isHeapSpaceOutOfMemoryError(t)) {</span>
<span class="nc" id="L141">                        return jvmHeapSpaceOomNewErrorMessage;</span>
                    }

<span class="nc" id="L144">                    return null;</span>
                });
<span class="fc" id="L146">    }</span>

    /**
     * Updates error messages of Throwables appearing in the cause tree of the passed root
     * Throwable. The passed Function is applied on each Throwable of the cause tree. Returning a
     * String will cause the detailMessage of the corresponding Throwable to be updated. Returning
     * &lt;code&gt;null&lt;/code&gt;, instead, won't trigger any detailMessage update on that Throwable.
     *
     * @param root The Throwable whose cause tree shall be traversed.
     * @param throwableToMessage The Function based on which the new messages are generated. The
     *     function implementation should return the new message. Returning &lt;code&gt;null&lt;/code&gt;, in
     *     contrast, will result in not updating the message for the corresponding Throwable.
     */
    public static void updateDetailMessage(
            @Nullable Throwable root, @Nullable Function&lt;Throwable, String&gt; throwableToMessage) {
<span class="fc bfc" id="L161" title="All 2 branches covered.">        if (throwableToMessage == null) {</span>
<span class="fc" id="L162">            return;</span>
        }

<span class="fc" id="L165">        Throwable it = root;</span>
<span class="fc bfc" id="L166" title="All 2 branches covered.">        while (it != null) {</span>
<span class="fc" id="L167">            String newMessage = throwableToMessage.apply(it);</span>
<span class="fc bfc" id="L168" title="All 2 branches covered.">            if (newMessage != null) {</span>
<span class="fc" id="L169">                updateDetailMessageOfThrowable(it, newMessage);</span>
            }

<span class="fc" id="L172">            it = it.getCause();</span>
<span class="fc" id="L173">        }</span>
<span class="fc" id="L174">    }</span>

    private static void updateDetailMessageOfThrowable(
            Throwable throwable, String newDetailMessage) {
        Field field;
        try {
<span class="fc" id="L180">            field = Throwable.class.getDeclaredField(&quot;detailMessage&quot;);</span>
<span class="nc" id="L181">        } catch (NoSuchFieldException e) {</span>
<span class="nc" id="L182">            throw new IllegalStateException(</span>
                    &quot;The JDK Throwable contains a detailMessage member. The Throwable class provided on the classpath does not which is why this exception appears.&quot;,
                    e);
<span class="fc" id="L185">        }</span>

<span class="fc" id="L187">        field.setAccessible(true);</span>
        try {
<span class="fc" id="L189">            field.set(throwable, newDetailMessage);</span>
<span class="nc" id="L190">        } catch (IllegalAccessException e) {</span>
<span class="nc" id="L191">            throw new IllegalStateException(</span>
                    &quot;The JDK Throwable contains a private detailMessage member that should be accessible through reflection. This is not the case for the Throwable class provided on the classpath.&quot;,
                    e);
<span class="fc" id="L194">        }</span>
<span class="fc" id="L195">    }</span>

    /**
     * Checks whether the given exception indicates a JVM metaspace out-of-memory error.
     *
     * @param t The exception to check.
     * @return True, if the exception is the metaspace {@link OutOfMemoryError}, false otherwise.
     */
    public static boolean isMetaspaceOutOfMemoryError(@Nullable Throwable t) {
<span class="fc" id="L204">        return isOutOfMemoryErrorWithMessageStartingWith(t, &quot;Metaspace&quot;);</span>
    }

    /**
     * Checks whether the given exception indicates a JVM direct out-of-memory error.
     *
     * @param t The exception to check.
     * @return True, if the exception is the direct {@link OutOfMemoryError}, false otherwise.
     */
    public static boolean isDirectOutOfMemoryError(@Nullable Throwable t) {
<span class="fc" id="L214">        return isOutOfMemoryErrorWithMessageStartingWith(t, &quot;Direct buffer memory&quot;);</span>
    }

    public static boolean isHeapSpaceOutOfMemoryError(@Nullable Throwable t) {
<span class="nc" id="L218">        return isOutOfMemoryErrorWithMessageStartingWith(t, &quot;Java heap space&quot;);</span>
    }

    private static boolean isOutOfMemoryErrorWithMessageStartingWith(
            @Nullable Throwable t, String prefix) {
        // the exact matching of the class is checked to avoid matching any custom subclasses of
        // OutOfMemoryError
        // as we are interested in the original exceptions, generated by JVM.
<span class="pc bpc" id="L226" title="5 of 6 branches missed.">        return isOutOfMemoryError(t) &amp;&amp; t.getMessage() != null &amp;&amp; t.getMessage().startsWith(prefix);</span>
    }

    private static boolean isOutOfMemoryError(@Nullable Throwable t) {
<span class="pc bpc" id="L230" title="3 of 4 branches missed.">        return t != null &amp;&amp; t.getClass() == OutOfMemoryError.class;</span>
    }

    /**
     * Rethrows the given {@code Throwable}, if it represents an error that is fatal to the JVM. See
     * {@link ExceptionUtils#isJvmFatalError(Throwable)} for a definition of fatal errors.
     *
     * @param t The Throwable to check and rethrow.
     */
    public static void rethrowIfFatalError(Throwable t) {
<span class="fc bfc" id="L240" title="All 2 branches covered.">        if (isJvmFatalError(t)) {</span>
<span class="fc" id="L241">            throw (Error) t;</span>
        }
<span class="fc" id="L243">    }</span>

    /**
     * Rethrows the given {@code Throwable}, if it represents an error that is fatal to the JVM or
     * an out-of-memory error. See {@link ExceptionUtils#isJvmFatalError(Throwable)} for a
     * definition of fatal errors.
     *
     * @param t The Throwable to check and rethrow.
     */
    public static void rethrowIfFatalErrorOrOOM(Throwable t) {
<span class="nc bnc" id="L253" title="All 4 branches missed.">        if (isJvmFatalError(t) || t instanceof OutOfMemoryError) {</span>
<span class="nc" id="L254">            throw (Error) t;</span>
        }
<span class="nc" id="L256">    }</span>

    /**
     * Adds a new exception as a {@link Throwable#addSuppressed(Throwable) suppressed exception} to
     * a prior exception, or returns the new exception, if no prior exception exists.
     *
     * &lt;pre&gt;{@code
     * public void closeAllThings() throws Exception {
     *     Exception ex = null;
     *     try {
     *         component.shutdown();
     *     } catch (Exception e) {
     *         ex = firstOrSuppressed(e, ex);
     *     }
     *     try {
     *         anotherComponent.stop();
     *     } catch (Exception e) {
     *         ex = firstOrSuppressed(e, ex);
     *     }
     *     try {
     *         lastComponent.shutdown();
     *     } catch (Exception e) {
     *         ex = firstOrSuppressed(e, ex);
     *     }
     *
     *     if (ex != null) {
     *         throw ex;
     *     }
     * }
     * }&lt;/pre&gt;
     *
     * @param newException The newly occurred exception
     * @param previous The previously occurred exception, possibly null.
     * @return The new exception, if no previous exception exists, or the previous exception with
     *     the new exception in the list of suppressed exceptions.
     */
    public static &lt;T extends Throwable&gt; T firstOrSuppressed(T newException, @Nullable T previous) {
<span class="fc" id="L293">        checkNotNull(newException, &quot;newException&quot;);</span>

<span class="pc bpc" id="L295" title="3 of 4 branches missed.">        if (previous == null || previous == newException) {</span>
<span class="fc" id="L296">            return newException;</span>
        } else {
<span class="nc" id="L298">            previous.addSuppressed(newException);</span>
<span class="nc" id="L299">            return previous;</span>
        }
    }

    /**
     * Throws the given {@code Throwable} in scenarios where the signatures do not allow you to
     * throw an arbitrary Throwable. Errors and RuntimeExceptions are thrown directly, other
     * exceptions are packed into runtime exceptions
     *
     * @param t The throwable to be thrown.
     */
    public static void rethrow(Throwable t) {
<span class="pc bpc" id="L311" title="1 of 2 branches missed.">        if (t instanceof Error) {</span>
<span class="nc" id="L312">            throw (Error) t;</span>
<span class="pc bpc" id="L313" title="1 of 2 branches missed.">        } else if (t instanceof RuntimeException) {</span>
<span class="nc" id="L314">            throw (RuntimeException) t;</span>
        } else {
<span class="fc" id="L316">            throw new RuntimeException(t);</span>
        }
    }

    /**
     * Throws the given {@code Throwable} in scenarios where the signatures do not allow you to
     * throw an arbitrary Throwable. Errors and RuntimeExceptions are thrown directly, other
     * exceptions are packed into a parent RuntimeException.
     *
     * @param t The throwable to be thrown.
     * @param parentMessage The message for the parent RuntimeException, if one is needed.
     */
    public static void rethrow(Throwable t, String parentMessage) {
<span class="nc bnc" id="L329" title="All 2 branches missed.">        if (t instanceof Error) {</span>
<span class="nc" id="L330">            throw (Error) t;</span>
<span class="nc bnc" id="L331" title="All 2 branches missed.">        } else if (t instanceof RuntimeException) {</span>
<span class="nc" id="L332">            throw (RuntimeException) t;</span>
        } else {
<span class="nc" id="L334">            throw new RuntimeException(parentMessage, t);</span>
        }
    }

    /**
     * Throws the given {@code Throwable} in scenarios where the signatures do allow to throw a
     * Exception. Errors and Exceptions are thrown directly, other &quot;exotic&quot; subclasses of Throwable
     * are wrapped in an Exception.
     *
     * @param t The throwable to be thrown.
     * @param parentMessage The message for the parent Exception, if one is needed.
     */
    public static void rethrowException(Throwable t, String parentMessage) throws Exception {
<span class="nc bnc" id="L347" title="All 2 branches missed.">        if (t instanceof Error) {</span>
<span class="nc" id="L348">            throw (Error) t;</span>
<span class="nc bnc" id="L349" title="All 2 branches missed.">        } else if (t instanceof Exception) {</span>
<span class="nc" id="L350">            throw (Exception) t;</span>
        } else {
<span class="nc" id="L352">            throw new Exception(parentMessage, t);</span>
        }
    }

    /**
     * Throws the given {@code Throwable} in scenarios where the signatures do allow to throw a
     * Exception. Errors and Exceptions are thrown directly, other &quot;exotic&quot; subclasses of Throwable
     * are wrapped in an Exception.
     *
     * @param t The throwable to be thrown.
     */
    public static void rethrowException(Throwable t) throws Exception {
<span class="nc bnc" id="L364" title="All 2 branches missed.">        if (t instanceof Error) {</span>
<span class="nc" id="L365">            throw (Error) t;</span>
<span class="nc bnc" id="L366" title="All 2 branches missed.">        } else if (t instanceof Exception) {</span>
<span class="nc" id="L367">            throw (Exception) t;</span>
        } else {
<span class="nc" id="L369">            throw new Exception(t.getMessage(), t);</span>
        }
    }

    /**
     * Tries to throw the given exception if not null.
     *
     * @param e exception to throw if not null.
     * @throws Exception
     */
    public static void tryRethrowException(@Nullable Exception e) throws Exception {
<span class="nc bnc" id="L380" title="All 2 branches missed.">        if (e != null) {</span>
<span class="nc" id="L381">            throw e;</span>
        }
<span class="nc" id="L383">    }</span>

    /**
     * Tries to throw the given {@code Throwable} in scenarios where the signatures allows only
     * IOExceptions (and RuntimeException and Error). Throws this exception directly, if it is an
     * IOException, a RuntimeException, or an Error. Otherwise does nothing.
     *
     * @param t The Throwable to be thrown.
     */
    public static void tryRethrowIOException(Throwable t) throws IOException {
<span class="nc bnc" id="L393" title="All 2 branches missed.">        if (t instanceof IOException) {</span>
<span class="nc" id="L394">            throw (IOException) t;</span>
<span class="nc bnc" id="L395" title="All 2 branches missed.">        } else if (t instanceof RuntimeException) {</span>
<span class="nc" id="L396">            throw (RuntimeException) t;</span>
<span class="nc bnc" id="L397" title="All 2 branches missed.">        } else if (t instanceof Error) {</span>
<span class="nc" id="L398">            throw (Error) t;</span>
        }
<span class="nc" id="L400">    }</span>

    /**
     * Re-throws the given {@code Throwable} in scenarios where the signatures allows only
     * IOExceptions (and RuntimeException and Error).
     *
     * &lt;p&gt;Throws this exception directly, if it is an IOException, a RuntimeException, or an Error.
     * Otherwise it wraps it in an IOException and throws it.
     *
     * @param t The Throwable to be thrown.
     */
    public static void rethrowIOException(Throwable t) throws IOException {
<span class="nc bnc" id="L412" title="All 2 branches missed.">        if (t instanceof IOException) {</span>
<span class="nc" id="L413">            throw (IOException) t;</span>
<span class="nc bnc" id="L414" title="All 2 branches missed.">        } else if (t instanceof RuntimeException) {</span>
<span class="nc" id="L415">            throw (RuntimeException) t;</span>
<span class="nc bnc" id="L416" title="All 2 branches missed.">        } else if (t instanceof Error) {</span>
<span class="nc" id="L417">            throw (Error) t;</span>
        } else {
<span class="nc" id="L419">            throw new IOException(t.getMessage(), t);</span>
        }
    }

    /**
     * Checks whether a throwable chain contains a specific type of exception and returns it. It
     * deserializes any {@link SerializedThrowable} that are found using the provided {@link
     * ClassLoader}.
     *
     * @param throwable the throwable chain to check.
     * @param searchType the type of exception to search for in the chain.
     * @param classLoader to use for deserialization.
     * @return Optional throwable of the requested type if available, otherwise empty
     */
    public static &lt;T extends Throwable&gt; Optional&lt;T&gt; findSerializedThrowable(
            Throwable throwable, Class&lt;T&gt; searchType, ClassLoader classLoader) {
<span class="nc bnc" id="L435" title="All 4 branches missed.">        if (throwable == null || searchType == null) {</span>
<span class="nc" id="L436">            return Optional.empty();</span>
        }

<span class="nc" id="L439">        Throwable t = throwable;</span>
<span class="nc bnc" id="L440" title="All 2 branches missed.">        while (t != null) {</span>
<span class="nc bnc" id="L441" title="All 2 branches missed.">            if (searchType.isAssignableFrom(t.getClass())) {</span>
<span class="nc" id="L442">                return Optional.of(searchType.cast(t));</span>
<span class="nc bnc" id="L443" title="All 2 branches missed.">            } else if (t.getClass().isAssignableFrom(SerializedThrowable.class)) {</span>
<span class="nc" id="L444">                Throwable next = ((SerializedThrowable) t).deserializeError(classLoader);</span>
                // SerializedThrowable#deserializeError returns itself under some conditions (e.g.,
                // null cause).
                // If that happens, exit to avoid looping infinitely. This is ok because if the user
                // was searching
                // for a SerializedThrowable, we would have returned it in the initial if condition.
<span class="nc bnc" id="L450" title="All 2 branches missed.">                t = (next == t) ? null : next;</span>
<span class="nc" id="L451">            } else {</span>
<span class="nc" id="L452">                t = t.getCause();</span>
            }
        }

<span class="nc" id="L456">        return Optional.empty();</span>
    }

    /**
     * Checks whether a throwable chain contains a specific type of exception and returns it.
     *
     * @param throwable the throwable chain to check.
     * @param searchType the type of exception to search for in the chain.
     * @return Optional throwable of the requested type if available, otherwise empty
     */
    public static &lt;T extends Throwable&gt; Optional&lt;T&gt; findThrowable(
            Throwable throwable, Class&lt;T&gt; searchType) {
<span class="pc bpc" id="L468" title="2 of 4 branches missed.">        if (throwable == null || searchType == null) {</span>
<span class="nc" id="L469">            return Optional.empty();</span>
        }

<span class="fc" id="L472">        Throwable t = throwable;</span>
<span class="pc bpc" id="L473" title="1 of 2 branches missed.">        while (t != null) {</span>
<span class="fc bfc" id="L474" title="All 2 branches covered.">            if (searchType.isAssignableFrom(t.getClass())) {</span>
<span class="fc" id="L475">                return Optional.of(searchType.cast(t));</span>
            } else {
<span class="fc" id="L477">                t = t.getCause();</span>
            }
        }

<span class="nc" id="L481">        return Optional.empty();</span>
    }

    /**
     * Checks whether a throwable chain contains a specific type of exception and returns it. This
     * method handles {@link SerializedThrowable}s in the chain and deserializes them with the given
     * ClassLoader.
     *
     * &lt;p&gt;SerializedThrowables are often used when exceptions might come from dynamically loaded
     * code and be transported over RPC / HTTP for better error reporting. The receiving processes
     * or threads might not have the dynamically loaded code available.
     *
     * @param throwable the throwable chain to check.
     * @param searchType the type of exception to search for in the chain.
     * @param classLoader the ClassLoader to use when encountering a SerializedThrowable.
     * @return Optional throwable of the requested type if available, otherwise empty
     */
    public static &lt;T extends Throwable&gt; Optional&lt;T&gt; findThrowableSerializedAware(
            Throwable throwable, Class&lt;T&gt; searchType, ClassLoader classLoader) {

<span class="nc bnc" id="L501" title="All 4 branches missed.">        if (throwable == null || searchType == null) {</span>
<span class="nc" id="L502">            return Optional.empty();</span>
        }

<span class="nc" id="L505">        Throwable t = throwable;</span>
<span class="nc bnc" id="L506" title="All 2 branches missed.">        while (t != null) {</span>
<span class="nc bnc" id="L507" title="All 2 branches missed.">            if (searchType.isAssignableFrom(t.getClass())) {</span>
<span class="nc" id="L508">                return Optional.of(searchType.cast(t));</span>
<span class="nc bnc" id="L509" title="All 2 branches missed.">            } else if (t instanceof SerializedThrowable) {</span>
<span class="nc" id="L510">                t = ((SerializedThrowable) t).deserializeError(classLoader);</span>
            } else {
<span class="nc" id="L512">                t = t.getCause();</span>
            }
        }

<span class="nc" id="L516">        return Optional.empty();</span>
    }

    /**
     * Checks whether a throwable chain contains an exception matching a predicate and returns it.
     *
     * @param throwable the throwable chain to check.
     * @param predicate the predicate of the exception to search for in the chain.
     * @return Optional throwable of the requested type if available, otherwise empty
     */
    public static Optional&lt;Throwable&gt; findThrowable(
            Throwable throwable, Predicate&lt;Throwable&gt; predicate) {
<span class="nc bnc" id="L528" title="All 4 branches missed.">        if (throwable == null || predicate == null) {</span>
<span class="nc" id="L529">            return Optional.empty();</span>
        }

<span class="nc" id="L532">        Throwable t = throwable;</span>
<span class="nc bnc" id="L533" title="All 2 branches missed.">        while (t != null) {</span>
<span class="nc bnc" id="L534" title="All 2 branches missed.">            if (predicate.test(t)) {</span>
<span class="nc" id="L535">                return Optional.of(t);</span>
            } else {
<span class="nc" id="L537">                t = t.getCause();</span>
            }
        }

<span class="nc" id="L541">        return Optional.empty();</span>
    }

    /**
     * Checks whether a throwable chain contains a specific error message and returns the
     * corresponding throwable.
     *
     * @param throwable the throwable chain to check.
     * @param searchMessage the error message to search for in the chain.
     * @return Optional throwable containing the search message if available, otherwise empty
     */
    public static Optional&lt;Throwable&gt; findThrowableWithMessage(
            Throwable throwable, String searchMessage) {
<span class="nc bnc" id="L554" title="All 4 branches missed.">        if (throwable == null || searchMessage == null) {</span>
<span class="nc" id="L555">            return Optional.empty();</span>
        }

<span class="nc" id="L558">        Throwable t = throwable;</span>
<span class="nc bnc" id="L559" title="All 2 branches missed.">        while (t != null) {</span>
<span class="nc bnc" id="L560" title="All 4 branches missed.">            if (t.getMessage() != null &amp;&amp; t.getMessage().contains(searchMessage)) {</span>
<span class="nc" id="L561">                return Optional.of(t);</span>
            } else {
<span class="nc" id="L563">                t = t.getCause();</span>
            }
        }

<span class="nc" id="L567">        return Optional.empty();</span>
    }

    /**
     * Unpacks an {@link ExecutionException} and returns its cause. Otherwise the given Throwable is
     * returned.
     *
     * @param throwable to unpack if it is an ExecutionException
     * @return Cause of ExecutionException or given Throwable
     */
    public static Throwable stripExecutionException(Throwable throwable) {
<span class="nc" id="L578">        return stripException(throwable, ExecutionException.class);</span>
    }

    /**
     * Unpacks an {@link CompletionException} and returns its cause. Otherwise the given Throwable
     * is returned.
     *
     * @param throwable to unpack if it is an CompletionException
     * @return Cause of CompletionException or given Throwable
     */
    public static Throwable stripCompletionException(Throwable throwable) {
<span class="nc" id="L589">        return stripException(throwable, CompletionException.class);</span>
    }

    /**
     * Unpacks an specified exception and returns its cause. Otherwise the given {@link Throwable}
     * is returned.
     *
     * @param throwableToStrip to strip
     * @param typeToStrip type to strip
     * @return Unpacked cause or given Throwable if not packed
     */
    public static Throwable stripException(
            Throwable throwableToStrip, Class&lt;? extends Throwable&gt; typeToStrip) {
<span class="fc bfc" id="L602" title="All 2 branches covered.">        while (typeToStrip.isAssignableFrom(throwableToStrip.getClass())</span>
<span class="pc bpc" id="L603" title="1 of 2 branches missed.">                &amp;&amp; throwableToStrip.getCause() != null) {</span>
<span class="fc" id="L604">            throwableToStrip = throwableToStrip.getCause();</span>
        }

<span class="fc" id="L607">        return throwableToStrip;</span>
    }

    /**
     * Tries to find a {@link SerializedThrowable} as the cause of the given throwable and throws
     * its deserialized value. If there is no such throwable, then the original throwable is thrown.
     *
     * @param throwable to check for a SerializedThrowable
     * @param classLoader to be used for the deserialization of the SerializedThrowable
     * @throws Throwable either the deserialized throwable or the given throwable
     */
    public static void tryDeserializeAndThrow(Throwable throwable, ClassLoader classLoader)
            throws Throwable {
<span class="nc" id="L620">        Throwable current = throwable;</span>

<span class="nc bnc" id="L622" title="All 4 branches missed.">        while (!(current instanceof SerializedThrowable) &amp;&amp; current.getCause() != null) {</span>
<span class="nc" id="L623">            current = current.getCause();</span>
        }

<span class="nc bnc" id="L626" title="All 2 branches missed.">        if (current instanceof SerializedThrowable) {</span>
<span class="nc" id="L627">            throw ((SerializedThrowable) current).deserializeError(classLoader);</span>
        } else {
<span class="nc" id="L629">            throw throwable;</span>
        }
    }

    /**
     * Checks whether the given exception is a {@link InterruptedException} and sets the interrupted
     * flag accordingly.
     *
     * @param e to check whether it is an {@link InterruptedException}
     */
    public static void checkInterrupted(Throwable e) {
<span class="nc bnc" id="L640" title="All 2 branches missed.">        if (e instanceof InterruptedException) {</span>
<span class="nc" id="L641">            Thread.currentThread().interrupt();</span>
        }
<span class="nc" id="L643">    }</span>

    // ------------------------------------------------------------------------
    //  Lambda exception utilities
    // ------------------------------------------------------------------------

    public static void suppressExceptions(RunnableWithException action) {
        try {
<span class="nc" id="L651">            action.run();</span>
<span class="nc" id="L652">        } catch (InterruptedException e) {</span>
            // restore interrupted state
<span class="nc" id="L654">            Thread.currentThread().interrupt();</span>
<span class="nc" id="L655">        } catch (Throwable t) {</span>
<span class="nc bnc" id="L656" title="All 2 branches missed.">            if (isJvmFatalError(t)) {</span>
<span class="nc" id="L657">                rethrow(t);</span>
            }
<span class="nc" id="L659">        }</span>
<span class="nc" id="L660">    }</span>

    // ------------------------------------------------------------------------

    /** Private constructor to prevent instantiation. */
    private ExceptionUtils() {}
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.7.202105040129</span></div></body></html>