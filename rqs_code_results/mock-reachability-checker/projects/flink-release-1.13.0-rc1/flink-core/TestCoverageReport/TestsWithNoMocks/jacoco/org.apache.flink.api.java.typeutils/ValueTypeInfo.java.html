<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>ValueTypeInfo.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Flink : Core</a> &gt; <a href="index.source.html" class="el_package">org.apache.flink.api.java.typeutils</a> &gt; <span class="el_source">ValueTypeInfo.java</span></div><h1>ValueTypeInfo.java</h1><pre class="source lang-java linenums">/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * &quot;License&quot;); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.apache.flink.api.java.typeutils;

import org.apache.flink.annotation.Public;
import org.apache.flink.annotation.PublicEvolving;
import org.apache.flink.api.common.ExecutionConfig;
import org.apache.flink.api.common.functions.InvalidTypesException;
import org.apache.flink.api.common.typeinfo.AtomicType;
import org.apache.flink.api.common.typeinfo.TypeInformation;
import org.apache.flink.api.common.typeutils.TypeComparator;
import org.apache.flink.api.common.typeutils.TypeSerializer;
import org.apache.flink.api.common.typeutils.base.BooleanValueComparator;
import org.apache.flink.api.common.typeutils.base.BooleanValueSerializer;
import org.apache.flink.api.common.typeutils.base.ByteValueComparator;
import org.apache.flink.api.common.typeutils.base.ByteValueSerializer;
import org.apache.flink.api.common.typeutils.base.CharValueComparator;
import org.apache.flink.api.common.typeutils.base.CharValueSerializer;
import org.apache.flink.api.common.typeutils.base.DoubleValueComparator;
import org.apache.flink.api.common.typeutils.base.DoubleValueSerializer;
import org.apache.flink.api.common.typeutils.base.FloatValueComparator;
import org.apache.flink.api.common.typeutils.base.FloatValueSerializer;
import org.apache.flink.api.common.typeutils.base.IntValueComparator;
import org.apache.flink.api.common.typeutils.base.IntValueSerializer;
import org.apache.flink.api.common.typeutils.base.LongValueComparator;
import org.apache.flink.api.common.typeutils.base.LongValueSerializer;
import org.apache.flink.api.common.typeutils.base.NullValueComparator;
import org.apache.flink.api.common.typeutils.base.NullValueSerializer;
import org.apache.flink.api.common.typeutils.base.ShortValueComparator;
import org.apache.flink.api.common.typeutils.base.ShortValueSerializer;
import org.apache.flink.api.common.typeutils.base.StringValueComparator;
import org.apache.flink.api.common.typeutils.base.StringValueSerializer;
import org.apache.flink.api.java.typeutils.runtime.CopyableValueComparator;
import org.apache.flink.api.java.typeutils.runtime.CopyableValueSerializer;
import org.apache.flink.api.java.typeutils.runtime.ValueComparator;
import org.apache.flink.api.java.typeutils.runtime.ValueSerializer;
import org.apache.flink.types.BooleanValue;
import org.apache.flink.types.ByteValue;
import org.apache.flink.types.CharValue;
import org.apache.flink.types.CopyableValue;
import org.apache.flink.types.DoubleValue;
import org.apache.flink.types.FloatValue;
import org.apache.flink.types.IntValue;
import org.apache.flink.types.LongValue;
import org.apache.flink.types.NullValue;
import org.apache.flink.types.ShortValue;
import org.apache.flink.types.StringValue;
import org.apache.flink.types.Value;

import static org.apache.flink.util.Preconditions.checkArgument;
import static org.apache.flink.util.Preconditions.checkNotNull;

/**
 * Type information for data types that extend the {@link Value} interface. The value interface
 * allows types to define their custom serialization and deserialization routines.
 *
 * @param &lt;T&gt; The type of the class represented by this type information.
 */
@Public
public class ValueTypeInfo&lt;T extends Value&gt; extends TypeInformation&lt;T&gt; implements AtomicType&lt;T&gt; {

    private static final long serialVersionUID = 1L;

<span class="fc" id="L80">    public static final ValueTypeInfo&lt;BooleanValue&gt; BOOLEAN_VALUE_TYPE_INFO =</span>
            new ValueTypeInfo&lt;&gt;(BooleanValue.class);
<span class="fc" id="L82">    public static final ValueTypeInfo&lt;ByteValue&gt; BYTE_VALUE_TYPE_INFO =</span>
            new ValueTypeInfo&lt;&gt;(ByteValue.class);
<span class="fc" id="L84">    public static final ValueTypeInfo&lt;CharValue&gt; CHAR_VALUE_TYPE_INFO =</span>
            new ValueTypeInfo&lt;&gt;(CharValue.class);
<span class="fc" id="L86">    public static final ValueTypeInfo&lt;DoubleValue&gt; DOUBLE_VALUE_TYPE_INFO =</span>
            new ValueTypeInfo&lt;&gt;(DoubleValue.class);
<span class="fc" id="L88">    public static final ValueTypeInfo&lt;FloatValue&gt; FLOAT_VALUE_TYPE_INFO =</span>
            new ValueTypeInfo&lt;&gt;(FloatValue.class);
<span class="fc" id="L90">    public static final ValueTypeInfo&lt;IntValue&gt; INT_VALUE_TYPE_INFO =</span>
            new ValueTypeInfo&lt;&gt;(IntValue.class);
<span class="fc" id="L92">    public static final ValueTypeInfo&lt;LongValue&gt; LONG_VALUE_TYPE_INFO =</span>
            new ValueTypeInfo&lt;&gt;(LongValue.class);
<span class="fc" id="L94">    public static final ValueTypeInfo&lt;NullValue&gt; NULL_VALUE_TYPE_INFO =</span>
            new ValueTypeInfo&lt;&gt;(NullValue.class);
<span class="fc" id="L96">    public static final ValueTypeInfo&lt;ShortValue&gt; SHORT_VALUE_TYPE_INFO =</span>
            new ValueTypeInfo&lt;&gt;(ShortValue.class);
<span class="fc" id="L98">    public static final ValueTypeInfo&lt;StringValue&gt; STRING_VALUE_TYPE_INFO =</span>
            new ValueTypeInfo&lt;&gt;(StringValue.class);

    private final Class&lt;T&gt; type;

    @PublicEvolving
<span class="fc" id="L104">    public ValueTypeInfo(Class&lt;T&gt; type) {</span>
<span class="fc" id="L105">        this.type = checkNotNull(type);</span>

<span class="fc" id="L107">        checkArgument(</span>
<span class="pc bpc" id="L108" title="3 of 4 branches missed.">                Value.class.isAssignableFrom(type) || type.equals(Value.class),</span>
                &quot;ValueTypeInfo can only be used for subclasses of %s&quot;,
<span class="fc" id="L110">                Value.class.getName());</span>
<span class="fc" id="L111">    }</span>

    @Override
    @PublicEvolving
    public int getArity() {
<span class="nc" id="L116">        return 1;</span>
    }

    @Override
    @PublicEvolving
    public int getTotalFields() {
<span class="fc" id="L122">        return 1;</span>
    }

    @Override
    @PublicEvolving
    public Class&lt;T&gt; getTypeClass() {
<span class="fc" id="L128">        return this.type;</span>
    }

    @Override
    @PublicEvolving
    public boolean isBasicType() {
<span class="fc" id="L134">        return false;</span>
    }

    @PublicEvolving
    public boolean isBasicValueType() {
<span class="nc bnc" id="L139" title="All 2 branches missed.">        return type.equals(StringValue.class)</span>
<span class="nc bnc" id="L140" title="All 2 branches missed.">                || type.equals(ByteValue.class)</span>
<span class="nc bnc" id="L141" title="All 2 branches missed.">                || type.equals(ShortValue.class)</span>
<span class="nc bnc" id="L142" title="All 2 branches missed.">                || type.equals(CharValue.class)</span>
<span class="nc bnc" id="L143" title="All 2 branches missed.">                || type.equals(DoubleValue.class)</span>
<span class="nc bnc" id="L144" title="All 2 branches missed.">                || type.equals(FloatValue.class)</span>
<span class="nc bnc" id="L145" title="All 2 branches missed.">                || type.equals(IntValue.class)</span>
<span class="nc bnc" id="L146" title="All 2 branches missed.">                || type.equals(LongValue.class)</span>
<span class="nc bnc" id="L147" title="All 2 branches missed.">                || type.equals(NullValue.class)</span>
<span class="nc bnc" id="L148" title="All 2 branches missed.">                || type.equals(BooleanValue.class);</span>
    }

    @Override
    @PublicEvolving
    public boolean isTupleType() {
<span class="fc" id="L154">        return false;</span>
    }

    @Override
    @PublicEvolving
    public boolean isKeyType() {
<span class="nc" id="L160">        return Comparable.class.isAssignableFrom(type);</span>
    }

    @Override
    @SuppressWarnings(&quot;unchecked&quot;)
    @PublicEvolving
    public TypeSerializer&lt;T&gt; createSerializer(ExecutionConfig executionConfig) {
<span class="pc bpc" id="L167" title="1 of 2 branches missed.">        if (BooleanValue.class.isAssignableFrom(type)) {</span>
<span class="nc" id="L168">            return (TypeSerializer&lt;T&gt;) BooleanValueSerializer.INSTANCE;</span>
<span class="pc bpc" id="L169" title="1 of 2 branches missed.">        } else if (ByteValue.class.isAssignableFrom(type)) {</span>
<span class="nc" id="L170">            return (TypeSerializer&lt;T&gt;) ByteValueSerializer.INSTANCE;</span>
<span class="pc bpc" id="L171" title="1 of 2 branches missed.">        } else if (CharValue.class.isAssignableFrom(type)) {</span>
<span class="nc" id="L172">            return (TypeSerializer&lt;T&gt;) CharValueSerializer.INSTANCE;</span>
<span class="fc bfc" id="L173" title="All 2 branches covered.">        } else if (DoubleValue.class.isAssignableFrom(type)) {</span>
<span class="fc" id="L174">            return (TypeSerializer&lt;T&gt;) DoubleValueSerializer.INSTANCE;</span>
<span class="pc bpc" id="L175" title="1 of 2 branches missed.">        } else if (FloatValue.class.isAssignableFrom(type)) {</span>
<span class="nc" id="L176">            return (TypeSerializer&lt;T&gt;) FloatValueSerializer.INSTANCE;</span>
<span class="pc bpc" id="L177" title="1 of 2 branches missed.">        } else if (IntValue.class.isAssignableFrom(type)) {</span>
<span class="nc" id="L178">            return (TypeSerializer&lt;T&gt;) IntValueSerializer.INSTANCE;</span>
<span class="fc bfc" id="L179" title="All 2 branches covered.">        } else if (LongValue.class.isAssignableFrom(type)) {</span>
<span class="fc" id="L180">            return (TypeSerializer&lt;T&gt;) LongValueSerializer.INSTANCE;</span>
<span class="pc bpc" id="L181" title="1 of 2 branches missed.">        } else if (NullValue.class.isAssignableFrom(type)) {</span>
<span class="nc" id="L182">            return (TypeSerializer&lt;T&gt;) NullValueSerializer.INSTANCE;</span>
<span class="pc bpc" id="L183" title="1 of 2 branches missed.">        } else if (ShortValue.class.isAssignableFrom(type)) {</span>
<span class="nc" id="L184">            return (TypeSerializer&lt;T&gt;) ShortValueSerializer.INSTANCE;</span>
<span class="pc bpc" id="L185" title="1 of 2 branches missed.">        } else if (StringValue.class.isAssignableFrom(type)) {</span>
<span class="fc" id="L186">            return (TypeSerializer&lt;T&gt;) StringValueSerializer.INSTANCE;</span>
<span class="nc bnc" id="L187" title="All 2 branches missed.">        } else if (CopyableValue.class.isAssignableFrom(type)) {</span>
<span class="nc" id="L188">            return (TypeSerializer&lt;T&gt;)</span>
<span class="nc" id="L189">                    createCopyableValueSerializer(type.asSubclass(CopyableValue.class));</span>
        } else {
<span class="nc" id="L191">            return new ValueSerializer&lt;T&gt;(type);</span>
        }
    }

    @SuppressWarnings({&quot;unchecked&quot;, &quot;rawtypes&quot;})
    @Override
    @PublicEvolving
    public TypeComparator&lt;T&gt; createComparator(
            boolean sortOrderAscending, ExecutionConfig executionConfig) {
<span class="nc bnc" id="L200" title="All 2 branches missed.">        if (!isKeyType()) {</span>
<span class="nc" id="L201">            throw new RuntimeException(&quot;The type &quot; + type.getName() + &quot; is not Comparable.&quot;);</span>
        }

<span class="nc bnc" id="L204" title="All 2 branches missed.">        if (BooleanValue.class.isAssignableFrom(type)) {</span>
<span class="nc" id="L205">            return (TypeComparator&lt;T&gt;) new BooleanValueComparator(sortOrderAscending);</span>
<span class="nc bnc" id="L206" title="All 2 branches missed.">        } else if (ByteValue.class.isAssignableFrom(type)) {</span>
<span class="nc" id="L207">            return (TypeComparator&lt;T&gt;) new ByteValueComparator(sortOrderAscending);</span>
<span class="nc bnc" id="L208" title="All 2 branches missed.">        } else if (CharValue.class.isAssignableFrom(type)) {</span>
<span class="nc" id="L209">            return (TypeComparator&lt;T&gt;) new CharValueComparator(sortOrderAscending);</span>
<span class="nc bnc" id="L210" title="All 2 branches missed.">        } else if (DoubleValue.class.isAssignableFrom(type)) {</span>
<span class="nc" id="L211">            return (TypeComparator&lt;T&gt;) new DoubleValueComparator(sortOrderAscending);</span>
<span class="nc bnc" id="L212" title="All 2 branches missed.">        } else if (FloatValue.class.isAssignableFrom(type)) {</span>
<span class="nc" id="L213">            return (TypeComparator&lt;T&gt;) new FloatValueComparator(sortOrderAscending);</span>
<span class="nc bnc" id="L214" title="All 2 branches missed.">        } else if (IntValue.class.isAssignableFrom(type)) {</span>
<span class="nc" id="L215">            return (TypeComparator&lt;T&gt;) new IntValueComparator(sortOrderAscending);</span>
<span class="nc bnc" id="L216" title="All 2 branches missed.">        } else if (LongValue.class.isAssignableFrom(type)) {</span>
<span class="nc" id="L217">            return (TypeComparator&lt;T&gt;) new LongValueComparator(sortOrderAscending);</span>
<span class="nc bnc" id="L218" title="All 2 branches missed.">        } else if (NullValue.class.isAssignableFrom(type)) {</span>
<span class="nc" id="L219">            return (TypeComparator&lt;T&gt;) NullValueComparator.getInstance();</span>
<span class="nc bnc" id="L220" title="All 2 branches missed.">        } else if (ShortValue.class.isAssignableFrom(type)) {</span>
<span class="nc" id="L221">            return (TypeComparator&lt;T&gt;) new ShortValueComparator(sortOrderAscending);</span>
<span class="nc bnc" id="L222" title="All 2 branches missed.">        } else if (StringValue.class.isAssignableFrom(type)) {</span>
<span class="nc" id="L223">            return (TypeComparator&lt;T&gt;) new StringValueComparator(sortOrderAscending);</span>
<span class="nc bnc" id="L224" title="All 2 branches missed.">        } else if (CopyableValue.class.isAssignableFrom(type)) {</span>
<span class="nc" id="L225">            return (TypeComparator&lt;T&gt;) new CopyableValueComparator(sortOrderAscending, type);</span>
        } else {
<span class="nc" id="L227">            return (TypeComparator&lt;T&gt;) new ValueComparator(sortOrderAscending, type);</span>
        }
    }

    // utility method to summon the necessary bound
    private static &lt;X extends CopyableValue&lt;X&gt;&gt;
            CopyableValueSerializer&lt;X&gt; createCopyableValueSerializer(Class&lt;X&gt; clazz) {
<span class="nc" id="L234">        return new CopyableValueSerializer&lt;X&gt;(clazz);</span>
    }

    // --------------------------------------------------------------------------------------------

    @Override
    public int hashCode() {
<span class="nc" id="L241">        return this.type.hashCode();</span>
    }

    @Override
    public boolean equals(Object obj) {
<span class="fc bfc" id="L246" title="All 2 branches covered.">        if (obj instanceof ValueTypeInfo) {</span>
            @SuppressWarnings(&quot;unchecked&quot;)
<span class="fc" id="L248">            ValueTypeInfo&lt;T&gt; valueTypeInfo = (ValueTypeInfo&lt;T&gt;) obj;</span>

<span class="pc bpc" id="L250" title="1 of 4 branches missed.">            return valueTypeInfo.canEqual(this) &amp;&amp; type == valueTypeInfo.type;</span>
        } else {
<span class="fc" id="L252">            return false;</span>
        }
    }

    @Override
    public boolean canEqual(Object obj) {
<span class="fc" id="L258">        return obj instanceof ValueTypeInfo;</span>
    }

    @Override
    public String toString() {
<span class="fc" id="L263">        return &quot;ValueType&lt;&quot; + type.getSimpleName() + &quot;&gt;&quot;;</span>
    }

    // --------------------------------------------------------------------------------------------

    @PublicEvolving
    static &lt;X extends Value&gt; TypeInformation&lt;X&gt; getValueTypeInfo(Class&lt;X&gt; typeClass) {
<span class="pc bpc" id="L270" title="1 of 4 branches missed.">        if (Value.class.isAssignableFrom(typeClass) &amp;&amp; !typeClass.equals(Value.class)) {</span>
<span class="fc" id="L271">            return new ValueTypeInfo&lt;X&gt;(typeClass);</span>
        } else {
<span class="fc" id="L273">            throw new InvalidTypesException(</span>
<span class="fc" id="L274">                    &quot;The given class is no subclass of &quot; + Value.class.getName());</span>
        }
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.7.202105040129</span></div></body></html>