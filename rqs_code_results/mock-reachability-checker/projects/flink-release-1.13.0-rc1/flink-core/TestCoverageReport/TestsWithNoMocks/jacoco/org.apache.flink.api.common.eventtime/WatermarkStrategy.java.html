<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>WatermarkStrategy.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Flink : Core</a> &gt; <a href="index.source.html" class="el_package">org.apache.flink.api.common.eventtime</a> &gt; <span class="el_source">WatermarkStrategy.java</span></div><h1>WatermarkStrategy.java</h1><pre class="source lang-java linenums">/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * &quot;License&quot;); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.apache.flink.api.common.eventtime;

import org.apache.flink.annotation.Public;

import java.io.Serializable;
import java.time.Duration;

import static org.apache.flink.util.Preconditions.checkArgument;
import static org.apache.flink.util.Preconditions.checkNotNull;

/**
 * The WatermarkStrategy defines how to generate {@link Watermark}s in the stream sources. The
 * WatermarkStrategy is a builder/factory for the {@link WatermarkGenerator} that generates the
 * watermarks and the {@link TimestampAssigner} which assigns the internal timestamp of a record.
 *
 * &lt;p&gt;This interface is split into three parts: 1) methods that an implementor of this interface
 * needs to implement, 2) builder methods for building a {@code WatermarkStrategy} on a base
 * strategy, 3) convenience methods for constructing a {@code WatermarkStrategy} for common built-in
 * strategies or based on a {@link WatermarkGeneratorSupplier}
 *
 * &lt;p&gt;Implementors of this interface need only implement {@link
 * #createWatermarkGenerator(WatermarkGeneratorSupplier.Context)}. Optionally, you can implement
 * {@link #createTimestampAssigner(TimestampAssignerSupplier.Context)}.
 *
 * &lt;p&gt;The builder methods, like {@link #withIdleness(Duration)} or {@link
 * #createTimestampAssigner(TimestampAssignerSupplier.Context)} create a new {@code
 * WatermarkStrategy} that wraps and enriches a base strategy. The strategy on which the method is
 * called is the base strategy.
 *
 * &lt;p&gt;The convenience methods, for example {@link #forBoundedOutOfOrderness(Duration)}, create a
 * {@code WatermarkStrategy} for common built in strategies.
 *
 * &lt;p&gt;This interface is {@link Serializable} because watermark strategies may be shipped to workers
 * during distributed execution.
 */
@Public
public interface WatermarkStrategy&lt;T&gt;
        extends TimestampAssignerSupplier&lt;T&gt;, WatermarkGeneratorSupplier&lt;T&gt; {

    // ------------------------------------------------------------------------
    //  Methods that implementors need to implement.
    // ------------------------------------------------------------------------

    /** Instantiates a WatermarkGenerator that generates watermarks according to this strategy. */
    @Override
    WatermarkGenerator&lt;T&gt; createWatermarkGenerator(WatermarkGeneratorSupplier.Context context);

    /**
     * Instantiates a {@link TimestampAssigner} for assigning timestamps according to this strategy.
     */
    @Override
    default TimestampAssigner&lt;T&gt; createTimestampAssigner(
            TimestampAssignerSupplier.Context context) {
        // By default, this is {@link RecordTimestampAssigner},
        // for cases where records come out of a source with valid timestamps, for example from
        // Kafka.
<span class="fc" id="L75">        return new RecordTimestampAssigner&lt;&gt;();</span>
    }

    // ------------------------------------------------------------------------
    //  Builder methods for enriching a base WatermarkStrategy
    // ------------------------------------------------------------------------

    /**
     * Creates a new {@code WatermarkStrategy} that wraps this strategy but instead uses the given
     * {@link TimestampAssigner} (via a {@link TimestampAssignerSupplier}).
     *
     * &lt;p&gt;You can use this when a {@link TimestampAssigner} needs additional context, for example
     * access to the metrics system.
     *
     * &lt;pre&gt;
     * {@code WatermarkStrategy&lt;Object&gt; wmStrategy = WatermarkStrategy
     *   .forMonotonousTimestamps()
     *   .withTimestampAssigner((ctx) -&gt; new MetricsReportingAssigner(ctx));
     * }&lt;/pre&gt;
     */
    default WatermarkStrategy&lt;T&gt; withTimestampAssigner(
            TimestampAssignerSupplier&lt;T&gt; timestampAssigner) {
<span class="fc" id="L97">        checkNotNull(timestampAssigner, &quot;timestampAssigner&quot;);</span>
<span class="fc" id="L98">        return new WatermarkStrategyWithTimestampAssigner&lt;&gt;(this, timestampAssigner);</span>
    }

    /**
     * Creates a new {@code WatermarkStrategy} that wraps this strategy but instead uses the given
     * {@link SerializableTimestampAssigner}.
     *
     * &lt;p&gt;You can use this in case you want to specify a {@link TimestampAssigner} via a lambda
     * function.
     *
     * &lt;pre&gt;
     * {@code WatermarkStrategy&lt;CustomObject&gt; wmStrategy = WatermarkStrategy
     *   .&lt;CustomObject&gt;forMonotonousTimestamps()
     *   .withTimestampAssigner((event, timestamp) -&gt; event.getTimestamp());
     * }&lt;/pre&gt;
     */
    default WatermarkStrategy&lt;T&gt; withTimestampAssigner(
            SerializableTimestampAssigner&lt;T&gt; timestampAssigner) {
<span class="fc" id="L116">        checkNotNull(timestampAssigner, &quot;timestampAssigner&quot;);</span>
<span class="fc" id="L117">        return new WatermarkStrategyWithTimestampAssigner&lt;&gt;(</span>
<span class="fc" id="L118">                this, TimestampAssignerSupplier.of(timestampAssigner));</span>
    }

    /**
     * Creates a new enriched {@link WatermarkStrategy} that also does idleness detection in the
     * created {@link WatermarkGenerator}.
     *
     * &lt;p&gt;Add an idle timeout to the watermark strategy. If no records flow in a partition of a
     * stream for that amount of time, then that partition is considered &quot;idle&quot; and will not hold
     * back the progress of watermarks in downstream operators.
     *
     * &lt;p&gt;Idleness can be important if some partitions have little data and might not have events
     * during some periods. Without idleness, these streams can stall the overall event time
     * progress of the application.
     */
    default WatermarkStrategy&lt;T&gt; withIdleness(Duration idleTimeout) {
<span class="fc" id="L134">        checkNotNull(idleTimeout, &quot;idleTimeout&quot;);</span>
<span class="fc" id="L135">        checkArgument(</span>
<span class="pc bpc" id="L136" title="2 of 4 branches missed.">                !(idleTimeout.isZero() || idleTimeout.isNegative()),</span>
                &quot;idleTimeout must be greater than zero&quot;);
<span class="fc" id="L138">        return new WatermarkStrategyWithIdleness&lt;&gt;(this, idleTimeout);</span>
    }

    // ------------------------------------------------------------------------
    //  Convenience methods for common watermark strategies
    // ------------------------------------------------------------------------

    /**
     * Creates a watermark strategy for situations with monotonously ascending timestamps.
     *
     * &lt;p&gt;The watermarks are generated periodically and tightly follow the latest timestamp in the
     * data. The delay introduced by this strategy is mainly the periodic interval in which the
     * watermarks are generated.
     *
     * @see AscendingTimestampsWatermarks
     */
    static &lt;T&gt; WatermarkStrategy&lt;T&gt; forMonotonousTimestamps() {
<span class="fc" id="L155">        return (ctx) -&gt; new AscendingTimestampsWatermarks&lt;&gt;();</span>
    }

    /**
     * Creates a watermark strategy for situations where records are out of order, but you can place
     * an upper bound on how far the events are out of order. An out-of-order bound B means that
     * once the an event with timestamp T was encountered, no events older than {@code T - B} will
     * follow any more.
     *
     * &lt;p&gt;The watermarks are generated periodically. The delay introduced by this watermark strategy
     * is the periodic interval length, plus the out of orderness bound.
     *
     * @see BoundedOutOfOrdernessWatermarks
     */
    static &lt;T&gt; WatermarkStrategy&lt;T&gt; forBoundedOutOfOrderness(Duration maxOutOfOrderness) {
<span class="nc" id="L170">        return (ctx) -&gt; new BoundedOutOfOrdernessWatermarks&lt;&gt;(maxOutOfOrderness);</span>
    }

    /** Creates a watermark strategy based on an existing {@link WatermarkGeneratorSupplier}. */
    static &lt;T&gt; WatermarkStrategy&lt;T&gt; forGenerator(WatermarkGeneratorSupplier&lt;T&gt; generatorSupplier) {
<span class="nc" id="L175">        return generatorSupplier::createWatermarkGenerator;</span>
    }

    /**
     * Creates a watermark strategy that generates no watermarks at all. This may be useful in
     * scenarios that do pure processing-time based stream processing.
     */
    static &lt;T&gt; WatermarkStrategy&lt;T&gt; noWatermarks() {
<span class="nc" id="L183">        return (ctx) -&gt; new NoWatermarksGenerator&lt;&gt;();</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.7.202105040129</span></div></body></html>