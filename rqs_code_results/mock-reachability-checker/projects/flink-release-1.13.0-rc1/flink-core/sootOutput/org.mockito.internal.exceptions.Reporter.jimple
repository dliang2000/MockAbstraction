public class org.mockito.internal.exceptions.Reporter extends java.lang.Object
{
    private static final java.lang.String NON_PUBLIC_PARENT;

    private void <init>()
    {
        org.mockito.internal.exceptions.Reporter r0;

        r0 := @this: org.mockito.internal.exceptions.Reporter;

        specialinvoke r0.<java.lang.Object: void <init>()>();

        return;
    }

    public static org.mockito.exceptions.base.MockitoException checkedExceptionInvalid(java.lang.Throwable)
    {
        java.lang.Throwable r0;
        org.mockito.exceptions.base.MockitoException $r1;
        java.lang.Object[] $r2;
        java.lang.StringBuilder $r3, $r4, $r5;
        java.lang.String $r6, $r7;

        r0 := @parameter0: java.lang.Throwable;

        $r1 = new org.mockito.exceptions.base.MockitoException;

        $r2 = newarray (java.lang.Object)[2];

        $r2[0] = "Checked exception is invalid for this method!";

        $r3 = new java.lang.StringBuilder;

        specialinvoke $r3.<java.lang.StringBuilder: void <init>()>();

        $r4 = virtualinvoke $r3.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>("Invalid: ");

        $r5 = virtualinvoke $r4.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.Object)>(r0);

        $r6 = virtualinvoke $r5.<java.lang.StringBuilder: java.lang.String toString()>();

        $r2[1] = $r6;

        $r7 = staticinvoke <org.mockito.internal.util.StringUtil: java.lang.String join(java.lang.Object[])>($r2);

        specialinvoke $r1.<org.mockito.exceptions.base.MockitoException: void <init>(java.lang.String)>($r7);

        return $r1;
    }

    public static org.mockito.exceptions.base.MockitoException cannotStubWithNullThrowable()
    {
        org.mockito.exceptions.base.MockitoException $r0;
        java.lang.Object[] $r1;
        java.lang.String $r2;

        $r0 = new org.mockito.exceptions.base.MockitoException;

        $r1 = newarray (java.lang.Object)[1];

        $r1[0] = "Cannot stub with null throwable!";

        $r2 = staticinvoke <org.mockito.internal.util.StringUtil: java.lang.String join(java.lang.Object[])>($r1);

        specialinvoke $r0.<org.mockito.exceptions.base.MockitoException: void <init>(java.lang.String)>($r2);

        return $r0;
    }

    public static org.mockito.exceptions.base.MockitoException unfinishedStubbing(org.mockito.invocation.Location)
    {
        org.mockito.invocation.Location r0;
        org.mockito.exceptions.misusing.UnfinishedStubbingException $r1;
        java.lang.Object[] $r2;
        java.lang.String $r3;

        r0 := @parameter0: org.mockito.invocation.Location;

        $r1 = new org.mockito.exceptions.misusing.UnfinishedStubbingException;

        $r2 = newarray (java.lang.Object)[13];

        $r2[0] = "Unfinished stubbing detected here:";

        $r2[1] = r0;

        $r2[2] = "";

        $r2[3] = "E.g. thenReturn() may be missing.";

        $r2[4] = "Examples of correct stubbing:";

        $r2[5] = "    when(mock.isOk()).thenReturn(true);";

        $r2[6] = "    when(mock.isOk()).thenThrow(exception);";

        $r2[7] = "    doThrow(exception).when(mock).someVoidMethod();";

        $r2[8] = "Hints:";

        $r2[9] = " 1. missing thenReturn()";

        $r2[10] = " 2. you are trying to stub a final method, which is not supported";

        $r2[11] = " 3: you are stubbing the behaviour of another mock inside before \'thenReturn\' instruction if completed";

        $r2[12] = "";

        $r3 = staticinvoke <org.mockito.internal.util.StringUtil: java.lang.String join(java.lang.Object[])>($r2);

        specialinvoke $r1.<org.mockito.exceptions.misusing.UnfinishedStubbingException: void <init>(java.lang.String)>($r3);

        return $r1;
    }

    public static org.mockito.exceptions.base.MockitoException incorrectUseOfApi()
    {
        org.mockito.exceptions.base.MockitoException $r0;
        java.lang.Object[] $r1;
        org.mockito.internal.debugging.LocationImpl $r2;
        java.lang.String $r3;

        $r0 = new org.mockito.exceptions.base.MockitoException;

        $r1 = newarray (java.lang.Object)[8];

        $r1[0] = "Incorrect use of API detected here:";

        $r2 = new org.mockito.internal.debugging.LocationImpl;

        specialinvoke $r2.<org.mockito.internal.debugging.LocationImpl: void <init>()>();

        $r1[1] = $r2;

        $r1[2] = "";

        $r1[3] = "You probably stored a reference to OngoingStubbing returned by when() and called stubbing methods like thenReturn() on this reference more than once.";

        $r1[4] = "Examples of correct usage:";

        $r1[5] = "    when(mock.isOk()).thenReturn(true).thenReturn(false).thenThrow(exception);";

        $r1[6] = "    when(mock.isOk()).thenReturn(true, false).thenThrow(exception);";

        $r1[7] = "";

        $r3 = staticinvoke <org.mockito.internal.util.StringUtil: java.lang.String join(java.lang.Object[])>($r1);

        specialinvoke $r0.<org.mockito.exceptions.base.MockitoException: void <init>(java.lang.String)>($r3);

        return $r0;
    }

    public static org.mockito.exceptions.base.MockitoException missingMethodInvocation()
    {
        org.mockito.exceptions.misusing.MissingMethodInvocationException $r0;
        java.lang.Object[] $r1;
        java.lang.String $r2;

        $r0 = new org.mockito.exceptions.misusing.MissingMethodInvocationException;

        $r1 = newarray (java.lang.Object)[10];

        $r1[0] = "when() requires an argument which has to be \'a method call on a mock\'.";

        $r1[1] = "For example:";

        $r1[2] = "    when(mock.getArticles()).thenReturn(articles);";

        $r1[3] = "";

        $r1[4] = "Also, this error might show up because:";

        $r1[5] = "1. you stub either of: final/private/equals()/hashCode() methods.";

        $r1[6] = "   Those methods *cannot* be stubbed/verified.";

        $r1[7] = "   Mocking methods declared on non-public parent classes is not supported.";

        $r1[8] = "2. inside when() you don\'t call method on mock but on some other object.";

        $r1[9] = "";

        $r2 = staticinvoke <org.mockito.internal.util.StringUtil: java.lang.String join(java.lang.Object[])>($r1);

        specialinvoke $r0.<org.mockito.exceptions.misusing.MissingMethodInvocationException: void <init>(java.lang.String)>($r2);

        return $r0;
    }

    public static org.mockito.exceptions.base.MockitoException unfinishedVerificationException(org.mockito.invocation.Location)
    {
        org.mockito.invocation.Location r0;
        org.mockito.exceptions.misusing.UnfinishedVerificationException $r1;
        java.lang.Object[] $r2;
        java.lang.String $r3;

        r0 := @parameter0: org.mockito.invocation.Location;

        $r1 = new org.mockito.exceptions.misusing.UnfinishedVerificationException;

        $r2 = newarray (java.lang.Object)[10];

        $r2[0] = "Missing method call for verify(mock) here:";

        $r2[1] = r0;

        $r2[2] = "";

        $r2[3] = "Example of correct verification:";

        $r2[4] = "    verify(mock).doSomething()";

        $r2[5] = "";

        $r2[6] = "Also, this error might show up because you verify either of: final/private/equals()/hashCode() methods.";

        $r2[7] = "Those methods *cannot* be stubbed/verified.";

        $r2[8] = "Mocking methods declared on non-public parent classes is not supported.";

        $r2[9] = "";

        $r3 = staticinvoke <org.mockito.internal.util.StringUtil: java.lang.String join(java.lang.Object[])>($r2);

        specialinvoke $r1.<org.mockito.exceptions.misusing.UnfinishedVerificationException: void <init>(java.lang.String)>($r3);

        return $r1;
    }

    public static org.mockito.exceptions.base.MockitoException notAMockPassedToVerify(java.lang.Class)
    {
        java.lang.Class r0;
        org.mockito.exceptions.misusing.NotAMockException $r1;
        java.lang.Object[] $r2;
        java.lang.StringBuilder $r3, $r4, $r6, $r7;
        java.lang.String $r5, $r8, $r9;

        r0 := @parameter0: java.lang.Class;

        $r1 = new org.mockito.exceptions.misusing.NotAMockException;

        $r2 = newarray (java.lang.Object)[6];

        $r3 = new java.lang.StringBuilder;

        specialinvoke $r3.<java.lang.StringBuilder: void <init>()>();

        $r4 = virtualinvoke $r3.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>("Argument passed to verify() is of type ");

        $r5 = virtualinvoke r0.<java.lang.Class: java.lang.String getSimpleName()>();

        $r6 = virtualinvoke $r4.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>($r5);

        $r7 = virtualinvoke $r6.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>(" and is not a mock!");

        $r8 = virtualinvoke $r7.<java.lang.StringBuilder: java.lang.String toString()>();

        $r2[0] = $r8;

        $r2[1] = "Make sure you place the parenthesis correctly!";

        $r2[2] = "See the examples of correct verifications:";

        $r2[3] = "    verify(mock).someMethod();";

        $r2[4] = "    verify(mock, times(10)).someMethod();";

        $r2[5] = "    verify(mock, atLeastOnce()).someMethod();";

        $r9 = staticinvoke <org.mockito.internal.util.StringUtil: java.lang.String join(java.lang.Object[])>($r2);

        specialinvoke $r1.<org.mockito.exceptions.misusing.NotAMockException: void <init>(java.lang.String)>($r9);

        return $r1;
    }

    public static org.mockito.exceptions.base.MockitoException nullPassedToVerify()
    {
        org.mockito.exceptions.misusing.NullInsteadOfMockException $r0;
        java.lang.Object[] $r1;
        java.lang.String $r2;

        $r0 = new org.mockito.exceptions.misusing.NullInsteadOfMockException;

        $r1 = newarray (java.lang.Object)[7];

        $r1[0] = "Argument passed to verify() should be a mock but is null!";

        $r1[1] = "Examples of correct verifications:";

        $r1[2] = "    verify(mock).someMethod();";

        $r1[3] = "    verify(mock, times(10)).someMethod();";

        $r1[4] = "    verify(mock, atLeastOnce()).someMethod();";

        $r1[5] = "    not: verify(mock.someMethod());";

        $r1[6] = "Also, if you use @Mock annotation don\'t miss initMocks()";

        $r2 = staticinvoke <org.mockito.internal.util.StringUtil: java.lang.String join(java.lang.Object[])>($r1);

        specialinvoke $r0.<org.mockito.exceptions.misusing.NullInsteadOfMockException: void <init>(java.lang.String)>($r2);

        return $r0;
    }

    public static org.mockito.exceptions.base.MockitoException notAMockPassedToWhenMethod()
    {
        org.mockito.exceptions.misusing.NotAMockException $r0;
        java.lang.Object[] $r1;
        java.lang.String $r2;

        $r0 = new org.mockito.exceptions.misusing.NotAMockException;

        $r1 = newarray (java.lang.Object)[3];

        $r1[0] = "Argument passed to when() is not a mock!";

        $r1[1] = "Example of correct stubbing:";

        $r1[2] = "    doThrow(new RuntimeException()).when(mock).someMethod();";

        $r2 = staticinvoke <org.mockito.internal.util.StringUtil: java.lang.String join(java.lang.Object[])>($r1);

        specialinvoke $r0.<org.mockito.exceptions.misusing.NotAMockException: void <init>(java.lang.String)>($r2);

        return $r0;
    }

    public static org.mockito.exceptions.base.MockitoException nullPassedToWhenMethod()
    {
        org.mockito.exceptions.misusing.NullInsteadOfMockException $r0;
        java.lang.Object[] $r1;
        java.lang.String $r2;

        $r0 = new org.mockito.exceptions.misusing.NullInsteadOfMockException;

        $r1 = newarray (java.lang.Object)[4];

        $r1[0] = "Argument passed to when() is null!";

        $r1[1] = "Example of correct stubbing:";

        $r1[2] = "    doThrow(new RuntimeException()).when(mock).someMethod();";

        $r1[3] = "Also, if you use @Mock annotation don\'t miss initMocks()";

        $r2 = staticinvoke <org.mockito.internal.util.StringUtil: java.lang.String join(java.lang.Object[])>($r1);

        specialinvoke $r0.<org.mockito.exceptions.misusing.NullInsteadOfMockException: void <init>(java.lang.String)>($r2);

        return $r0;
    }

    public static org.mockito.exceptions.base.MockitoException mocksHaveToBePassedToVerifyNoMoreInteractions()
    {
        org.mockito.exceptions.base.MockitoException $r0;
        java.lang.Object[] $r1;
        java.lang.String $r2;

        $r0 = new org.mockito.exceptions.base.MockitoException;

        $r1 = newarray (java.lang.Object)[5];

        $r1[0] = "Method requires argument(s)!";

        $r1[1] = "Pass mocks that should be verified, e.g:";

        $r1[2] = "    verifyNoMoreInteractions(mockOne, mockTwo);";

        $r1[3] = "    verifyZeroInteractions(mockOne, mockTwo);";

        $r1[4] = "";

        $r2 = staticinvoke <org.mockito.internal.util.StringUtil: java.lang.String join(java.lang.Object[])>($r1);

        specialinvoke $r0.<org.mockito.exceptions.base.MockitoException: void <init>(java.lang.String)>($r2);

        return $r0;
    }

    public static org.mockito.exceptions.base.MockitoException notAMockPassedToVerifyNoMoreInteractions()
    {
        org.mockito.exceptions.misusing.NotAMockException $r0;
        java.lang.Object[] $r1;
        java.lang.String $r2;

        $r0 = new org.mockito.exceptions.misusing.NotAMockException;

        $r1 = newarray (java.lang.Object)[5];

        $r1[0] = "Argument(s) passed is not a mock!";

        $r1[1] = "Examples of correct verifications:";

        $r1[2] = "    verifyNoMoreInteractions(mockOne, mockTwo);";

        $r1[3] = "    verifyZeroInteractions(mockOne, mockTwo);";

        $r1[4] = "";

        $r2 = staticinvoke <org.mockito.internal.util.StringUtil: java.lang.String join(java.lang.Object[])>($r1);

        specialinvoke $r0.<org.mockito.exceptions.misusing.NotAMockException: void <init>(java.lang.String)>($r2);

        return $r0;
    }

    public static org.mockito.exceptions.base.MockitoException nullPassedToVerifyNoMoreInteractions()
    {
        org.mockito.exceptions.misusing.NullInsteadOfMockException $r0;
        java.lang.Object[] $r1;
        java.lang.String $r2;

        $r0 = new org.mockito.exceptions.misusing.NullInsteadOfMockException;

        $r1 = newarray (java.lang.Object)[4];

        $r1[0] = "Argument(s) passed is null!";

        $r1[1] = "Examples of correct verifications:";

        $r1[2] = "    verifyNoMoreInteractions(mockOne, mockTwo);";

        $r1[3] = "    verifyZeroInteractions(mockOne, mockTwo);";

        $r2 = staticinvoke <org.mockito.internal.util.StringUtil: java.lang.String join(java.lang.Object[])>($r1);

        specialinvoke $r0.<org.mockito.exceptions.misusing.NullInsteadOfMockException: void <init>(java.lang.String)>($r2);

        return $r0;
    }

    public static org.mockito.exceptions.base.MockitoException notAMockPassedWhenCreatingInOrder()
    {
        org.mockito.exceptions.misusing.NotAMockException $r0;
        java.lang.Object[] $r1;
        java.lang.String $r2;

        $r0 = new org.mockito.exceptions.misusing.NotAMockException;

        $r1 = newarray (java.lang.Object)[4];

        $r1[0] = "Argument(s) passed is not a mock!";

        $r1[1] = "Pass mocks that require verification in order.";

        $r1[2] = "For example:";

        $r1[3] = "    InOrder inOrder = inOrder(mockOne, mockTwo);";

        $r2 = staticinvoke <org.mockito.internal.util.StringUtil: java.lang.String join(java.lang.Object[])>($r1);

        specialinvoke $r0.<org.mockito.exceptions.misusing.NotAMockException: void <init>(java.lang.String)>($r2);

        return $r0;
    }

    public static org.mockito.exceptions.base.MockitoException nullPassedWhenCreatingInOrder()
    {
        org.mockito.exceptions.misusing.NullInsteadOfMockException $r0;
        java.lang.Object[] $r1;
        java.lang.String $r2;

        $r0 = new org.mockito.exceptions.misusing.NullInsteadOfMockException;

        $r1 = newarray (java.lang.Object)[4];

        $r1[0] = "Argument(s) passed is null!";

        $r1[1] = "Pass mocks that require verification in order.";

        $r1[2] = "For example:";

        $r1[3] = "    InOrder inOrder = inOrder(mockOne, mockTwo);";

        $r2 = staticinvoke <org.mockito.internal.util.StringUtil: java.lang.String join(java.lang.Object[])>($r1);

        specialinvoke $r0.<org.mockito.exceptions.misusing.NullInsteadOfMockException: void <init>(java.lang.String)>($r2);

        return $r0;
    }

    public static org.mockito.exceptions.base.MockitoException mocksHaveToBePassedWhenCreatingInOrder()
    {
        org.mockito.exceptions.base.MockitoException $r0;
        java.lang.Object[] $r1;
        java.lang.String $r2;

        $r0 = new org.mockito.exceptions.base.MockitoException;

        $r1 = newarray (java.lang.Object)[4];

        $r1[0] = "Method requires argument(s)!";

        $r1[1] = "Pass mocks that require verification in order.";

        $r1[2] = "For example:";

        $r1[3] = "    InOrder inOrder = inOrder(mockOne, mockTwo);";

        $r2 = staticinvoke <org.mockito.internal.util.StringUtil: java.lang.String join(java.lang.Object[])>($r1);

        specialinvoke $r0.<org.mockito.exceptions.base.MockitoException: void <init>(java.lang.String)>($r2);

        return $r0;
    }

    public static org.mockito.exceptions.base.MockitoException inOrderRequiresFamiliarMock()
    {
        org.mockito.exceptions.base.MockitoException $r0;
        java.lang.Object[] $r1;
        java.lang.String $r2;

        $r0 = new org.mockito.exceptions.base.MockitoException;

        $r1 = newarray (java.lang.Object)[4];

        $r1[0] = "InOrder can only verify mocks that were passed in during creation of InOrder.";

        $r1[1] = "For example:";

        $r1[2] = "    InOrder inOrder = inOrder(mockOne);";

        $r1[3] = "    inOrder.verify(mockOne).doStuff();";

        $r2 = staticinvoke <org.mockito.internal.util.StringUtil: java.lang.String join(java.lang.Object[])>($r1);

        specialinvoke $r0.<org.mockito.exceptions.base.MockitoException: void <init>(java.lang.String)>($r2);

        return $r0;
    }

    public static org.mockito.exceptions.base.MockitoException invalidUseOfMatchers(int, java.util.List)
    {
        int i0, $i1;
        java.util.List r0;
        org.mockito.exceptions.misusing.InvalidUseOfMatchersException $r1;
        java.lang.Object[] $r2;
        java.lang.StringBuilder $r3, $r4, $r5, $r6, $r7, $r9;
        java.lang.Object $r8;
        java.lang.String $r10, $r11;

        i0 := @parameter0: int;

        r0 := @parameter1: java.util.List;

        $r1 = new org.mockito.exceptions.misusing.InvalidUseOfMatchersException;

        $r2 = newarray (java.lang.Object)[13];

        $r2[0] = "Invalid use of argument matchers!";

        $r3 = new java.lang.StringBuilder;

        specialinvoke $r3.<java.lang.StringBuilder: void <init>()>();

        $r4 = virtualinvoke $r3.<java.lang.StringBuilder: java.lang.StringBuilder append(int)>(i0);

        $r5 = virtualinvoke $r4.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>(" matchers expected, ");

        $i1 = interfaceinvoke r0.<java.util.List: int size()>();

        $r6 = virtualinvoke $r5.<java.lang.StringBuilder: java.lang.StringBuilder append(int)>($i1);

        $r7 = virtualinvoke $r6.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>(" recorded:");

        $r8 = staticinvoke <org.mockito.internal.exceptions.Reporter: java.lang.Object locationsOf(java.util.Collection)>(r0);

        $r9 = virtualinvoke $r7.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.Object)>($r8);

        $r10 = virtualinvoke $r9.<java.lang.StringBuilder: java.lang.String toString()>();

        $r2[1] = $r10;

        $r2[2] = "";

        $r2[3] = "This exception may occur if matchers are combined with raw values:";

        $r2[4] = "    //incorrect:";

        $r2[5] = "    someMethod(anyObject(), \"raw String\");";

        $r2[6] = "When using matchers, all arguments have to be provided by matchers.";

        $r2[7] = "For example:";

        $r2[8] = "    //correct:";

        $r2[9] = "    someMethod(anyObject(), eq(\"String by matcher\"));";

        $r2[10] = "";

        $r2[11] = "For more info see javadoc for Matchers class.";

        $r2[12] = "";

        $r11 = staticinvoke <org.mockito.internal.util.StringUtil: java.lang.String join(java.lang.Object[])>($r2);

        specialinvoke $r1.<org.mockito.exceptions.misusing.InvalidUseOfMatchersException: void <init>(java.lang.String)>($r11);

        return $r1;
    }

    public static org.mockito.exceptions.base.MockitoException incorrectUseOfAdditionalMatchers(java.lang.String, int, java.util.Collection)
    {
        java.lang.String r0, $r8, $r15, $r17;
        int i0, $i1;
        java.util.Collection r1;
        org.mockito.exceptions.misusing.InvalidUseOfMatchersException $r2;
        java.lang.Object[] $r3;
        java.lang.StringBuilder $r4, $r5, $r6, $r7, $r10, $r11, $r12, $r13, $r14;
        org.mockito.internal.debugging.LocationImpl $r9;
        java.lang.Object $r16;

        r0 := @parameter0: java.lang.String;

        i0 := @parameter1: int;

        r1 := @parameter2: java.util.Collection;

        $r2 = new org.mockito.exceptions.misusing.InvalidUseOfMatchersException;

        $r3 = newarray (java.lang.Object)[16];

        $r4 = new java.lang.StringBuilder;

        specialinvoke $r4.<java.lang.StringBuilder: void <init>()>();

        $r5 = virtualinvoke $r4.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>("Invalid use of argument matchers inside additional matcher ");

        $r6 = virtualinvoke $r5.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>(r0);

        $r7 = virtualinvoke $r6.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>(" !");

        $r8 = virtualinvoke $r7.<java.lang.StringBuilder: java.lang.String toString()>();

        $r3[0] = $r8;

        $r9 = new org.mockito.internal.debugging.LocationImpl;

        specialinvoke $r9.<org.mockito.internal.debugging.LocationImpl: void <init>()>();

        $r3[1] = $r9;

        $r3[2] = "";

        $r10 = new java.lang.StringBuilder;

        specialinvoke $r10.<java.lang.StringBuilder: void <init>()>();

        $r11 = virtualinvoke $r10.<java.lang.StringBuilder: java.lang.StringBuilder append(int)>(i0);

        $r12 = virtualinvoke $r11.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>(" sub matchers expected, ");

        $i1 = interfaceinvoke r1.<java.util.Collection: int size()>();

        $r13 = virtualinvoke $r12.<java.lang.StringBuilder: java.lang.StringBuilder append(int)>($i1);

        $r14 = virtualinvoke $r13.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>(" recorded:");

        $r15 = virtualinvoke $r14.<java.lang.StringBuilder: java.lang.String toString()>();

        $r3[3] = $r15;

        $r16 = staticinvoke <org.mockito.internal.exceptions.Reporter: java.lang.Object locationsOf(java.util.Collection)>(r1);

        $r3[4] = $r16;

        $r3[5] = "";

        $r3[6] = "This exception may occur if matchers are combined with raw values:";

        $r3[7] = "    //incorrect:";

        $r3[8] = "    someMethod(AdditionalMatchers.and(isNotNull(), \"raw String\");";

        $r3[9] = "When using matchers, all arguments have to be provided by matchers.";

        $r3[10] = "For example:";

        $r3[11] = "    //correct:";

        $r3[12] = "    someMethod(AdditionalMatchers.and(isNotNull(), eq(\"raw String\"));";

        $r3[13] = "";

        $r3[14] = "For more info see javadoc for Matchers and AdditionalMatchers classes.";

        $r3[15] = "";

        $r17 = staticinvoke <org.mockito.internal.util.StringUtil: java.lang.String join(java.lang.Object[])>($r3);

        specialinvoke $r2.<org.mockito.exceptions.misusing.InvalidUseOfMatchersException: void <init>(java.lang.String)>($r17);

        return $r2;
    }

    public static org.mockito.exceptions.base.MockitoException stubPassedToVerify()
    {
        org.mockito.exceptions.misusing.CannotVerifyStubOnlyMock $r0;
        java.lang.Object[] $r1;
        java.lang.String $r2;

        $r0 = new org.mockito.exceptions.misusing.CannotVerifyStubOnlyMock;

        $r1 = newarray (java.lang.Object)[2];

        $r1[0] = "Argument passed to verify() is a stubOnly() mock, not a full blown mock!";

        $r1[1] = "If you intend to verify invocations on a mock, don\'t use stubOnly() in its MockSettings.";

        $r2 = staticinvoke <org.mockito.internal.util.StringUtil: java.lang.String join(java.lang.Object[])>($r1);

        specialinvoke $r0.<org.mockito.exceptions.misusing.CannotVerifyStubOnlyMock: void <init>(java.lang.String)>($r2);

        return $r0;
    }

    public static org.mockito.exceptions.base.MockitoException reportNoSubMatchersFound(java.lang.String)
    {
        java.lang.String r0, $r6, $r8;
        org.mockito.exceptions.misusing.InvalidUseOfMatchersException $r1;
        java.lang.Object[] $r2;
        java.lang.StringBuilder $r3, $r4, $r5;
        org.mockito.internal.debugging.LocationImpl $r7;

        r0 := @parameter0: java.lang.String;

        $r1 = new org.mockito.exceptions.misusing.InvalidUseOfMatchersException;

        $r2 = newarray (java.lang.Object)[3];

        $r3 = new java.lang.StringBuilder;

        specialinvoke $r3.<java.lang.StringBuilder: void <init>()>();

        $r4 = virtualinvoke $r3.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>("No matchers found for additional matcher ");

        $r5 = virtualinvoke $r4.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>(r0);

        $r6 = virtualinvoke $r5.<java.lang.StringBuilder: java.lang.String toString()>();

        $r2[0] = $r6;

        $r7 = new org.mockito.internal.debugging.LocationImpl;

        specialinvoke $r7.<org.mockito.internal.debugging.LocationImpl: void <init>()>();

        $r2[1] = $r7;

        $r2[2] = "";

        $r8 = staticinvoke <org.mockito.internal.util.StringUtil: java.lang.String join(java.lang.Object[])>($r2);

        specialinvoke $r1.<org.mockito.exceptions.misusing.InvalidUseOfMatchersException: void <init>(java.lang.String)>($r8);

        return $r1;
    }

    private static java.lang.Object locationsOf(java.util.Collection)
    {
        java.util.Collection r0;
        java.util.Iterator r2;
        org.mockito.internal.matchers.LocalizedMatcher r3;
        java.util.ArrayList $r4;
        boolean $z0;
        java.lang.Object[] $r5;
        java.lang.String $r6, $r9;
        java.lang.Object $r7;
        org.mockito.invocation.Location $r8;

        r0 := @parameter0: java.util.Collection;

        $r4 = new java.util.ArrayList;

        specialinvoke $r4.<java.util.ArrayList: void <init>()>();

        r2 = interfaceinvoke r0.<java.util.Collection: java.util.Iterator iterator()>();

     label1:
        $z0 = interfaceinvoke r2.<java.util.Iterator: boolean hasNext()>();

        if $z0 == 0 goto label2;

        $r7 = interfaceinvoke r2.<java.util.Iterator: java.lang.Object next()>();

        r3 = (org.mockito.internal.matchers.LocalizedMatcher) $r7;

        $r8 = virtualinvoke r3.<org.mockito.internal.matchers.LocalizedMatcher: org.mockito.invocation.Location getLocation()>();

        $r9 = interfaceinvoke $r8.<org.mockito.invocation.Location: java.lang.String toString()>();

        interfaceinvoke $r4.<java.util.List: boolean add(java.lang.Object)>($r9);

        goto label1;

     label2:
        $r5 = interfaceinvoke $r4.<java.util.List: java.lang.Object[] toArray()>();

        $r6 = staticinvoke <org.mockito.internal.util.StringUtil: java.lang.String join(java.lang.Object[])>($r5);

        return $r6;
    }

    public static java.lang.AssertionError argumentsAreDifferent(java.lang.String, java.lang.String, org.mockito.invocation.Location)
    {
        java.lang.String r0, r1, r3;
        org.mockito.invocation.Location r2;
        java.lang.Object[] $r4;
        org.mockito.internal.debugging.LocationImpl $r5;
        java.lang.AssertionError $r6;

        r0 := @parameter0: java.lang.String;

        r1 := @parameter1: java.lang.String;

        r2 := @parameter2: org.mockito.invocation.Location;

        $r4 = newarray (java.lang.Object)[7];

        $r4[0] = "Argument(s) are different! Wanted:";

        $r4[1] = r0;

        $r5 = new org.mockito.internal.debugging.LocationImpl;

        specialinvoke $r5.<org.mockito.internal.debugging.LocationImpl: void <init>()>();

        $r4[2] = $r5;

        $r4[3] = "Actual invocation has different arguments:";

        $r4[4] = r1;

        $r4[5] = r2;

        $r4[6] = "";

        r3 = staticinvoke <org.mockito.internal.util.StringUtil: java.lang.String join(java.lang.Object[])>($r4);

        $r6 = staticinvoke <org.mockito.internal.junit.ExceptionFactory: java.lang.AssertionError createArgumentsAreDifferentException(java.lang.String,java.lang.String,java.lang.String)>(r3, r0, r1);

        return $r6;
    }

    public static org.mockito.exceptions.base.MockitoAssertionError wantedButNotInvoked(org.mockito.invocation.DescribedInvocation)
    {
        org.mockito.invocation.DescribedInvocation r0;
        org.mockito.exceptions.verification.WantedButNotInvoked $r1;
        java.lang.String $r2;

        r0 := @parameter0: org.mockito.invocation.DescribedInvocation;

        $r1 = new org.mockito.exceptions.verification.WantedButNotInvoked;

        $r2 = staticinvoke <org.mockito.internal.exceptions.Reporter: java.lang.String createWantedButNotInvokedMessage(org.mockito.invocation.DescribedInvocation)>(r0);

        specialinvoke $r1.<org.mockito.exceptions.verification.WantedButNotInvoked: void <init>(java.lang.String)>($r2);

        return $r1;
    }

    public static org.mockito.exceptions.base.MockitoAssertionError wantedButNotInvoked(org.mockito.invocation.DescribedInvocation, java.util.List)
    {
        org.mockito.invocation.DescribedInvocation r0, r3;
        java.util.List r1;
        java.util.Iterator r2;
        boolean $z0, $z1;
        java.lang.StringBuilder $r4, $r5, $r6, $r8, $r9, $r12, $r13, $r14, $r18, $r19, $r21;
        int $i0;
        java.lang.String $r7, $r10, $r15, $r17, r23, r25;
        org.mockito.exceptions.verification.WantedButNotInvoked $r11;
        java.lang.Object $r16;
        org.mockito.invocation.Location $r20;

        r0 := @parameter0: org.mockito.invocation.DescribedInvocation;

        r1 := @parameter1: java.util.List;

        $z0 = interfaceinvoke r1.<java.util.List: boolean isEmpty()>();

        if $z0 == 0 goto label1;

        r23 = "Actually, there were zero interactions with this mock.\n";

        goto label4;

     label1:
        $r4 = new java.lang.StringBuilder;

        $r5 = new java.lang.StringBuilder;

        specialinvoke $r5.<java.lang.StringBuilder: void <init>()>();

        $r6 = virtualinvoke $r5.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>("\nHowever, there ");

        $i0 = interfaceinvoke r1.<java.util.List: int size()>();

        $r7 = staticinvoke <org.mockito.internal.reporting.Pluralizer: java.lang.String were_exactly_x_interactions(int)>($i0);

        $r8 = virtualinvoke $r6.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>($r7);

        $r9 = virtualinvoke $r8.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>(" with this mock:\n");

        $r10 = virtualinvoke $r9.<java.lang.StringBuilder: java.lang.String toString()>();

        specialinvoke $r4.<java.lang.StringBuilder: void <init>(java.lang.String)>($r10);

        r2 = interfaceinvoke r1.<java.util.List: java.util.Iterator iterator()>();

     label2:
        $z1 = interfaceinvoke r2.<java.util.Iterator: boolean hasNext()>();

        if $z1 == 0 goto label3;

        $r16 = interfaceinvoke r2.<java.util.Iterator: java.lang.Object next()>();

        r3 = (org.mockito.invocation.DescribedInvocation) $r16;

        $r17 = interfaceinvoke r3.<org.mockito.invocation.DescribedInvocation: java.lang.String toString()>();

        $r18 = virtualinvoke $r4.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>($r17);

        $r19 = virtualinvoke $r18.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>("\n");

        $r20 = interfaceinvoke r3.<org.mockito.invocation.DescribedInvocation: org.mockito.invocation.Location getLocation()>();

        $r21 = virtualinvoke $r19.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.Object)>($r20);

        virtualinvoke $r21.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>("\n\n");

        goto label2;

     label3:
        r23 = virtualinvoke $r4.<java.lang.StringBuilder: java.lang.String toString()>();

     label4:
        r25 = staticinvoke <org.mockito.internal.exceptions.Reporter: java.lang.String createWantedButNotInvokedMessage(org.mockito.invocation.DescribedInvocation)>(r0);

        $r11 = new org.mockito.exceptions.verification.WantedButNotInvoked;

        $r12 = new java.lang.StringBuilder;

        specialinvoke $r12.<java.lang.StringBuilder: void <init>()>();

        $r13 = virtualinvoke $r12.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>(r25);

        $r14 = virtualinvoke $r13.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>(r23);

        $r15 = virtualinvoke $r14.<java.lang.StringBuilder: java.lang.String toString()>();

        specialinvoke $r11.<org.mockito.exceptions.verification.WantedButNotInvoked: void <init>(java.lang.String)>($r15);

        return $r11;
    }

    private static java.lang.String createWantedButNotInvokedMessage(org.mockito.invocation.DescribedInvocation)
    {
        org.mockito.invocation.DescribedInvocation r0;
        java.lang.Object[] $r1;
        java.lang.String $r2, $r4;
        org.mockito.internal.debugging.LocationImpl $r3;

        r0 := @parameter0: org.mockito.invocation.DescribedInvocation;

        $r1 = newarray (java.lang.Object)[4];

        $r1[0] = "Wanted but not invoked:";

        $r2 = interfaceinvoke r0.<org.mockito.invocation.DescribedInvocation: java.lang.String toString()>();

        $r1[1] = $r2;

        $r3 = new org.mockito.internal.debugging.LocationImpl;

        specialinvoke $r3.<org.mockito.internal.debugging.LocationImpl: void <init>()>();

        $r1[2] = $r3;

        $r1[3] = "";

        $r4 = staticinvoke <org.mockito.internal.util.StringUtil: java.lang.String join(java.lang.Object[])>($r1);

        return $r4;
    }

    public static org.mockito.exceptions.base.MockitoAssertionError wantedButNotInvokedInOrder(org.mockito.invocation.DescribedInvocation, org.mockito.invocation.DescribedInvocation)
    {
        org.mockito.invocation.DescribedInvocation r0, r1;
        org.mockito.exceptions.verification.VerificationInOrderFailure $r2;
        java.lang.Object[] $r3;
        java.lang.String $r4, $r6, $r8;
        org.mockito.internal.debugging.LocationImpl $r5;
        org.mockito.invocation.Location $r7;

        r0 := @parameter0: org.mockito.invocation.DescribedInvocation;

        r1 := @parameter1: org.mockito.invocation.DescribedInvocation;

        $r2 = new org.mockito.exceptions.verification.VerificationInOrderFailure;

        $r3 = newarray (java.lang.Object)[8];

        $r3[0] = "Verification in order failure";

        $r3[1] = "Wanted but not invoked:";

        $r4 = interfaceinvoke r0.<org.mockito.invocation.DescribedInvocation: java.lang.String toString()>();

        $r3[2] = $r4;

        $r5 = new org.mockito.internal.debugging.LocationImpl;

        specialinvoke $r5.<org.mockito.internal.debugging.LocationImpl: void <init>()>();

        $r3[3] = $r5;

        $r3[4] = "Wanted anywhere AFTER following interaction:";

        $r6 = interfaceinvoke r1.<org.mockito.invocation.DescribedInvocation: java.lang.String toString()>();

        $r3[5] = $r6;

        $r7 = interfaceinvoke r1.<org.mockito.invocation.DescribedInvocation: org.mockito.invocation.Location getLocation()>();

        $r3[6] = $r7;

        $r3[7] = "";

        $r8 = staticinvoke <org.mockito.internal.util.StringUtil: java.lang.String join(java.lang.Object[])>($r3);

        specialinvoke $r2.<org.mockito.exceptions.verification.VerificationInOrderFailure: void <init>(java.lang.String)>($r8);

        return $r2;
    }

    public static org.mockito.exceptions.base.MockitoAssertionError tooManyActualInvocations(int, int, org.mockito.invocation.DescribedInvocation, java.util.List)
    {
        int i0, i1;
        org.mockito.invocation.DescribedInvocation r0;
        java.util.List r1;
        java.lang.String r2;
        org.mockito.exceptions.verification.TooManyActualInvocations $r3;

        i0 := @parameter0: int;

        i1 := @parameter1: int;

        r0 := @parameter2: org.mockito.invocation.DescribedInvocation;

        r1 := @parameter3: java.util.List;

        r2 = staticinvoke <org.mockito.internal.exceptions.Reporter: java.lang.String createTooManyInvocationsMessage(int,int,org.mockito.invocation.DescribedInvocation,java.util.List)>(i0, i1, r0, r1);

        $r3 = new org.mockito.exceptions.verification.TooManyActualInvocations;

        specialinvoke $r3.<org.mockito.exceptions.verification.TooManyActualInvocations: void <init>(java.lang.String)>(r2);

        return $r3;
    }

    private static java.lang.String createTooManyInvocationsMessage(int, int, org.mockito.invocation.DescribedInvocation, java.util.List)
    {
        int i0, i1;
        org.mockito.invocation.DescribedInvocation r0;
        java.util.List r1;
        java.lang.Object[] $r2;
        java.lang.String $r3, $r6, $r9, $r13, $r16, $r17, $r18;
        java.lang.StringBuilder $r4, $r5, $r7, $r8, $r11, $r12, $r14, $r15;
        org.mockito.internal.debugging.LocationImpl $r10;

        i0 := @parameter0: int;

        i1 := @parameter1: int;

        r0 := @parameter2: org.mockito.invocation.DescribedInvocation;

        r1 := @parameter3: java.util.List;

        $r2 = newarray (java.lang.Object)[6];

        $r3 = interfaceinvoke r0.<org.mockito.invocation.DescribedInvocation: java.lang.String toString()>();

        $r2[0] = $r3;

        $r4 = new java.lang.StringBuilder;

        specialinvoke $r4.<java.lang.StringBuilder: void <init>()>();

        $r5 = virtualinvoke $r4.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>("Wanted ");

        $r6 = staticinvoke <org.mockito.internal.reporting.Pluralizer: java.lang.String pluralize(int)>(i0);

        $r7 = virtualinvoke $r5.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>($r6);

        $r8 = virtualinvoke $r7.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>(":");

        $r9 = virtualinvoke $r8.<java.lang.StringBuilder: java.lang.String toString()>();

        $r2[1] = $r9;

        $r10 = new org.mockito.internal.debugging.LocationImpl;

        specialinvoke $r10.<org.mockito.internal.debugging.LocationImpl: void <init>()>();

        $r2[2] = $r10;

        $r11 = new java.lang.StringBuilder;

        specialinvoke $r11.<java.lang.StringBuilder: void <init>()>();

        $r12 = virtualinvoke $r11.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>("But was ");

        $r13 = staticinvoke <org.mockito.internal.reporting.Pluralizer: java.lang.String pluralize(int)>(i1);

        $r14 = virtualinvoke $r12.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>($r13);

        $r15 = virtualinvoke $r14.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>(":");

        $r16 = virtualinvoke $r15.<java.lang.StringBuilder: java.lang.String toString()>();

        $r2[3] = $r16;

        $r17 = staticinvoke <org.mockito.internal.exceptions.Reporter: java.lang.String createAllLocationsMessage(java.util.List)>(r1);

        $r2[4] = $r17;

        $r2[5] = "";

        $r18 = staticinvoke <org.mockito.internal.util.StringUtil: java.lang.String join(java.lang.Object[])>($r2);

        return $r18;
    }

    public static org.mockito.exceptions.base.MockitoAssertionError neverWantedButInvoked(org.mockito.invocation.DescribedInvocation, java.util.List)
    {
        org.mockito.invocation.DescribedInvocation r0;
        java.util.List r1;
        org.mockito.exceptions.verification.NeverWantedButInvoked $r2;
        java.lang.Object[] $r3;
        java.lang.String $r4, $r6, $r7;
        org.mockito.internal.debugging.LocationImpl $r5;

        r0 := @parameter0: org.mockito.invocation.DescribedInvocation;

        r1 := @parameter1: java.util.List;

        $r2 = new org.mockito.exceptions.verification.NeverWantedButInvoked;

        $r3 = newarray (java.lang.Object)[5];

        $r4 = interfaceinvoke r0.<org.mockito.invocation.DescribedInvocation: java.lang.String toString()>();

        $r3[0] = $r4;

        $r3[1] = "Never wanted here:";

        $r5 = new org.mockito.internal.debugging.LocationImpl;

        specialinvoke $r5.<org.mockito.internal.debugging.LocationImpl: void <init>()>();

        $r3[2] = $r5;

        $r3[3] = "But invoked here:";

        $r6 = staticinvoke <org.mockito.internal.exceptions.Reporter: java.lang.String createAllLocationsMessage(java.util.List)>(r1);

        $r3[4] = $r6;

        $r7 = staticinvoke <org.mockito.internal.util.StringUtil: java.lang.String join(java.lang.Object[])>($r3);

        specialinvoke $r2.<org.mockito.exceptions.verification.NeverWantedButInvoked: void <init>(java.lang.String)>($r7);

        return $r2;
    }

    public static org.mockito.exceptions.base.MockitoAssertionError tooManyActualInvocationsInOrder(int, int, org.mockito.invocation.DescribedInvocation, java.util.List)
    {
        int i0, i1;
        org.mockito.invocation.DescribedInvocation r0;
        java.util.List r1;
        java.lang.String r2, $r8, $r9;
        org.mockito.exceptions.verification.VerificationInOrderFailure $r3;
        java.lang.Object[] $r4;
        java.lang.StringBuilder $r5, $r6, $r7;

        i0 := @parameter0: int;

        i1 := @parameter1: int;

        r0 := @parameter2: org.mockito.invocation.DescribedInvocation;

        r1 := @parameter3: java.util.List;

        r2 = staticinvoke <org.mockito.internal.exceptions.Reporter: java.lang.String createTooManyInvocationsMessage(int,int,org.mockito.invocation.DescribedInvocation,java.util.List)>(i0, i1, r0, r1);

        $r3 = new org.mockito.exceptions.verification.VerificationInOrderFailure;

        $r4 = newarray (java.lang.Object)[1];

        $r5 = new java.lang.StringBuilder;

        specialinvoke $r5.<java.lang.StringBuilder: void <init>()>();

        $r6 = virtualinvoke $r5.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>("Verification in order failure:");

        $r7 = virtualinvoke $r6.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>(r2);

        $r8 = virtualinvoke $r7.<java.lang.StringBuilder: java.lang.String toString()>();

        $r4[0] = $r8;

        $r9 = staticinvoke <org.mockito.internal.util.StringUtil: java.lang.String join(java.lang.Object[])>($r4);

        specialinvoke $r3.<org.mockito.exceptions.verification.VerificationInOrderFailure: void <init>(java.lang.String)>($r9);

        return $r3;
    }

    private static java.lang.String createAllLocationsMessage(java.util.List)
    {
        java.util.List r0;
        java.util.Iterator r2;
        org.mockito.invocation.Location r3;
        java.lang.StringBuilder $r4, $r7;
        boolean $z0;
        java.lang.String $r5;
        java.lang.Object $r6;

        r0 := @parameter0: java.util.List;

        if r0 != null goto label1;

        return "\n";

     label1:
        $r4 = new java.lang.StringBuilder;

        specialinvoke $r4.<java.lang.StringBuilder: void <init>()>();

        r2 = interfaceinvoke r0.<java.util.List: java.util.Iterator iterator()>();

     label2:
        $z0 = interfaceinvoke r2.<java.util.Iterator: boolean hasNext()>();

        if $z0 == 0 goto label3;

        $r6 = interfaceinvoke r2.<java.util.Iterator: java.lang.Object next()>();

        r3 = (org.mockito.invocation.Location) $r6;

        $r7 = virtualinvoke $r4.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.Object)>(r3);

        virtualinvoke $r7.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>("\n");

        goto label2;

     label3:
        $r5 = virtualinvoke $r4.<java.lang.StringBuilder: java.lang.String toString()>();

        return $r5;
    }

    private static java.lang.String createTooLittleInvocationsMessage(org.mockito.internal.reporting.Discrepancy, org.mockito.invocation.DescribedInvocation, java.util.List)
    {
        org.mockito.internal.reporting.Discrepancy r0;
        org.mockito.invocation.DescribedInvocation r1;
        java.util.List r2;
        java.lang.Object[] $r3;
        java.lang.String $r4, $r7, $r10, $r14, $r17, $r18, $r19, $r20, $r21;
        java.lang.StringBuilder $r5, $r6, $r8, $r9, $r12, $r13, $r15, $r16;
        int $i1, $i3;
        org.mockito.internal.debugging.LocationImpl $r11;

        r0 := @parameter0: org.mockito.internal.reporting.Discrepancy;

        r1 := @parameter1: org.mockito.invocation.DescribedInvocation;

        r2 := @parameter2: java.util.List;

        $r3 = newarray (java.lang.Object)[5];

        $r4 = interfaceinvoke r1.<org.mockito.invocation.DescribedInvocation: java.lang.String toString()>();

        $r3[0] = $r4;

        $r5 = new java.lang.StringBuilder;

        specialinvoke $r5.<java.lang.StringBuilder: void <init>()>();

        $r6 = virtualinvoke $r5.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>("Wanted ");

        $r7 = virtualinvoke r0.<org.mockito.internal.reporting.Discrepancy: java.lang.String getPluralizedWantedCount()>();

        $r8 = virtualinvoke $r6.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>($r7);

        $i1 = virtualinvoke r0.<org.mockito.internal.reporting.Discrepancy: int getWantedCount()>();

        if $i1 != 0 goto label1;

        $r20 = ".";

        goto label2;

     label1:
        $r20 = ":";

     label2:
        $r9 = virtualinvoke $r8.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>($r20);

        $r10 = virtualinvoke $r9.<java.lang.StringBuilder: java.lang.String toString()>();

        $r3[1] = $r10;

        $r11 = new org.mockito.internal.debugging.LocationImpl;

        specialinvoke $r11.<org.mockito.internal.debugging.LocationImpl: void <init>()>();

        $r3[2] = $r11;

        $r12 = new java.lang.StringBuilder;

        specialinvoke $r12.<java.lang.StringBuilder: void <init>()>();

        $r13 = virtualinvoke $r12.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>("But was ");

        $r14 = virtualinvoke r0.<org.mockito.internal.reporting.Discrepancy: java.lang.String getPluralizedActualCount()>();

        $r15 = virtualinvoke $r13.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>($r14);

        $i3 = virtualinvoke r0.<org.mockito.internal.reporting.Discrepancy: int getActualCount()>();

        if $i3 != 0 goto label3;

        $r21 = ".";

        goto label4;

     label3:
        $r21 = ":";

     label4:
        $r16 = virtualinvoke $r15.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>($r21);

        $r17 = virtualinvoke $r16.<java.lang.StringBuilder: java.lang.String toString()>();

        $r3[3] = $r17;

        $r18 = staticinvoke <org.mockito.internal.exceptions.Reporter: java.lang.String createAllLocationsMessage(java.util.List)>(r2);

        $r3[4] = $r18;

        $r19 = staticinvoke <org.mockito.internal.util.StringUtil: java.lang.String join(java.lang.Object[])>($r3);

        return $r19;
    }

    public static org.mockito.exceptions.base.MockitoAssertionError tooLittleActualInvocations(org.mockito.internal.reporting.Discrepancy, org.mockito.invocation.DescribedInvocation, java.util.List)
    {
        org.mockito.internal.reporting.Discrepancy r0;
        org.mockito.invocation.DescribedInvocation r1;
        java.util.List r2;
        java.lang.String r3;
        org.mockito.exceptions.verification.TooLittleActualInvocations $r4;

        r0 := @parameter0: org.mockito.internal.reporting.Discrepancy;

        r1 := @parameter1: org.mockito.invocation.DescribedInvocation;

        r2 := @parameter2: java.util.List;

        r3 = staticinvoke <org.mockito.internal.exceptions.Reporter: java.lang.String createTooLittleInvocationsMessage(org.mockito.internal.reporting.Discrepancy,org.mockito.invocation.DescribedInvocation,java.util.List)>(r0, r1, r2);

        $r4 = new org.mockito.exceptions.verification.TooLittleActualInvocations;

        specialinvoke $r4.<org.mockito.exceptions.verification.TooLittleActualInvocations: void <init>(java.lang.String)>(r3);

        return $r4;
    }

    public static org.mockito.exceptions.base.MockitoAssertionError tooLittleActualInvocationsInOrder(org.mockito.internal.reporting.Discrepancy, org.mockito.invocation.DescribedInvocation, java.util.List)
    {
        org.mockito.internal.reporting.Discrepancy r0;
        org.mockito.invocation.DescribedInvocation r1;
        java.util.List r2;
        java.lang.String r3, $r9, $r10;
        org.mockito.exceptions.verification.VerificationInOrderFailure $r4;
        java.lang.Object[] $r5;
        java.lang.StringBuilder $r6, $r7, $r8;

        r0 := @parameter0: org.mockito.internal.reporting.Discrepancy;

        r1 := @parameter1: org.mockito.invocation.DescribedInvocation;

        r2 := @parameter2: java.util.List;

        r3 = staticinvoke <org.mockito.internal.exceptions.Reporter: java.lang.String createTooLittleInvocationsMessage(org.mockito.internal.reporting.Discrepancy,org.mockito.invocation.DescribedInvocation,java.util.List)>(r0, r1, r2);

        $r4 = new org.mockito.exceptions.verification.VerificationInOrderFailure;

        $r5 = newarray (java.lang.Object)[1];

        $r6 = new java.lang.StringBuilder;

        specialinvoke $r6.<java.lang.StringBuilder: void <init>()>();

        $r7 = virtualinvoke $r6.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>("Verification in order failure:");

        $r8 = virtualinvoke $r7.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>(r3);

        $r9 = virtualinvoke $r8.<java.lang.StringBuilder: java.lang.String toString()>();

        $r5[0] = $r9;

        $r10 = staticinvoke <org.mockito.internal.util.StringUtil: java.lang.String join(java.lang.Object[])>($r5);

        specialinvoke $r4.<org.mockito.exceptions.verification.VerificationInOrderFailure: void <init>(java.lang.String)>($r10);

        return $r4;
    }

    public static org.mockito.exceptions.base.MockitoAssertionError noMoreInteractionsWanted(org.mockito.invocation.Invocation, java.util.List)
    {
        org.mockito.invocation.Invocation r0;
        java.util.List r1;
        java.lang.String r3, $r14, $r16;
        org.mockito.internal.exceptions.util.ScenarioPrinter $r4;
        org.mockito.exceptions.verification.NoInteractionsWanted $r5;
        java.lang.Object[] $r6;
        org.mockito.internal.debugging.LocationImpl $r7;
        java.lang.StringBuilder $r8, $r9, $r12, $r13;
        java.lang.Object $r10;
        org.mockito.mock.MockName $r11;
        org.mockito.invocation.Location $r15;

        r0 := @parameter0: org.mockito.invocation.Invocation;

        r1 := @parameter1: java.util.List;

        $r4 = new org.mockito.internal.exceptions.util.ScenarioPrinter;

        specialinvoke $r4.<org.mockito.internal.exceptions.util.ScenarioPrinter: void <init>()>();

        r3 = virtualinvoke $r4.<org.mockito.internal.exceptions.util.ScenarioPrinter: java.lang.String print(java.util.List)>(r1);

        $r5 = new org.mockito.exceptions.verification.NoInteractionsWanted;

        $r6 = newarray (java.lang.Object)[5];

        $r6[0] = "No interactions wanted here:";

        $r7 = new org.mockito.internal.debugging.LocationImpl;

        specialinvoke $r7.<org.mockito.internal.debugging.LocationImpl: void <init>()>();

        $r6[1] = $r7;

        $r8 = new java.lang.StringBuilder;

        specialinvoke $r8.<java.lang.StringBuilder: void <init>()>();

        $r9 = virtualinvoke $r8.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>("But found this interaction on mock \'");

        $r10 = interfaceinvoke r0.<org.mockito.invocation.Invocation: java.lang.Object getMock()>();

        $r11 = staticinvoke <org.mockito.internal.exceptions.Reporter: org.mockito.mock.MockName safelyGetMockName(java.lang.Object)>($r10);

        $r12 = virtualinvoke $r9.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.Object)>($r11);

        $r13 = virtualinvoke $r12.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>("\':");

        $r14 = virtualinvoke $r13.<java.lang.StringBuilder: java.lang.String toString()>();

        $r6[2] = $r14;

        $r15 = interfaceinvoke r0.<org.mockito.invocation.Invocation: org.mockito.invocation.Location getLocation()>();

        $r6[3] = $r15;

        $r6[4] = r3;

        $r16 = staticinvoke <org.mockito.internal.util.StringUtil: java.lang.String join(java.lang.Object[])>($r6);

        specialinvoke $r5.<org.mockito.exceptions.verification.NoInteractionsWanted: void <init>(java.lang.String)>($r16);

        return $r5;
    }

    public static org.mockito.exceptions.base.MockitoAssertionError noMoreInteractionsWantedInOrder(org.mockito.invocation.Invocation)
    {
        org.mockito.invocation.Invocation r0;
        org.mockito.exceptions.verification.VerificationInOrderFailure $r1;
        java.lang.Object[] $r2;
        org.mockito.internal.debugging.LocationImpl $r3;
        java.lang.StringBuilder $r4, $r5, $r8, $r9;
        java.lang.Object $r6;
        org.mockito.mock.MockName $r7;
        java.lang.String $r10, $r12;
        org.mockito.invocation.Location $r11;

        r0 := @parameter0: org.mockito.invocation.Invocation;

        $r1 = new org.mockito.exceptions.verification.VerificationInOrderFailure;

        $r2 = newarray (java.lang.Object)[4];

        $r2[0] = "No interactions wanted here:";

        $r3 = new org.mockito.internal.debugging.LocationImpl;

        specialinvoke $r3.<org.mockito.internal.debugging.LocationImpl: void <init>()>();

        $r2[1] = $r3;

        $r4 = new java.lang.StringBuilder;

        specialinvoke $r4.<java.lang.StringBuilder: void <init>()>();

        $r5 = virtualinvoke $r4.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>("But found this interaction on mock \'");

        $r6 = interfaceinvoke r0.<org.mockito.invocation.Invocation: java.lang.Object getMock()>();

        $r7 = staticinvoke <org.mockito.internal.exceptions.Reporter: org.mockito.mock.MockName safelyGetMockName(java.lang.Object)>($r6);

        $r8 = virtualinvoke $r5.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.Object)>($r7);

        $r9 = virtualinvoke $r8.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>("\':");

        $r10 = virtualinvoke $r9.<java.lang.StringBuilder: java.lang.String toString()>();

        $r2[2] = $r10;

        $r11 = interfaceinvoke r0.<org.mockito.invocation.Invocation: org.mockito.invocation.Location getLocation()>();

        $r2[3] = $r11;

        $r12 = staticinvoke <org.mockito.internal.util.StringUtil: java.lang.String join(java.lang.Object[])>($r2);

        specialinvoke $r1.<org.mockito.exceptions.verification.VerificationInOrderFailure: void <init>(java.lang.String)>($r12);

        return $r1;
    }

    public static org.mockito.exceptions.base.MockitoException cannotMockClass(java.lang.Class, java.lang.String)
    {
        java.lang.Class r0;
        java.lang.String r1, $r6, $r8, $r12, $r13;
        org.mockito.exceptions.base.MockitoException $r2;
        java.lang.Object[] $r3;
        java.lang.StringBuilder $r4, $r5, $r7, $r9, $r10, $r11;

        r0 := @parameter0: java.lang.Class;

        r1 := @parameter1: java.lang.String;

        $r2 = new org.mockito.exceptions.base.MockitoException;

        $r3 = newarray (java.lang.Object)[3];

        $r4 = new java.lang.StringBuilder;

        specialinvoke $r4.<java.lang.StringBuilder: void <init>()>();

        $r5 = virtualinvoke $r4.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>("Cannot mock/spy ");

        $r6 = virtualinvoke r0.<java.lang.Class: java.lang.String toString()>();

        $r7 = virtualinvoke $r5.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>($r6);

        $r8 = virtualinvoke $r7.<java.lang.StringBuilder: java.lang.String toString()>();

        $r3[0] = $r8;

        $r3[1] = "Mockito cannot mock/spy because :";

        $r9 = new java.lang.StringBuilder;

        specialinvoke $r9.<java.lang.StringBuilder: void <init>()>();

        $r10 = virtualinvoke $r9.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>(" - ");

        $r11 = virtualinvoke $r10.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>(r1);

        $r12 = virtualinvoke $r11.<java.lang.StringBuilder: java.lang.String toString()>();

        $r3[2] = $r12;

        $r13 = staticinvoke <org.mockito.internal.util.StringUtil: java.lang.String join(java.lang.Object[])>($r3);

        specialinvoke $r2.<org.mockito.exceptions.base.MockitoException: void <init>(java.lang.String)>($r13);

        return $r2;
    }

    public static org.mockito.exceptions.base.MockitoException cannotStubVoidMethodWithAReturnValue(java.lang.String)
    {
        java.lang.String r0, $r7, $r8;
        org.mockito.exceptions.misusing.CannotStubVoidMethodWithReturnValue $r1;
        java.lang.Object[] $r2;
        java.lang.StringBuilder $r3, $r4, $r5, $r6;

        r0 := @parameter0: java.lang.String;

        $r1 = new org.mockito.exceptions.misusing.CannotStubVoidMethodWithReturnValue;

        $r2 = newarray (java.lang.Object)[15];

        $r3 = new java.lang.StringBuilder;

        specialinvoke $r3.<java.lang.StringBuilder: void <init>()>();

        $r4 = virtualinvoke $r3.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>("\'");

        $r5 = virtualinvoke $r4.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>(r0);

        $r6 = virtualinvoke $r5.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>("\' is a *void method* and it *cannot* be stubbed with a *return value*!");

        $r7 = virtualinvoke $r6.<java.lang.StringBuilder: java.lang.String toString()>();

        $r2[0] = $r7;

        $r2[1] = "Voids are usually stubbed with Throwables:";

        $r2[2] = "    doThrow(exception).when(mock).someVoidMethod();";

        $r2[3] = "If you need to set the void method to do nothing you can use:";

        $r2[4] = "    doNothing().when(mock).someVoidMethod();";

        $r2[5] = "For more information, check out the javadocs for Mockito.doNothing().";

        $r2[6] = "***";

        $r2[7] = "If you\'re unsure why you\'re getting above error read on.";

        $r2[8] = "Due to the nature of the syntax above problem might occur because:";

        $r2[9] = "1. The method you are trying to stub is *overloaded*. Make sure you are calling the right overloaded version.";

        $r2[10] = "2. Somewhere in your test you are stubbing *final methods*. Sorry, Mockito does not verify/stub final methods.";

        $r2[11] = "3. A spy is stubbed using when(spy.foo()).then() syntax. It is safer to stub spies - ";

        $r2[12] = "   - with doReturn|Throw() family of methods. More in javadocs for Mockito.spy() method.";

        $r2[13] = "4. Mocking methods declared on non-public parent classes is not supported.";

        $r2[14] = "";

        $r8 = staticinvoke <org.mockito.internal.util.StringUtil: java.lang.String join(java.lang.Object[])>($r2);

        specialinvoke $r1.<org.mockito.exceptions.misusing.CannotStubVoidMethodWithReturnValue: void <init>(java.lang.String)>($r8);

        return $r1;
    }

    public static org.mockito.exceptions.base.MockitoException onlyVoidMethodsCanBeSetToDoNothing()
    {
        org.mockito.exceptions.base.MockitoException $r0;
        java.lang.Object[] $r1;
        java.lang.String $r2;

        $r0 = new org.mockito.exceptions.base.MockitoException;

        $r1 = newarray (java.lang.Object)[7];

        $r1[0] = "Only void methods can doNothing()!";

        $r1[1] = "Example of correct use of doNothing():";

        $r1[2] = "    doNothing().";

        $r1[3] = "    doThrow(new RuntimeException())";

        $r1[4] = "    .when(mock).someVoidMethod();";

        $r1[5] = "Above means:";

        $r1[6] = "someVoidMethod() does nothing the 1st time but throws an exception the 2nd time is called";

        $r2 = staticinvoke <org.mockito.internal.util.StringUtil: java.lang.String join(java.lang.Object[])>($r1);

        specialinvoke $r0.<org.mockito.exceptions.base.MockitoException: void <init>(java.lang.String)>($r2);

        return $r0;
    }

    public static org.mockito.exceptions.base.MockitoException wrongTypeOfReturnValue(java.lang.String, java.lang.String, java.lang.String)
    {
        java.lang.String r0, r1, r2, $r10, $r15, $r16;
        org.mockito.exceptions.misusing.WrongTypeOfReturnValue $r3;
        java.lang.Object[] $r4;
        java.lang.StringBuilder $r5, $r6, $r7, $r8, $r9, $r11, $r12, $r13, $r14;

        r0 := @parameter0: java.lang.String;

        r1 := @parameter1: java.lang.String;

        r2 := @parameter2: java.lang.String;

        $r3 = new org.mockito.exceptions.misusing.WrongTypeOfReturnValue;

        $r4 = newarray (java.lang.Object)[10];

        $r5 = new java.lang.StringBuilder;

        specialinvoke $r5.<java.lang.StringBuilder: void <init>()>();

        $r6 = virtualinvoke $r5.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>(r1);

        $r7 = virtualinvoke $r6.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>(" cannot be returned by ");

        $r8 = virtualinvoke $r7.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>(r2);

        $r9 = virtualinvoke $r8.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>("()");

        $r10 = virtualinvoke $r9.<java.lang.StringBuilder: java.lang.String toString()>();

        $r4[0] = $r10;

        $r11 = new java.lang.StringBuilder;

        specialinvoke $r11.<java.lang.StringBuilder: void <init>()>();

        $r12 = virtualinvoke $r11.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>(r2);

        $r13 = virtualinvoke $r12.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>("() should return ");

        $r14 = virtualinvoke $r13.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>(r0);

        $r15 = virtualinvoke $r14.<java.lang.StringBuilder: java.lang.String toString()>();

        $r4[1] = $r15;

        $r4[2] = "***";

        $r4[3] = "If you\'re unsure why you\'re getting above error read on.";

        $r4[4] = "Due to the nature of the syntax above problem might occur because:";

        $r4[5] = "1. This exception *might* occur in wrongly written multi-threaded tests.";

        $r4[6] = "   Please refer to Mockito FAQ on limitations of concurrency testing.";

        $r4[7] = "2. A spy is stubbed using when(spy.foo()).then() syntax. It is safer to stub spies - ";

        $r4[8] = "   - with doReturn|Throw() family of methods. More in javadocs for Mockito.spy() method.";

        $r4[9] = "";

        $r16 = staticinvoke <org.mockito.internal.util.StringUtil: java.lang.String join(java.lang.Object[])>($r4);

        specialinvoke $r3.<org.mockito.exceptions.misusing.WrongTypeOfReturnValue: void <init>(java.lang.String)>($r16);

        return $r3;
    }

    public static org.mockito.exceptions.base.MockitoException wrongTypeReturnedByDefaultAnswer(java.lang.Object, java.lang.String, java.lang.String, java.lang.String)
    {
        java.lang.Object r0;
        java.lang.String r1, r2, r3, $r11, $r16, $r22, $r23;
        org.mockito.exceptions.misusing.WrongTypeOfReturnValue $r4;
        java.lang.Object[] $r5;
        java.lang.StringBuilder $r6, $r7, $r8, $r9, $r10, $r12, $r13, $r14, $r15, $r17, $r18, $r20, $r21;
        org.mockito.mock.MockName $r19;

        r0 := @parameter0: java.lang.Object;

        r1 := @parameter1: java.lang.String;

        r2 := @parameter2: java.lang.String;

        r3 := @parameter3: java.lang.String;

        $r4 = new org.mockito.exceptions.misusing.WrongTypeOfReturnValue;

        $r5 = newarray (java.lang.Object)[6];

        $r5[0] = "Default answer returned a result with the wrong type:";

        $r6 = new java.lang.StringBuilder;

        specialinvoke $r6.<java.lang.StringBuilder: void <init>()>();

        $r7 = virtualinvoke $r6.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>(r2);

        $r8 = virtualinvoke $r7.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>(" cannot be returned by ");

        $r9 = virtualinvoke $r8.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>(r3);

        $r10 = virtualinvoke $r9.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>("()");

        $r11 = virtualinvoke $r10.<java.lang.StringBuilder: java.lang.String toString()>();

        $r5[1] = $r11;

        $r12 = new java.lang.StringBuilder;

        specialinvoke $r12.<java.lang.StringBuilder: void <init>()>();

        $r13 = virtualinvoke $r12.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>(r3);

        $r14 = virtualinvoke $r13.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>("() should return ");

        $r15 = virtualinvoke $r14.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>(r1);

        $r16 = virtualinvoke $r15.<java.lang.StringBuilder: java.lang.String toString()>();

        $r5[2] = $r16;

        $r5[3] = "";

        $r17 = new java.lang.StringBuilder;

        specialinvoke $r17.<java.lang.StringBuilder: void <init>()>();

        $r18 = virtualinvoke $r17.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>("The default answer of ");

        $r19 = staticinvoke <org.mockito.internal.exceptions.Reporter: org.mockito.mock.MockName safelyGetMockName(java.lang.Object)>(r0);

        $r20 = virtualinvoke $r18.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.Object)>($r19);

        $r21 = virtualinvoke $r20.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>(" that was configured on the mock is probably incorrectly implemented.");

        $r22 = virtualinvoke $r21.<java.lang.StringBuilder: java.lang.String toString()>();

        $r5[4] = $r22;

        $r5[5] = "";

        $r23 = staticinvoke <org.mockito.internal.util.StringUtil: java.lang.String join(java.lang.Object[])>($r5);

        specialinvoke $r4.<org.mockito.exceptions.misusing.WrongTypeOfReturnValue: void <init>(java.lang.String)>($r23);

        return $r4;
    }

    public static org.mockito.exceptions.verification.MoreThanAllowedActualInvocations wantedAtMostX(int, int)
    {
        int i0, i1;
        org.mockito.exceptions.verification.MoreThanAllowedActualInvocations $r0;
        java.lang.Object[] $r1;
        java.lang.StringBuilder $r2, $r3, $r5, $r6, $r7;
        java.lang.String $r4, $r8, $r9;

        i0 := @parameter0: int;

        i1 := @parameter1: int;

        $r0 = new org.mockito.exceptions.verification.MoreThanAllowedActualInvocations;

        $r1 = newarray (java.lang.Object)[1];

        $r2 = new java.lang.StringBuilder;

        specialinvoke $r2.<java.lang.StringBuilder: void <init>()>();

        $r3 = virtualinvoke $r2.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>("Wanted at most ");

        $r4 = staticinvoke <org.mockito.internal.reporting.Pluralizer: java.lang.String pluralize(int)>(i0);

        $r5 = virtualinvoke $r3.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>($r4);

        $r6 = virtualinvoke $r5.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>(" but was ");

        $r7 = virtualinvoke $r6.<java.lang.StringBuilder: java.lang.StringBuilder append(int)>(i1);

        $r8 = virtualinvoke $r7.<java.lang.StringBuilder: java.lang.String toString()>();

        $r1[0] = $r8;

        $r9 = staticinvoke <org.mockito.internal.util.StringUtil: java.lang.String join(java.lang.Object[])>($r1);

        specialinvoke $r0.<org.mockito.exceptions.verification.MoreThanAllowedActualInvocations: void <init>(java.lang.String)>($r9);

        return $r0;
    }

    public static org.mockito.exceptions.base.MockitoException misplacedArgumentMatcher(java.util.List)
    {
        java.util.List r0;
        org.mockito.exceptions.misusing.InvalidUseOfMatchersException $r1;
        java.lang.Object[] $r2;
        java.lang.Object $r3;
        java.lang.String $r4;

        r0 := @parameter0: java.util.List;

        $r1 = new org.mockito.exceptions.misusing.InvalidUseOfMatchersException;

        $r2 = newarray (java.lang.Object)[19];

        $r2[0] = "Misplaced or misused argument matcher detected here:";

        $r3 = staticinvoke <org.mockito.internal.exceptions.Reporter: java.lang.Object locationsOf(java.util.Collection)>(r0);

        $r2[1] = $r3;

        $r2[2] = "";

        $r2[3] = "You cannot use argument matchers outside of verification or stubbing.";

        $r2[4] = "Examples of correct usage of argument matchers:";

        $r2[5] = "    when(mock.get(anyInt())).thenReturn(null);";

        $r2[6] = "    doThrow(new RuntimeException()).when(mock).someVoidMethod(anyObject());";

        $r2[7] = "    verify(mock).someMethod(contains(\"foo\"))";

        $r2[8] = "";

        $r2[9] = "This message may appear after an NullPointerException if the last matcher is returning an object ";

        $r2[10] = "like any() but the stubbed method signature expect a primitive argument, in this case,";

        $r2[11] = "use primitive alternatives.";

        $r2[12] = "    when(mock.get(any())); // bad use, will raise NPE";

        $r2[13] = "    when(mock.get(anyInt())); // correct usage use";

        $r2[14] = "";

        $r2[15] = "Also, this error might show up because you use argument matchers with methods that cannot be mocked.";

        $r2[16] = "Following methods *cannot* be stubbed/verified: final/private/equals()/hashCode().";

        $r2[17] = "Mocking methods declared on non-public parent classes is not supported.";

        $r2[18] = "";

        $r4 = staticinvoke <org.mockito.internal.util.StringUtil: java.lang.String join(java.lang.Object[])>($r2);

        specialinvoke $r1.<org.mockito.exceptions.misusing.InvalidUseOfMatchersException: void <init>(java.lang.String)>($r4);

        return $r1;
    }

    public static org.mockito.exceptions.base.MockitoException smartNullPointerException(java.lang.String, org.mockito.invocation.Location)
    {
        java.lang.String r0, $r5;
        org.mockito.invocation.Location r1;
        org.mockito.exceptions.verification.SmartNullPointerException $r2;
        java.lang.Object[] $r3;
        org.mockito.internal.debugging.LocationImpl $r4;

        r0 := @parameter0: java.lang.String;

        r1 := @parameter1: org.mockito.invocation.Location;

        $r2 = new org.mockito.exceptions.verification.SmartNullPointerException;

        $r3 = newarray (java.lang.Object)[6];

        $r3[0] = "You have a NullPointerException here:";

        $r4 = new org.mockito.internal.debugging.LocationImpl;

        specialinvoke $r4.<org.mockito.internal.debugging.LocationImpl: void <init>()>();

        $r3[1] = $r4;

        $r3[2] = "because this method call was *not* stubbed correctly:";

        $r3[3] = r1;

        $r3[4] = r0;

        $r3[5] = "";

        $r5 = staticinvoke <org.mockito.internal.util.StringUtil: java.lang.String join(java.lang.Object[])>($r3);

        specialinvoke $r2.<org.mockito.exceptions.verification.SmartNullPointerException: void <init>(java.lang.String)>($r5);

        return $r2;
    }

    public static org.mockito.exceptions.base.MockitoException noArgumentValueWasCaptured()
    {
        org.mockito.exceptions.base.MockitoException $r0;
        java.lang.Object[] $r1;
        java.lang.String $r2;

        $r0 = new org.mockito.exceptions.base.MockitoException;

        $r1 = newarray (java.lang.Object)[10];

        $r1[0] = "No argument value was captured!";

        $r1[1] = "You might have forgotten to use argument.capture() in verify()...";

        $r1[2] = "...or you used capture() in stubbing but stubbed method was not called.";

        $r1[3] = "Be aware that it is recommended to use capture() only with verify()";

        $r1[4] = "";

        $r1[5] = "Examples of correct argument capturing:";

        $r1[6] = "    ArgumentCaptor<Person> argument = ArgumentCaptor.forClass(Person.class);";

        $r1[7] = "    verify(mock).doSomething(argument.capture());";

        $r1[8] = "    assertEquals(\"John\", argument.getValue().getName());";

        $r1[9] = "";

        $r2 = staticinvoke <org.mockito.internal.util.StringUtil: java.lang.String join(java.lang.Object[])>($r1);

        specialinvoke $r0.<org.mockito.exceptions.base.MockitoException: void <init>(java.lang.String)>($r2);

        return $r0;
    }

    public static org.mockito.exceptions.base.MockitoException extraInterfacesDoesNotAcceptNullParameters()
    {
        org.mockito.exceptions.base.MockitoException $r0;
        java.lang.Object[] $r1;
        java.lang.String $r2;

        $r0 = new org.mockito.exceptions.base.MockitoException;

        $r1 = newarray (java.lang.Object)[1];

        $r1[0] = "extraInterfaces() does not accept null parameters.";

        $r2 = staticinvoke <org.mockito.internal.util.StringUtil: java.lang.String join(java.lang.Object[])>($r1);

        specialinvoke $r0.<org.mockito.exceptions.base.MockitoException: void <init>(java.lang.String)>($r2);

        return $r0;
    }

    public static org.mockito.exceptions.base.MockitoException extraInterfacesAcceptsOnlyInterfaces(java.lang.Class)
    {
        java.lang.Class r0;
        org.mockito.exceptions.base.MockitoException $r1;
        java.lang.Object[] $r2;
        java.lang.StringBuilder $r3, $r4, $r6, $r7;
        java.lang.String $r5, $r8, $r9;

        r0 := @parameter0: java.lang.Class;

        $r1 = new org.mockito.exceptions.base.MockitoException;

        $r2 = newarray (java.lang.Object)[2];

        $r2[0] = "extraInterfaces() accepts only interfaces.";

        $r3 = new java.lang.StringBuilder;

        specialinvoke $r3.<java.lang.StringBuilder: void <init>()>();

        $r4 = virtualinvoke $r3.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>("You passed following type: ");

        $r5 = virtualinvoke r0.<java.lang.Class: java.lang.String getSimpleName()>();

        $r6 = virtualinvoke $r4.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>($r5);

        $r7 = virtualinvoke $r6.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>(" which is not an interface.");

        $r8 = virtualinvoke $r7.<java.lang.StringBuilder: java.lang.String toString()>();

        $r2[1] = $r8;

        $r9 = staticinvoke <org.mockito.internal.util.StringUtil: java.lang.String join(java.lang.Object[])>($r2);

        specialinvoke $r1.<org.mockito.exceptions.base.MockitoException: void <init>(java.lang.String)>($r9);

        return $r1;
    }

    public static org.mockito.exceptions.base.MockitoException extraInterfacesCannotContainMockedType(java.lang.Class)
    {
        java.lang.Class r0;
        org.mockito.exceptions.base.MockitoException $r1;
        java.lang.Object[] $r2;
        java.lang.StringBuilder $r3, $r4, $r6;
        java.lang.String $r5, $r7, $r8;

        r0 := @parameter0: java.lang.Class;

        $r1 = new org.mockito.exceptions.base.MockitoException;

        $r2 = newarray (java.lang.Object)[3];

        $r2[0] = "extraInterfaces() does not accept the same type as the mocked type.";

        $r3 = new java.lang.StringBuilder;

        specialinvoke $r3.<java.lang.StringBuilder: void <init>()>();

        $r4 = virtualinvoke $r3.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>("You mocked following type: ");

        $r5 = virtualinvoke r0.<java.lang.Class: java.lang.String getSimpleName()>();

        $r6 = virtualinvoke $r4.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>($r5);

        $r7 = virtualinvoke $r6.<java.lang.StringBuilder: java.lang.String toString()>();

        $r2[1] = $r7;

        $r2[2] = "and you passed the same very interface to the extraInterfaces()";

        $r8 = staticinvoke <org.mockito.internal.util.StringUtil: java.lang.String join(java.lang.Object[])>($r2);

        specialinvoke $r1.<org.mockito.exceptions.base.MockitoException: void <init>(java.lang.String)>($r8);

        return $r1;
    }

    public static org.mockito.exceptions.base.MockitoException extraInterfacesRequiresAtLeastOneInterface()
    {
        org.mockito.exceptions.base.MockitoException $r0;
        java.lang.Object[] $r1;
        java.lang.String $r2;

        $r0 = new org.mockito.exceptions.base.MockitoException;

        $r1 = newarray (java.lang.Object)[1];

        $r1[0] = "extraInterfaces() requires at least one interface.";

        $r2 = staticinvoke <org.mockito.internal.util.StringUtil: java.lang.String join(java.lang.Object[])>($r1);

        specialinvoke $r0.<org.mockito.exceptions.base.MockitoException: void <init>(java.lang.String)>($r2);

        return $r0;
    }

    public static org.mockito.exceptions.base.MockitoException mockedTypeIsInconsistentWithSpiedInstanceType(java.lang.Class, java.lang.Object)
    {
        java.lang.Class r0, $r6;
        java.lang.Object r1;
        org.mockito.exceptions.base.MockitoException $r2;
        java.lang.Object[] $r3;
        java.lang.StringBuilder $r4, $r5, $r8, $r9, $r11;
        java.lang.String $r7, $r10, $r12, $r13;

        r0 := @parameter0: java.lang.Class;

        r1 := @parameter1: java.lang.Object;

        $r2 = new org.mockito.exceptions.base.MockitoException;

        $r3 = newarray (java.lang.Object)[6];

        $r3[0] = "Mocked type must be the same as the type of your spied instance.";

        $r4 = new java.lang.StringBuilder;

        specialinvoke $r4.<java.lang.StringBuilder: void <init>()>();

        $r5 = virtualinvoke $r4.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>("Mocked type must be: ");

        $r6 = virtualinvoke r1.<java.lang.Object: java.lang.Class getClass()>();

        $r7 = virtualinvoke $r6.<java.lang.Class: java.lang.String getSimpleName()>();

        $r8 = virtualinvoke $r5.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>($r7);

        $r9 = virtualinvoke $r8.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>(", but is: ");

        $r10 = virtualinvoke r0.<java.lang.Class: java.lang.String getSimpleName()>();

        $r11 = virtualinvoke $r9.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>($r10);

        $r12 = virtualinvoke $r11.<java.lang.StringBuilder: java.lang.String toString()>();

        $r3[1] = $r12;

        $r3[2] = "  //correct spying:";

        $r3[3] = "  spy = mock( ->ArrayList.class<- , withSettings().spiedInstance( ->new ArrayList()<- );";

        $r3[4] = "  //incorrect - types don\'t match:";

        $r3[5] = "  spy = mock( ->List.class<- , withSettings().spiedInstance( ->new ArrayList()<- );";

        $r13 = staticinvoke <org.mockito.internal.util.StringUtil: java.lang.String join(java.lang.Object[])>($r3);

        specialinvoke $r2.<org.mockito.exceptions.base.MockitoException: void <init>(java.lang.String)>($r13);

        return $r2;
    }

    public static org.mockito.exceptions.base.MockitoException cannotCallAbstractRealMethod()
    {
        org.mockito.exceptions.base.MockitoException $r0;
        java.lang.Object[] $r1;
        java.lang.String $r2;

        $r0 = new org.mockito.exceptions.base.MockitoException;

        $r1 = newarray (java.lang.Object)[4];

        $r1[0] = "Cannot call abstract real method on java object!";

        $r1[1] = "Calling real methods is only possible when mocking non abstract method.";

        $r1[2] = "  //correct example:";

        $r1[3] = "  when(mockOfConcreteClass.nonAbstractMethod()).thenCallRealMethod();";

        $r2 = staticinvoke <org.mockito.internal.util.StringUtil: java.lang.String join(java.lang.Object[])>($r1);

        specialinvoke $r0.<org.mockito.exceptions.base.MockitoException: void <init>(java.lang.String)>($r2);

        return $r0;
    }

    public static org.mockito.exceptions.base.MockitoException cannotVerifyToString()
    {
        org.mockito.exceptions.base.MockitoException $r0;
        java.lang.Object[] $r1;
        java.lang.String $r2;

        $r0 = new org.mockito.exceptions.base.MockitoException;

        $r1 = newarray (java.lang.Object)[3];

        $r1[0] = "Mockito cannot verify toString()";

        $r1[1] = "toString() is too often used behind of scenes  (i.e. during String concatenation, in IDE debugging views). Verifying it may give inconsistent or hard to understand results. Not to mention that verifying toString() most likely hints awkward design (hard to explain in a short exception message. Trust me...)";

        $r1[2] = "However, it is possible to stub toString(). Stubbing toString() smells a bit funny but there are rare, legitimate use cases.";

        $r2 = staticinvoke <org.mockito.internal.util.StringUtil: java.lang.String join(java.lang.Object[])>($r1);

        specialinvoke $r0.<org.mockito.exceptions.base.MockitoException: void <init>(java.lang.String)>($r2);

        return $r0;
    }

    public static org.mockito.exceptions.base.MockitoException moreThanOneAnnotationNotAllowed(java.lang.String)
    {
        java.lang.String r0, $r6;
        org.mockito.exceptions.base.MockitoException $r1;
        java.lang.StringBuilder $r2, $r3, $r4, $r5;

        r0 := @parameter0: java.lang.String;

        $r1 = new org.mockito.exceptions.base.MockitoException;

        $r2 = new java.lang.StringBuilder;

        specialinvoke $r2.<java.lang.StringBuilder: void <init>()>();

        $r3 = virtualinvoke $r2.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>("You cannot have more than one Mockito annotation on a field!\nThe field \'");

        $r4 = virtualinvoke $r3.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>(r0);

        $r5 = virtualinvoke $r4.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>("\' has multiple Mockito annotations.\nFor info how to use annotations see examples in javadoc for MockitoAnnotations class.");

        $r6 = virtualinvoke $r5.<java.lang.StringBuilder: java.lang.String toString()>();

        specialinvoke $r1.<org.mockito.exceptions.base.MockitoException: void <init>(java.lang.String)>($r6);

        return $r1;
    }

    public static org.mockito.exceptions.base.MockitoException unsupportedCombinationOfAnnotations(java.lang.String, java.lang.String)
    {
        java.lang.String r0, r1, $r8;
        org.mockito.exceptions.base.MockitoException $r2;
        java.lang.StringBuilder $r3, $r4, $r5, $r6, $r7;

        r0 := @parameter0: java.lang.String;

        r1 := @parameter1: java.lang.String;

        $r2 = new org.mockito.exceptions.base.MockitoException;

        $r3 = new java.lang.StringBuilder;

        specialinvoke $r3.<java.lang.StringBuilder: void <init>()>();

        $r4 = virtualinvoke $r3.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>("This combination of annotations is not permitted on a single field:\n@");

        $r5 = virtualinvoke $r4.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>(r0);

        $r6 = virtualinvoke $r5.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>(" and @");

        $r7 = virtualinvoke $r6.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>(r1);

        $r8 = virtualinvoke $r7.<java.lang.StringBuilder: java.lang.String toString()>();

        specialinvoke $r2.<org.mockito.exceptions.base.MockitoException: void <init>(java.lang.String)>($r8);

        return $r2;
    }

    public static org.mockito.exceptions.base.MockitoException cannotInitializeForSpyAnnotation(java.lang.String, java.lang.Exception)
    {
        java.lang.String r0, $r8, $r11, $r13, $r14;
        java.lang.Exception r1;
        org.mockito.exceptions.base.MockitoException $r2;
        java.lang.Object[] $r3;
        java.lang.StringBuilder $r4, $r5, $r6, $r7, $r9, $r10, $r12;

        r0 := @parameter0: java.lang.String;

        r1 := @parameter1: java.lang.Exception;

        $r2 = new org.mockito.exceptions.base.MockitoException;

        $r3 = newarray (java.lang.Object)[8];

        $r4 = new java.lang.StringBuilder;

        specialinvoke $r4.<java.lang.StringBuilder: void <init>()>();

        $r5 = virtualinvoke $r4.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>("Cannot instantiate a @Spy for \'");

        $r6 = virtualinvoke $r5.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>(r0);

        $r7 = virtualinvoke $r6.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>("\' field.");

        $r8 = virtualinvoke $r7.<java.lang.StringBuilder: java.lang.String toString()>();

        $r3[0] = $r8;

        $r3[1] = "You haven\'t provided the instance for spying at field declaration so I tried to construct the instance.";

        $r9 = new java.lang.StringBuilder;

        specialinvoke $r9.<java.lang.StringBuilder: void <init>()>();

        $r10 = virtualinvoke $r9.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>("However, I failed because: ");

        $r11 = virtualinvoke r1.<java.lang.Exception: java.lang.String getMessage()>();

        $r12 = virtualinvoke $r10.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>($r11);

        $r13 = virtualinvoke $r12.<java.lang.StringBuilder: java.lang.String toString()>();

        $r3[2] = $r13;

        $r3[3] = "Examples of correct usage of @Spy:";

        $r3[4] = "   @Spy List mock = new LinkedList();";

        $r3[5] = "   @Spy Foo foo; //only if Foo has parameterless constructor";

        $r3[6] = "   //also, don\'t forget about MockitoAnnotations.initMocks();";

        $r3[7] = "";

        $r14 = staticinvoke <org.mockito.internal.util.StringUtil: java.lang.String join(java.lang.Object[])>($r3);

        specialinvoke $r2.<org.mockito.exceptions.base.MockitoException: void <init>(java.lang.String,java.lang.Throwable)>($r14, r1);

        return $r2;
    }

    public static org.mockito.exceptions.base.MockitoException cannotInitializeForInjectMocksAnnotation(java.lang.String, java.lang.String)
    {
        java.lang.String r0, r1, $r9, $r10;
        org.mockito.exceptions.base.MockitoException $r2;
        java.lang.Object[] $r3;
        java.lang.StringBuilder $r4, $r5, $r6, $r7, $r8;

        r0 := @parameter0: java.lang.String;

        r1 := @parameter1: java.lang.String;

        $r2 = new org.mockito.exceptions.base.MockitoException;

        $r3 = newarray (java.lang.Object)[7];

        $r4 = new java.lang.StringBuilder;

        specialinvoke $r4.<java.lang.StringBuilder: void <init>()>();

        $r5 = virtualinvoke $r4.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>("Cannot instantiate @InjectMocks field named \'");

        $r6 = virtualinvoke $r5.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>(r0);

        $r7 = virtualinvoke $r6.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>("\'! Cause: ");

        $r8 = virtualinvoke $r7.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>(r1);

        $r9 = virtualinvoke $r8.<java.lang.StringBuilder: java.lang.String toString()>();

        $r3[0] = $r9;

        $r3[1] = "You haven\'t provided the instance at field declaration so I tried to construct the instance.";

        $r3[2] = "Examples of correct usage of @InjectMocks:";

        $r3[3] = "   @InjectMocks Service service = new Service();";

        $r3[4] = "   @InjectMocks Service service;";

        $r3[5] = "   //and... don\'t forget about some @Mocks for injection :)";

        $r3[6] = "";

        $r10 = staticinvoke <org.mockito.internal.util.StringUtil: java.lang.String join(java.lang.Object[])>($r3);

        specialinvoke $r2.<org.mockito.exceptions.base.MockitoException: void <init>(java.lang.String)>($r10);

        return $r2;
    }

    public static org.mockito.exceptions.base.MockitoException atMostAndNeverShouldNotBeUsedWithTimeout()
    {
        org.mockito.exceptions.misusing.FriendlyReminderException $r0;
        java.lang.Object[] $r1;
        java.lang.String $r2;

        $r0 = new org.mockito.exceptions.misusing.FriendlyReminderException;

        $r1 = newarray (java.lang.Object)[8];

        $r1[0] = "";

        $r1[1] = "Don\'t panic! I\'m just a friendly reminder!";

        $r1[2] = "timeout() should not be used with atMost() or never() because...";

        $r1[3] = "...it does not make much sense - the test would have passed immediately in concurrency";

        $r1[4] = "We kept this method only to avoid compilation errors when upgrading Mockito.";

        $r1[5] = "In future release we will remove timeout(x).atMost(y) from the API.";

        $r1[6] = "If you want to find out more please refer to issue 235";

        $r1[7] = "";

        $r2 = staticinvoke <org.mockito.internal.util.StringUtil: java.lang.String join(java.lang.Object[])>($r1);

        specialinvoke $r0.<org.mockito.exceptions.misusing.FriendlyReminderException: void <init>(java.lang.String)>($r2);

        return $r0;
    }

    public static org.mockito.exceptions.base.MockitoException fieldInitialisationThrewException(java.lang.reflect.Field, java.lang.Throwable)
    {
        java.lang.reflect.Field r0;
        java.lang.Throwable r1;
        org.mockito.exceptions.base.MockitoException $r2;
        java.lang.Object[] $r3;
        java.lang.StringBuilder $r4, $r5, $r7, $r8, $r10, $r11, $r13, $r14, $r16;
        java.lang.String $r6, $r12, $r15, $r17, $r18;
        java.lang.Class $r9;

        r0 := @parameter0: java.lang.reflect.Field;

        r1 := @parameter1: java.lang.Throwable;

        $r2 = new org.mockito.exceptions.base.MockitoException;

        $r3 = newarray (java.lang.Object)[4];

        $r4 = new java.lang.StringBuilder;

        specialinvoke $r4.<java.lang.StringBuilder: void <init>()>();

        $r5 = virtualinvoke $r4.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>("Cannot instantiate @InjectMocks field named \'");

        $r6 = virtualinvoke r0.<java.lang.reflect.Field: java.lang.String getName()>();

        $r7 = virtualinvoke $r5.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>($r6);

        $r8 = virtualinvoke $r7.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>("\' of type \'");

        $r9 = virtualinvoke r0.<java.lang.reflect.Field: java.lang.Class getType()>();

        $r10 = virtualinvoke $r8.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.Object)>($r9);

        $r11 = virtualinvoke $r10.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>("\'.");

        $r12 = virtualinvoke $r11.<java.lang.StringBuilder: java.lang.String toString()>();

        $r3[0] = $r12;

        $r3[1] = "You haven\'t provided the instance at field declaration so I tried to construct the instance.";

        $r13 = new java.lang.StringBuilder;

        specialinvoke $r13.<java.lang.StringBuilder: void <init>()>();

        $r14 = virtualinvoke $r13.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>("However the constructor or the initialization block threw an exception : ");

        $r15 = virtualinvoke r1.<java.lang.Throwable: java.lang.String getMessage()>();

        $r16 = virtualinvoke $r14.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>($r15);

        $r17 = virtualinvoke $r16.<java.lang.StringBuilder: java.lang.String toString()>();

        $r3[2] = $r17;

        $r3[3] = "";

        $r18 = staticinvoke <org.mockito.internal.util.StringUtil: java.lang.String join(java.lang.Object[])>($r3);

        specialinvoke $r2.<org.mockito.exceptions.base.MockitoException: void <init>(java.lang.String,java.lang.Throwable)>($r18, r1);

        return $r2;
    }

    public static org.mockito.exceptions.base.MockitoException methodDoesNotAcceptParameter(java.lang.String, java.lang.String)
    {
        java.lang.String r0, r1, $r8;
        org.mockito.exceptions.base.MockitoException $r2;
        java.lang.StringBuilder $r3, $r4, $r5, $r6, $r7;

        r0 := @parameter0: java.lang.String;

        r1 := @parameter1: java.lang.String;

        $r2 = new org.mockito.exceptions.base.MockitoException;

        $r3 = new java.lang.StringBuilder;

        specialinvoke $r3.<java.lang.StringBuilder: void <init>()>();

        $r4 = virtualinvoke $r3.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>(r0);

        $r5 = virtualinvoke $r4.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>("() does not accept ");

        $r6 = virtualinvoke $r5.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>(r1);

        $r7 = virtualinvoke $r6.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>(" See the Javadoc.");

        $r8 = virtualinvoke $r7.<java.lang.StringBuilder: java.lang.String toString()>();

        specialinvoke $r2.<org.mockito.exceptions.base.MockitoException: void <init>(java.lang.String)>($r8);

        return $r2;
    }

    public static org.mockito.exceptions.base.MockitoException invocationListenersRequiresAtLeastOneListener()
    {
        org.mockito.exceptions.base.MockitoException $r0;

        $r0 = new org.mockito.exceptions.base.MockitoException;

        specialinvoke $r0.<org.mockito.exceptions.base.MockitoException: void <init>(java.lang.String)>("invocationListeners() requires at least one listener");

        return $r0;
    }

    public static org.mockito.exceptions.base.MockitoException invocationListenerThrewException(org.mockito.listeners.InvocationListener, java.lang.Throwable)
    {
        org.mockito.listeners.InvocationListener r0;
        java.lang.Throwable r1;
        org.mockito.exceptions.base.MockitoException $r2;
        java.lang.Object[] $r3;
        java.lang.StringBuilder $r4, $r5, $r8, $r10, $r11, $r14, $r16;
        java.lang.Class $r6, $r12;
        java.lang.String $r7, $r9, $r13, $r15, $r17, $r18;

        r0 := @parameter0: org.mockito.listeners.InvocationListener;

        r1 := @parameter1: java.lang.Throwable;

        $r2 = new org.mockito.exceptions.base.MockitoException;

        $r3 = newarray (java.lang.Object)[2];

        $r4 = new java.lang.StringBuilder;

        specialinvoke $r4.<java.lang.StringBuilder: void <init>()>();

        $r5 = virtualinvoke $r4.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>("The invocation listener with type ");

        $r6 = virtualinvoke r0.<java.lang.Object: java.lang.Class getClass()>();

        $r7 = virtualinvoke $r6.<java.lang.Class: java.lang.String getName()>();

        $r8 = virtualinvoke $r5.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>($r7);

        $r9 = virtualinvoke $r8.<java.lang.StringBuilder: java.lang.String toString()>();

        $r3[0] = $r9;

        $r10 = new java.lang.StringBuilder;

        specialinvoke $r10.<java.lang.StringBuilder: void <init>()>();

        $r11 = virtualinvoke $r10.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>("threw an exception : ");

        $r12 = virtualinvoke r1.<java.lang.Object: java.lang.Class getClass()>();

        $r13 = virtualinvoke $r12.<java.lang.Class: java.lang.String getName()>();

        $r14 = virtualinvoke $r11.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>($r13);

        $r15 = virtualinvoke r1.<java.lang.Throwable: java.lang.String getMessage()>();

        $r16 = virtualinvoke $r14.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>($r15);

        $r17 = virtualinvoke $r16.<java.lang.StringBuilder: java.lang.String toString()>();

        $r3[1] = $r17;

        $r18 = staticinvoke <org.mockito.internal.util.StringUtil: java.lang.String join(java.lang.Object[])>($r3);

        specialinvoke $r2.<org.mockito.exceptions.base.MockitoException: void <init>(java.lang.String,java.lang.Throwable)>($r18, r1);

        return $r2;
    }

    public static org.mockito.exceptions.base.MockitoException cannotInjectDependency(java.lang.reflect.Field, java.lang.Object, java.lang.Exception)
    {
        java.lang.reflect.Field r0;
        java.lang.Object r1;
        java.lang.Exception r2;
        org.mockito.exceptions.base.MockitoException $r3;
        java.lang.Object[] $r4;
        java.lang.StringBuilder $r5, $r6, $r8, $r9, $r11, $r12, $r13, $r14, $r16, $r17, $r20, $r21, $r23, $r24, $r26;
        org.mockito.mock.MockName $r7;
        java.lang.String $r10, $r15, $r19, $r22, $r25, $r27, $r28;
        java.lang.Class $r18;

        r0 := @parameter0: java.lang.reflect.Field;

        r1 := @parameter1: java.lang.Object;

        r2 := @parameter2: java.lang.Exception;

        $r3 = new org.mockito.exceptions.base.MockitoException;

        $r4 = newarray (java.lang.Object)[5];

        $r5 = new java.lang.StringBuilder;

        specialinvoke $r5.<java.lang.StringBuilder: void <init>()>();

        $r6 = virtualinvoke $r5.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>("Mockito couldn\'t inject mock dependency \'");

        $r7 = staticinvoke <org.mockito.internal.exceptions.Reporter: org.mockito.mock.MockName safelyGetMockName(java.lang.Object)>(r1);

        $r8 = virtualinvoke $r6.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.Object)>($r7);

        $r9 = virtualinvoke $r8.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>("\' on field ");

        $r10 = virtualinvoke $r9.<java.lang.StringBuilder: java.lang.String toString()>();

        $r4[0] = $r10;

        $r11 = new java.lang.StringBuilder;

        specialinvoke $r11.<java.lang.StringBuilder: void <init>()>();

        $r12 = virtualinvoke $r11.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>("\'");

        $r13 = virtualinvoke $r12.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.Object)>(r0);

        $r14 = virtualinvoke $r13.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>("\'");

        $r15 = virtualinvoke $r14.<java.lang.StringBuilder: java.lang.String toString()>();

        $r4[1] = $r15;

        $r16 = new java.lang.StringBuilder;

        specialinvoke $r16.<java.lang.StringBuilder: void <init>()>();

        $r17 = virtualinvoke $r16.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>("whose type \'");

        $r18 = virtualinvoke r0.<java.lang.reflect.Field: java.lang.Class getDeclaringClass()>();

        $r19 = virtualinvoke $r18.<java.lang.Class: java.lang.String getCanonicalName()>();

        $r20 = virtualinvoke $r17.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>($r19);

        $r21 = virtualinvoke $r20.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>("\' was annotated by @InjectMocks in your test.");

        $r22 = virtualinvoke $r21.<java.lang.StringBuilder: java.lang.String toString()>();

        $r4[2] = $r22;

        $r23 = new java.lang.StringBuilder;

        specialinvoke $r23.<java.lang.StringBuilder: void <init>()>();

        $r24 = virtualinvoke $r23.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>("Also I failed because: ");

        $r25 = staticinvoke <org.mockito.internal.exceptions.Reporter: java.lang.String exceptionCauseMessageIfAvailable(java.lang.Exception)>(r2);

        $r26 = virtualinvoke $r24.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>($r25);

        $r27 = virtualinvoke $r26.<java.lang.StringBuilder: java.lang.String toString()>();

        $r4[3] = $r27;

        $r4[4] = "";

        $r28 = staticinvoke <org.mockito.internal.util.StringUtil: java.lang.String join(java.lang.Object[])>($r4);

        specialinvoke $r3.<org.mockito.exceptions.base.MockitoException: void <init>(java.lang.String,java.lang.Throwable)>($r28, r2);

        return $r3;
    }

    private static java.lang.String exceptionCauseMessageIfAvailable(java.lang.Exception)
    {
        java.lang.Exception r0;
        java.lang.Throwable $r1, $r2;
        java.lang.String $r3, $r4;

        r0 := @parameter0: java.lang.Exception;

        $r1 = virtualinvoke r0.<java.lang.Exception: java.lang.Throwable getCause()>();

        if $r1 != null goto label1;

        $r4 = virtualinvoke r0.<java.lang.Exception: java.lang.String getMessage()>();

        return $r4;

     label1:
        $r2 = virtualinvoke r0.<java.lang.Exception: java.lang.Throwable getCause()>();

        $r3 = virtualinvoke $r2.<java.lang.Throwable: java.lang.String getMessage()>();

        return $r3;
    }

    public static org.mockito.exceptions.base.MockitoException mockedTypeIsInconsistentWithDelegatedInstanceType(java.lang.Class, java.lang.Object)
    {
        java.lang.Class r0, $r6;
        java.lang.Object r1;
        org.mockito.exceptions.base.MockitoException $r2;
        java.lang.Object[] $r3;
        java.lang.StringBuilder $r4, $r5, $r8, $r9, $r11;
        java.lang.String $r7, $r10, $r12, $r13;

        r0 := @parameter0: java.lang.Class;

        r1 := @parameter1: java.lang.Object;

        $r2 = new org.mockito.exceptions.base.MockitoException;

        $r3 = newarray (java.lang.Object)[6];

        $r3[0] = "Mocked type must be the same as the type of your delegated instance.";

        $r4 = new java.lang.StringBuilder;

        specialinvoke $r4.<java.lang.StringBuilder: void <init>()>();

        $r5 = virtualinvoke $r4.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>("Mocked type must be: ");

        $r6 = virtualinvoke r1.<java.lang.Object: java.lang.Class getClass()>();

        $r7 = virtualinvoke $r6.<java.lang.Class: java.lang.String getSimpleName()>();

        $r8 = virtualinvoke $r5.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>($r7);

        $r9 = virtualinvoke $r8.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>(", but is: ");

        $r10 = virtualinvoke r0.<java.lang.Class: java.lang.String getSimpleName()>();

        $r11 = virtualinvoke $r9.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>($r10);

        $r12 = virtualinvoke $r11.<java.lang.StringBuilder: java.lang.String toString()>();

        $r3[1] = $r12;

        $r3[2] = "  //correct delegate:";

        $r3[3] = "  spy = mock( ->List.class<- , withSettings().delegatedInstance( ->new ArrayList()<- );";

        $r3[4] = "  //incorrect - types don\'t match:";

        $r3[5] = "  spy = mock( ->List.class<- , withSettings().delegatedInstance( ->new HashSet()<- );";

        $r13 = staticinvoke <org.mockito.internal.util.StringUtil: java.lang.String join(java.lang.Object[])>($r3);

        specialinvoke $r2.<org.mockito.exceptions.base.MockitoException: void <init>(java.lang.String)>($r13);

        return $r2;
    }

    public static org.mockito.exceptions.base.MockitoException spyAndDelegateAreMutuallyExclusive()
    {
        org.mockito.exceptions.base.MockitoException $r0;
        java.lang.Object[] $r1;
        java.lang.String $r2;

        $r0 = new org.mockito.exceptions.base.MockitoException;

        $r1 = newarray (java.lang.Object)[1];

        $r1[0] = "Settings should not define a spy instance and a delegated instance at the same time.";

        $r2 = staticinvoke <org.mockito.internal.util.StringUtil: java.lang.String join(java.lang.Object[])>($r1);

        specialinvoke $r0.<org.mockito.exceptions.base.MockitoException: void <init>(java.lang.String)>($r2);

        return $r0;
    }

    public static org.mockito.exceptions.base.MockitoException invalidArgumentRangeAtIdentityAnswerCreationTime()
    {
        org.mockito.exceptions.base.MockitoException $r0;
        java.lang.Object[] $r1;
        java.lang.String $r2;

        $r0 = new org.mockito.exceptions.base.MockitoException;

        $r1 = newarray (java.lang.Object)[4];

        $r1[0] = "Invalid argument index.";

        $r1[1] = "The index need to be a positive number that indicates the position of the argument to return.";

        $r1[2] = "However it is possible to use the -1 value to indicates that the last argument should be";

        $r1[3] = "returned.";

        $r2 = staticinvoke <org.mockito.internal.util.StringUtil: java.lang.String join(java.lang.Object[])>($r1);

        specialinvoke $r0.<org.mockito.exceptions.base.MockitoException: void <init>(java.lang.String)>($r2);

        return $r0;
    }

    public static org.mockito.exceptions.base.MockitoException invalidArgumentPositionRangeAtInvocationTime(org.mockito.invocation.InvocationOnMock, boolean, int)
    {
        org.mockito.invocation.InvocationOnMock r0;
        boolean z0;
        int i0;
        org.mockito.exceptions.base.MockitoException $r1;
        java.lang.Object[] $r2;
        java.lang.StringBuilder $r3, $r4, $r7, $r8, $r11, $r12, $r14, $r15, $r16, $r17, $r18, $r19, $r20, $r21;
        java.lang.Object $r5;
        org.mockito.mock.MockName $r6;
        java.lang.reflect.Method $r9;
        java.lang.String $r10, $r13, $r22, $r23, $r24;

        r0 := @parameter0: org.mockito.invocation.InvocationOnMock;

        z0 := @parameter1: boolean;

        i0 := @parameter2: int;

        $r1 = new org.mockito.exceptions.base.MockitoException;

        $r2 = newarray (java.lang.Object)[7];

        $r2[0] = "Invalid argument index for the current invocation of method : ";

        $r3 = new java.lang.StringBuilder;

        specialinvoke $r3.<java.lang.StringBuilder: void <init>()>();

        $r4 = virtualinvoke $r3.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>(" -> ");

        $r5 = interfaceinvoke r0.<org.mockito.invocation.InvocationOnMock: java.lang.Object getMock()>();

        $r6 = staticinvoke <org.mockito.internal.exceptions.Reporter: org.mockito.mock.MockName safelyGetMockName(java.lang.Object)>($r5);

        $r7 = virtualinvoke $r4.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.Object)>($r6);

        $r8 = virtualinvoke $r7.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>(".");

        $r9 = interfaceinvoke r0.<org.mockito.invocation.InvocationOnMock: java.lang.reflect.Method getMethod()>();

        $r10 = virtualinvoke $r9.<java.lang.reflect.Method: java.lang.String getName()>();

        $r11 = virtualinvoke $r8.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>($r10);

        $r12 = virtualinvoke $r11.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>("()");

        $r13 = virtualinvoke $r12.<java.lang.StringBuilder: java.lang.String toString()>();

        $r2[1] = $r13;

        $r2[2] = "";

        $r14 = new java.lang.StringBuilder;

        specialinvoke $r14.<java.lang.StringBuilder: void <init>()>();

        if z0 == 0 goto label1;

        $r24 = "Last parameter wanted";

        goto label2;

     label1:
        $r15 = new java.lang.StringBuilder;

        specialinvoke $r15.<java.lang.StringBuilder: void <init>()>();

        $r16 = virtualinvoke $r15.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>("Wanted parameter at position ");

        $r17 = virtualinvoke $r16.<java.lang.StringBuilder: java.lang.StringBuilder append(int)>(i0);

        $r24 = virtualinvoke $r17.<java.lang.StringBuilder: java.lang.String toString()>();

     label2:
        $r18 = virtualinvoke $r14.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>($r24);

        $r19 = virtualinvoke $r18.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>(" but ");

        $r20 = staticinvoke <org.mockito.internal.exceptions.Reporter: java.lang.StringBuilder possibleArgumentTypesOf(org.mockito.invocation.InvocationOnMock)>(r0);

        $r21 = virtualinvoke $r19.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.Object)>($r20);

        $r22 = virtualinvoke $r21.<java.lang.StringBuilder: java.lang.String toString()>();

        $r2[3] = $r22;

        $r2[4] = "The index need to be a positive number that indicates a valid position of the argument in the invocation.";

        $r2[5] = "However it is possible to use the -1 value to indicates that the last argument should be returned.";

        $r2[6] = "";

        $r23 = staticinvoke <org.mockito.internal.util.StringUtil: java.lang.String join(java.lang.Object[])>($r2);

        specialinvoke $r1.<org.mockito.exceptions.base.MockitoException: void <init>(java.lang.String)>($r23);

        return $r1;
    }

    private static java.lang.StringBuilder possibleArgumentTypesOf(org.mockito.invocation.InvocationOnMock)
    {
        org.mockito.invocation.InvocationOnMock r0;
        java.lang.Class[] r1;
        int i0, $i1, $i2, i3;
        java.lang.reflect.Method $r3, $r7;
        java.lang.StringBuilder $r4, $r5, $r8, $r11, $r13, $r17, $r18, $r20;
        boolean $z0;
        java.lang.Class $r9, $r14, $r15;
        java.lang.String $r10, $r16;

        r0 := @parameter0: org.mockito.invocation.InvocationOnMock;

        $r3 = interfaceinvoke r0.<org.mockito.invocation.InvocationOnMock: java.lang.reflect.Method getMethod()>();

        r1 = virtualinvoke $r3.<java.lang.reflect.Method: java.lang.Class[] getParameterTypes()>();

        $i1 = lengthof r1;

        if $i1 != 0 goto label1;

        $r20 = new java.lang.StringBuilder;

        specialinvoke $r20.<java.lang.StringBuilder: void <init>(java.lang.String)>("the method has no arguments.\n");

        return $r20;

     label1:
        $r4 = new java.lang.StringBuilder;

        specialinvoke $r4.<java.lang.StringBuilder: void <init>(java.lang.String)>("the possible argument indexes for this method are :\n");

        i3 = 0;

        i0 = lengthof r1;

     label2:
        if i3 >= i0 goto label5;

        $r5 = virtualinvoke $r4.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>("    [");

        virtualinvoke $r5.<java.lang.StringBuilder: java.lang.StringBuilder append(int)>(i3);

        $r7 = interfaceinvoke r0.<org.mockito.invocation.InvocationOnMock: java.lang.reflect.Method getMethod()>();

        $z0 = virtualinvoke $r7.<java.lang.reflect.Method: boolean isVarArgs()>();

        if $z0 == 0 goto label3;

        $i2 = i0 - 1;

        if i3 != $i2 goto label3;

        $r13 = virtualinvoke $r4.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>("+] ");

        $r14 = r1[i3];

        $r15 = virtualinvoke $r14.<java.lang.Class: java.lang.Class getComponentType()>();

        $r16 = virtualinvoke $r15.<java.lang.Class: java.lang.String getSimpleName()>();

        $r17 = virtualinvoke $r13.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>($r16);

        $r18 = virtualinvoke $r17.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>("  <- Vararg");

        virtualinvoke $r18.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>("\n");

        goto label4;

     label3:
        $r8 = virtualinvoke $r4.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>("] ");

        $r9 = r1[i3];

        $r10 = virtualinvoke $r9.<java.lang.Class: java.lang.String getSimpleName()>();

        $r11 = virtualinvoke $r8.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>($r10);

        virtualinvoke $r11.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>("\n");

     label4:
        i3 = i3 + 1;

        goto label2;

     label5:
        return $r4;
    }

    public static org.mockito.exceptions.base.MockitoException wrongTypeOfArgumentToReturn(org.mockito.invocation.InvocationOnMock, java.lang.String, java.lang.Class, int)
    {
        org.mockito.invocation.InvocationOnMock r0;
        java.lang.String r1, $r7, $r10, $r15, $r23, $r26, $r33, $r34;
        java.lang.Class r2;
        int i0;
        org.mockito.exceptions.misusing.WrongTypeOfReturnValue $r3;
        java.lang.Object[] $r4;
        java.lang.StringBuilder $r5, $r6, $r8, $r9, $r11, $r12, $r13, $r14, $r16, $r17, $r20, $r21, $r24, $r25, $r27, $r28, $r29, $r30, $r31, $r32;
        java.lang.Object $r18;
        org.mockito.mock.MockName $r19;
        java.lang.reflect.Method $r22;

        r0 := @parameter0: org.mockito.invocation.InvocationOnMock;

        r1 := @parameter1: java.lang.String;

        r2 := @parameter2: java.lang.Class;

        i0 := @parameter3: int;

        $r3 = new org.mockito.exceptions.misusing.WrongTypeOfReturnValue;

        $r4 = newarray (java.lang.Object)[17];

        $r5 = new java.lang.StringBuilder;

        specialinvoke $r5.<java.lang.StringBuilder: void <init>()>();

        $r6 = virtualinvoke $r5.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>("The argument of type \'");

        $r7 = virtualinvoke r2.<java.lang.Class: java.lang.String getSimpleName()>();

        $r8 = virtualinvoke $r6.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>($r7);

        $r9 = virtualinvoke $r8.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>("\' cannot be returned because the following ");

        $r10 = virtualinvoke $r9.<java.lang.StringBuilder: java.lang.String toString()>();

        $r4[0] = $r10;

        $r11 = new java.lang.StringBuilder;

        specialinvoke $r11.<java.lang.StringBuilder: void <init>()>();

        $r12 = virtualinvoke $r11.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>("method should return the type \'");

        $r13 = virtualinvoke $r12.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>(r1);

        $r14 = virtualinvoke $r13.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>("\'");

        $r15 = virtualinvoke $r14.<java.lang.StringBuilder: java.lang.String toString()>();

        $r4[1] = $r15;

        $r16 = new java.lang.StringBuilder;

        specialinvoke $r16.<java.lang.StringBuilder: void <init>()>();

        $r17 = virtualinvoke $r16.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>(" -> ");

        $r18 = interfaceinvoke r0.<org.mockito.invocation.InvocationOnMock: java.lang.Object getMock()>();

        $r19 = staticinvoke <org.mockito.internal.exceptions.Reporter: org.mockito.mock.MockName safelyGetMockName(java.lang.Object)>($r18);

        $r20 = virtualinvoke $r17.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.Object)>($r19);

        $r21 = virtualinvoke $r20.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>(".");

        $r22 = interfaceinvoke r0.<org.mockito.invocation.InvocationOnMock: java.lang.reflect.Method getMethod()>();

        $r23 = virtualinvoke $r22.<java.lang.reflect.Method: java.lang.String getName()>();

        $r24 = virtualinvoke $r21.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>($r23);

        $r25 = virtualinvoke $r24.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>("()");

        $r26 = virtualinvoke $r25.<java.lang.StringBuilder: java.lang.String toString()>();

        $r4[2] = $r26;

        $r4[3] = "";

        $r4[4] = "The reason for this error can be :";

        $r4[5] = "1. The wanted argument position is incorrect.";

        $r4[6] = "2. The answer is used on the wrong interaction.";

        $r4[7] = "";

        $r27 = new java.lang.StringBuilder;

        specialinvoke $r27.<java.lang.StringBuilder: void <init>()>();

        $r28 = virtualinvoke $r27.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>("Position of the wanted argument is ");

        $r29 = virtualinvoke $r28.<java.lang.StringBuilder: java.lang.StringBuilder append(int)>(i0);

        $r30 = virtualinvoke $r29.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>(" and ");

        $r31 = staticinvoke <org.mockito.internal.exceptions.Reporter: java.lang.StringBuilder possibleArgumentTypesOf(org.mockito.invocation.InvocationOnMock)>(r0);

        $r32 = virtualinvoke $r30.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.Object)>($r31);

        $r33 = virtualinvoke $r32.<java.lang.StringBuilder: java.lang.String toString()>();

        $r4[8] = $r33;

        $r4[9] = "***";

        $r4[10] = "However if you\'re still unsure why you\'re getting above error read on.";

        $r4[11] = "Due to the nature of the syntax above problem might occur because:";

        $r4[12] = "1. This exception *might* occur in wrongly written multi-threaded tests.";

        $r4[13] = "   Please refer to Mockito FAQ on limitations of concurrency testing.";

        $r4[14] = "2. A spy is stubbed using when(spy.foo()).then() syntax. It is safer to stub spies - ";

        $r4[15] = "   - with doReturn|Throw() family of methods. More in javadocs for Mockito.spy() method.";

        $r4[16] = "";

        $r34 = staticinvoke <org.mockito.internal.util.StringUtil: java.lang.String join(java.lang.Object[])>($r4);

        specialinvoke $r3.<org.mockito.exceptions.misusing.WrongTypeOfReturnValue: void <init>(java.lang.String)>($r34);

        return $r3;
    }

    public static org.mockito.exceptions.base.MockitoException defaultAnswerDoesNotAcceptNullParameter()
    {
        org.mockito.exceptions.base.MockitoException $r0;

        $r0 = new org.mockito.exceptions.base.MockitoException;

        specialinvoke $r0.<org.mockito.exceptions.base.MockitoException: void <init>(java.lang.String)>("defaultAnswer() does not accept null parameter");

        return $r0;
    }

    public static org.mockito.exceptions.base.MockitoException serializableWontWorkForObjectsThatDontImplementSerializable(java.lang.Class)
    {
        java.lang.Class r0;
        org.mockito.exceptions.base.MockitoException $r1;
        java.lang.Object[] $r2;
        java.lang.StringBuilder $r3, $r4, $r6, $r7;
        java.lang.String $r5, $r8, $r9;

        r0 := @parameter0: java.lang.Class;

        $r1 = new org.mockito.exceptions.base.MockitoException;

        $r2 = newarray (java.lang.Object)[7];

        $r3 = new java.lang.StringBuilder;

        specialinvoke $r3.<java.lang.StringBuilder: void <init>()>();

        $r4 = virtualinvoke $r3.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>("You are using the setting \'withSettings().serializable()\' however the type you are trying to mock \'");

        $r5 = virtualinvoke r0.<java.lang.Class: java.lang.String getSimpleName()>();

        $r6 = virtualinvoke $r4.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>($r5);

        $r7 = virtualinvoke $r6.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>("\'");

        $r8 = virtualinvoke $r7.<java.lang.StringBuilder: java.lang.String toString()>();

        $r2[0] = $r8;

        $r2[1] = "do not implement Serializable AND do not have a no-arg constructor.";

        $r2[2] = "This combination is requested, otherwise you will get an \'java.io.InvalidClassException\' when the mock will be serialized";

        $r2[3] = "";

        $r2[4] = "Also note that as requested by the Java serialization specification, the whole hierarchy need to implements Serializable,";

        $r2[5] = "i.e. the top-most superclass has to implements Serializable.";

        $r2[6] = "";

        $r9 = staticinvoke <org.mockito.internal.util.StringUtil: java.lang.String join(java.lang.Object[])>($r2);

        specialinvoke $r1.<org.mockito.exceptions.base.MockitoException: void <init>(java.lang.String)>($r9);

        return $r1;
    }

    public static org.mockito.exceptions.base.MockitoException delegatedMethodHasWrongReturnType(java.lang.reflect.Method, java.lang.reflect.Method, java.lang.Object, java.lang.Object)
    {
        java.lang.reflect.Method r0, r1;
        java.lang.Object r2, r3;
        org.mockito.exceptions.base.MockitoException $r4;
        java.lang.Object[] $r5;
        java.lang.StringBuilder $r6, $r7, $r8, $r9, $r11, $r13, $r14, $r17, $r18, $r21, $r23, $r24, $r27, $r28;
        org.mockito.mock.MockName $r10;
        java.lang.String $r12, $r16, $r20, $r22, $r26, $r29, $r30;
        java.lang.Class $r15, $r19, $r25;

        r0 := @parameter0: java.lang.reflect.Method;

        r1 := @parameter1: java.lang.reflect.Method;

        r2 := @parameter2: java.lang.Object;

        r3 := @parameter3: java.lang.Object;

        $r4 = new org.mockito.exceptions.base.MockitoException;

        $r5 = newarray (java.lang.Object)[5];

        $r5[0] = "Methods called on delegated instance must have compatible return types with the mock.";

        $r6 = new java.lang.StringBuilder;

        specialinvoke $r6.<java.lang.StringBuilder: void <init>()>();

        $r7 = virtualinvoke $r6.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>("When calling: ");

        $r8 = virtualinvoke $r7.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.Object)>(r0);

        $r9 = virtualinvoke $r8.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>(" on mock: ");

        $r10 = staticinvoke <org.mockito.internal.exceptions.Reporter: org.mockito.mock.MockName safelyGetMockName(java.lang.Object)>(r2);

        $r11 = virtualinvoke $r9.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.Object)>($r10);

        $r12 = virtualinvoke $r11.<java.lang.StringBuilder: java.lang.String toString()>();

        $r5[1] = $r12;

        $r13 = new java.lang.StringBuilder;

        specialinvoke $r13.<java.lang.StringBuilder: void <init>()>();

        $r14 = virtualinvoke $r13.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>("return type should be: ");

        $r15 = virtualinvoke r0.<java.lang.reflect.Method: java.lang.Class getReturnType()>();

        $r16 = virtualinvoke $r15.<java.lang.Class: java.lang.String getSimpleName()>();

        $r17 = virtualinvoke $r14.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>($r16);

        $r18 = virtualinvoke $r17.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>(", but was: ");

        $r19 = virtualinvoke r1.<java.lang.reflect.Method: java.lang.Class getReturnType()>();

        $r20 = virtualinvoke $r19.<java.lang.Class: java.lang.String getSimpleName()>();

        $r21 = virtualinvoke $r18.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>($r20);

        $r22 = virtualinvoke $r21.<java.lang.StringBuilder: java.lang.String toString()>();

        $r5[2] = $r22;

        $r5[3] = "Check that the instance passed to delegatesTo() is of the correct type or contains compatible methods";

        $r23 = new java.lang.StringBuilder;

        specialinvoke $r23.<java.lang.StringBuilder: void <init>()>();

        $r24 = virtualinvoke $r23.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>("(delegate instance had type: ");

        $r25 = virtualinvoke r3.<java.lang.Object: java.lang.Class getClass()>();

        $r26 = virtualinvoke $r25.<java.lang.Class: java.lang.String getSimpleName()>();

        $r27 = virtualinvoke $r24.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>($r26);

        $r28 = virtualinvoke $r27.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>(")");

        $r29 = virtualinvoke $r28.<java.lang.StringBuilder: java.lang.String toString()>();

        $r5[4] = $r29;

        $r30 = staticinvoke <org.mockito.internal.util.StringUtil: java.lang.String join(java.lang.Object[])>($r5);

        specialinvoke $r4.<org.mockito.exceptions.base.MockitoException: void <init>(java.lang.String)>($r30);

        return $r4;
    }

    public static org.mockito.exceptions.base.MockitoException delegatedMethodDoesNotExistOnDelegate(java.lang.reflect.Method, java.lang.Object, java.lang.Object)
    {
        java.lang.reflect.Method r0;
        java.lang.Object r1, r2;
        org.mockito.exceptions.base.MockitoException $r3;
        java.lang.Object[] $r4;
        java.lang.StringBuilder $r5, $r6, $r7, $r8, $r10, $r12, $r13, $r16, $r17;
        org.mockito.mock.MockName $r9;
        java.lang.String $r11, $r15, $r18, $r19;
        java.lang.Class $r14;

        r0 := @parameter0: java.lang.reflect.Method;

        r1 := @parameter1: java.lang.Object;

        r2 := @parameter2: java.lang.Object;

        $r3 = new org.mockito.exceptions.base.MockitoException;

        $r4 = newarray (java.lang.Object)[5];

        $r4[0] = "Methods called on mock must exist in delegated instance.";

        $r5 = new java.lang.StringBuilder;

        specialinvoke $r5.<java.lang.StringBuilder: void <init>()>();

        $r6 = virtualinvoke $r5.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>("When calling: ");

        $r7 = virtualinvoke $r6.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.Object)>(r0);

        $r8 = virtualinvoke $r7.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>(" on mock: ");

        $r9 = staticinvoke <org.mockito.internal.exceptions.Reporter: org.mockito.mock.MockName safelyGetMockName(java.lang.Object)>(r1);

        $r10 = virtualinvoke $r8.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.Object)>($r9);

        $r11 = virtualinvoke $r10.<java.lang.StringBuilder: java.lang.String toString()>();

        $r4[1] = $r11;

        $r4[2] = "no such method was found.";

        $r4[3] = "Check that the instance passed to delegatesTo() is of the correct type or contains compatible methods";

        $r12 = new java.lang.StringBuilder;

        specialinvoke $r12.<java.lang.StringBuilder: void <init>()>();

        $r13 = virtualinvoke $r12.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>("(delegate instance had type: ");

        $r14 = virtualinvoke r2.<java.lang.Object: java.lang.Class getClass()>();

        $r15 = virtualinvoke $r14.<java.lang.Class: java.lang.String getSimpleName()>();

        $r16 = virtualinvoke $r13.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>($r15);

        $r17 = virtualinvoke $r16.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>(")");

        $r18 = virtualinvoke $r17.<java.lang.StringBuilder: java.lang.String toString()>();

        $r4[4] = $r18;

        $r19 = staticinvoke <org.mockito.internal.util.StringUtil: java.lang.String join(java.lang.Object[])>($r4);

        specialinvoke $r3.<org.mockito.exceptions.base.MockitoException: void <init>(java.lang.String)>($r19);

        return $r3;
    }

    public static org.mockito.exceptions.base.MockitoException usingConstructorWithFancySerializable(org.mockito.mock.SerializableMode)
    {
        org.mockito.mock.SerializableMode r0;
        org.mockito.exceptions.base.MockitoException $r1;
        java.lang.StringBuilder $r2, $r3, $r4, $r5;
        java.lang.String $r6;

        r0 := @parameter0: org.mockito.mock.SerializableMode;

        $r1 = new org.mockito.exceptions.base.MockitoException;

        $r2 = new java.lang.StringBuilder;

        specialinvoke $r2.<java.lang.StringBuilder: void <init>()>();

        $r3 = virtualinvoke $r2.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>("Mocks instantiated with constructor cannot be combined with ");

        $r4 = virtualinvoke $r3.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.Object)>(r0);

        $r5 = virtualinvoke $r4.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>(" serialization mode.");

        $r6 = virtualinvoke $r5.<java.lang.StringBuilder: java.lang.String toString()>();

        specialinvoke $r1.<org.mockito.exceptions.base.MockitoException: void <init>(java.lang.String)>($r6);

        return $r1;
    }

    public static org.mockito.exceptions.base.MockitoException cannotCreateTimerWithNegativeDurationTime(long)
    {
        long l0;
        org.mockito.exceptions.misusing.FriendlyReminderException $r0;
        java.lang.Object[] $r1;
        java.lang.StringBuilder $r2, $r3, $r4, $r5;
        java.lang.String $r6, $r7;

        l0 := @parameter0: long;

        $r0 = new org.mockito.exceptions.misusing.FriendlyReminderException;

        $r1 = newarray (java.lang.Object)[6];

        $r1[0] = "";

        $r1[1] = "Don\'t panic! I\'m just a friendly reminder!";

        $r1[2] = "It is impossible for time to go backward, therefore...";

        $r2 = new java.lang.StringBuilder;

        specialinvoke $r2.<java.lang.StringBuilder: void <init>()>();

        $r3 = virtualinvoke $r2.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>("You cannot put negative value of duration: (");

        $r4 = virtualinvoke $r3.<java.lang.StringBuilder: java.lang.StringBuilder append(long)>(l0);

        $r5 = virtualinvoke $r4.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>(")");

        $r6 = virtualinvoke $r5.<java.lang.StringBuilder: java.lang.String toString()>();

        $r1[3] = $r6;

        $r1[4] = "as argument of timer methods (after(), timeout())";

        $r1[5] = "";

        $r7 = staticinvoke <org.mockito.internal.util.StringUtil: java.lang.String join(java.lang.Object[])>($r1);

        specialinvoke $r0.<org.mockito.exceptions.misusing.FriendlyReminderException: void <init>(java.lang.String)>($r7);

        return $r0;
    }

    public static org.mockito.exceptions.base.MockitoException notAnException()
    {
        org.mockito.exceptions.base.MockitoException $r0;
        java.lang.Object[] $r1;
        java.lang.String $r2;

        $r0 = new org.mockito.exceptions.base.MockitoException;

        $r1 = newarray (java.lang.Object)[2];

        $r1[0] = "Exception type cannot be null.";

        $r1[1] = "This may happen with doThrow(Class)|thenThrow(Class) family of methods if passing null parameter.";

        $r2 = staticinvoke <org.mockito.internal.util.StringUtil: java.lang.String join(java.lang.Object[])>($r1);

        specialinvoke $r0.<org.mockito.exceptions.base.MockitoException: void <init>(java.lang.String)>($r2);

        return $r0;
    }

    private static org.mockito.mock.MockName safelyGetMockName(java.lang.Object)
    {
        java.lang.Object r0;
        org.mockito.mock.MockName $r1;

        r0 := @parameter0: java.lang.Object;

        $r1 = staticinvoke <org.mockito.internal.util.MockUtil: org.mockito.mock.MockName getMockName(java.lang.Object)>(r0);

        return $r1;
    }

    public static org.mockito.exceptions.misusing.UnnecessaryStubbingException formatUnncessaryStubbingException(java.lang.Class, java.util.Collection)
    {
        java.lang.Class r0;
        java.util.Collection r1;
        org.mockito.invocation.Invocation r3;
        java.lang.StringBuilder $r4, $r7, $r8, $r9, $r12, $r13, $r15, $r17, $r18, $r19;
        boolean $z0;
        org.mockito.exceptions.misusing.UnnecessaryStubbingException $r5;
        java.lang.Object[] $r6;
        java.lang.String $r10, $r11, $r14, $r23;
        java.lang.Object $r16;
        int $i0, i1;
        org.mockito.invocation.Location $r20;
        java.util.Iterator r22;

        r0 := @parameter0: java.lang.Class;

        r1 := @parameter1: java.util.Collection;

        $r4 = new java.lang.StringBuilder;

        specialinvoke $r4.<java.lang.StringBuilder: void <init>()>();

        i1 = 1;

        r22 = interfaceinvoke r1.<java.util.Collection: java.util.Iterator iterator()>();

     label1:
        $z0 = interfaceinvoke r22.<java.util.Iterator: boolean hasNext()>();

        if $z0 == 0 goto label2;

        $r16 = interfaceinvoke r22.<java.util.Iterator: java.lang.Object next()>();

        r3 = (org.mockito.invocation.Invocation) $r16;

        $r17 = virtualinvoke $r4.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>("\n  ");

        $i0 = i1;

        i1 = i1 + 1;

        $r18 = virtualinvoke $r17.<java.lang.StringBuilder: java.lang.StringBuilder append(int)>($i0);

        $r19 = virtualinvoke $r18.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>(". ");

        $r20 = interfaceinvoke r3.<org.mockito.invocation.Invocation: org.mockito.invocation.Location getLocation()>();

        virtualinvoke $r19.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.Object)>($r20);

        goto label1;

     label2:
        if r0 == null goto label3;

        $r12 = new java.lang.StringBuilder;

        specialinvoke $r12.<java.lang.StringBuilder: void <init>()>();

        $r13 = virtualinvoke $r12.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>("Unnecessary stubbings detected in test class: ");

        $r14 = virtualinvoke r0.<java.lang.Class: java.lang.String getSimpleName()>();

        $r15 = virtualinvoke $r13.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>($r14);

        $r23 = virtualinvoke $r15.<java.lang.StringBuilder: java.lang.String toString()>();

        goto label4;

     label3:
        $r23 = "Unnecessary stubbings detected.";

     label4:
        $r5 = new org.mockito.exceptions.misusing.UnnecessaryStubbingException;

        $r6 = newarray (java.lang.Object)[4];

        $r6[0] = $r23;

        $r6[1] = "Clean & maintainable test code requires zero unnecessary code.";

        $r7 = new java.lang.StringBuilder;

        specialinvoke $r7.<java.lang.StringBuilder: void <init>()>();

        $r8 = virtualinvoke $r7.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>("Following stubbings are unnecessary (click to navigate to relevant line of code):");

        $r9 = virtualinvoke $r8.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.Object)>($r4);

        $r10 = virtualinvoke $r9.<java.lang.StringBuilder: java.lang.String toString()>();

        $r6[2] = $r10;

        $r6[3] = "Please remove unnecessary stubbings or use \'lenient\' strictness. More info: javadoc for UnnecessaryStubbingException class.";

        $r11 = staticinvoke <org.mockito.internal.util.StringUtil: java.lang.String join(java.lang.Object[])>($r6);

        specialinvoke $r5.<org.mockito.exceptions.misusing.UnnecessaryStubbingException: void <init>(java.lang.String)>($r11);

        return $r5;
    }

    public static void unncessaryStubbingException(java.util.List)
    {
        java.util.List r0;
        org.mockito.exceptions.misusing.UnnecessaryStubbingException $r1;

        r0 := @parameter0: java.util.List;

        $r1 = staticinvoke <org.mockito.internal.exceptions.Reporter: org.mockito.exceptions.misusing.UnnecessaryStubbingException formatUnncessaryStubbingException(java.lang.Class,java.util.Collection)>(null, r0);

        throw $r1;
    }

    public static void potentialStubbingProblem(org.mockito.invocation.Invocation, java.util.Collection)
    {
        org.mockito.invocation.Invocation r0, r4;
        java.util.Collection r1;
        java.util.Iterator r3;
        java.lang.StringBuilder $r5, $r9, $r10, $r13, $r14, $r16, $r17, $r18, $r20, $r21, $r23, $r27, $r28, $r29, $r31, $r33;
        boolean $z0;
        int $i0, $i1, $i2, i3;
        org.mockito.exceptions.misusing.PotentialStubbingProblem $r7;
        java.lang.Object[] $r8;
        java.lang.reflect.Method $r11;
        java.lang.String $r12, $r15, $r19, $r24, $r25;
        org.mockito.invocation.Location $r22, $r32;
        java.lang.Object $r26;

        r0 := @parameter0: org.mockito.invocation.Invocation;

        r1 := @parameter1: java.util.Collection;

        $r5 = new java.lang.StringBuilder;

        specialinvoke $r5.<java.lang.StringBuilder: void <init>()>();

        i3 = 1;

        r3 = interfaceinvoke r1.<java.util.Collection: java.util.Iterator iterator()>();

     label1:
        $z0 = interfaceinvoke r3.<java.util.Iterator: boolean hasNext()>();

        if $z0 == 0 goto label2;

        $r26 = interfaceinvoke r3.<java.util.Iterator: java.lang.Object next()>();

        r4 = (org.mockito.invocation.Invocation) $r26;

        $r27 = virtualinvoke $r5.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>("    ");

        $i2 = i3;

        i3 = i3 + 1;

        $r28 = virtualinvoke $r27.<java.lang.StringBuilder: java.lang.StringBuilder append(int)>($i2);

        $r29 = virtualinvoke $r28.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>(". ");

        virtualinvoke $r29.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.Object)>(r4);

        $r31 = virtualinvoke $r5.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>("\n      ");

        $r32 = interfaceinvoke r4.<org.mockito.invocation.Invocation: org.mockito.invocation.Location getLocation()>();

        $r33 = virtualinvoke $r31.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.Object)>($r32);

        virtualinvoke $r33.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>("\n");

        goto label1;

     label2:
        $i0 = virtualinvoke $r5.<java.lang.StringBuilder: int length()>();

        $i1 = $i0 - 1;

        virtualinvoke $r5.<java.lang.StringBuilder: java.lang.StringBuilder deleteCharAt(int)>($i1);

        $r7 = new org.mockito.exceptions.misusing.PotentialStubbingProblem;

        $r8 = newarray (java.lang.Object)[14];

        $r8[0] = "Strict stubbing argument mismatch. Please check:";

        $r9 = new java.lang.StringBuilder;

        specialinvoke $r9.<java.lang.StringBuilder: void <init>()>();

        $r10 = virtualinvoke $r9.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>(" - this invocation of \'");

        $r11 = interfaceinvoke r0.<org.mockito.invocation.Invocation: java.lang.reflect.Method getMethod()>();

        $r12 = virtualinvoke $r11.<java.lang.reflect.Method: java.lang.String getName()>();

        $r13 = virtualinvoke $r10.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>($r12);

        $r14 = virtualinvoke $r13.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>("\' method:");

        $r15 = virtualinvoke $r14.<java.lang.StringBuilder: java.lang.String toString()>();

        $r8[1] = $r15;

        $r16 = new java.lang.StringBuilder;

        specialinvoke $r16.<java.lang.StringBuilder: void <init>()>();

        $r17 = virtualinvoke $r16.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>("    ");

        $r18 = virtualinvoke $r17.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.Object)>(r0);

        $r19 = virtualinvoke $r18.<java.lang.StringBuilder: java.lang.String toString()>();

        $r8[2] = $r19;

        $r20 = new java.lang.StringBuilder;

        specialinvoke $r20.<java.lang.StringBuilder: void <init>()>();

        $r21 = virtualinvoke $r20.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>("    ");

        $r22 = interfaceinvoke r0.<org.mockito.invocation.Invocation: org.mockito.invocation.Location getLocation()>();

        $r23 = virtualinvoke $r21.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.Object)>($r22);

        $r24 = virtualinvoke $r23.<java.lang.StringBuilder: java.lang.String toString()>();

        $r8[3] = $r24;

        $r8[4] = " - has following stubbing(s) with different arguments:";

        $r8[5] = $r5;

        $r8[6] = "Typically, stubbing argument mismatch indicates user mistake when writing tests.";

        $r8[7] = "Mockito fails early so that you can debug potential problem easily.";

        $r8[8] = "However, there are legit scenarios when this exception generates false negative signal:";

        $r8[9] = "  - stubbing the same method multiple times using \'given().will()\' or \'when().then()\' API";

        $r8[10] = "    Please use \'will().given()\' or \'doReturn().when()\' API for stubbing.";

        $r8[11] = "  - stubbed method is intentionally invoked with different arguments by code under test";

        $r8[12] = "    Please use default or \'silent\' JUnit Rule (equivalent of Strictness.LENIENT).";

        $r8[13] = "For more information see javadoc for PotentialStubbingProblem class.";

        $r25 = staticinvoke <org.mockito.internal.util.StringUtil: java.lang.String join(java.lang.Object[])>($r8);

        specialinvoke $r7.<org.mockito.exceptions.misusing.PotentialStubbingProblem: void <init>(java.lang.String)>($r25);

        throw $r7;
    }

    public static void redundantMockitoListener(java.lang.String)
    {
        java.lang.String r0, $r7, $r8;
        org.mockito.exceptions.misusing.RedundantListenerException $r1;
        java.lang.Object[] $r2;
        java.lang.StringBuilder $r3, $r4, $r5, $r6;

        r0 := @parameter0: java.lang.String;

        $r1 = new org.mockito.exceptions.misusing.RedundantListenerException;

        $r2 = newarray (java.lang.Object)[6];

        $r2[0] = "Problems adding Mockito listener.";

        $r3 = new java.lang.StringBuilder;

        specialinvoke $r3.<java.lang.StringBuilder: void <init>()>();

        $r4 = virtualinvoke $r3.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>("Listener of type \'");

        $r5 = virtualinvoke $r4.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>(r0);

        $r6 = virtualinvoke $r5.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>("\' has already been added and not removed.");

        $r7 = virtualinvoke $r6.<java.lang.StringBuilder: java.lang.String toString()>();

        $r2[1] = $r7;

        $r2[2] = "It indicates that previous listener was not removed according to the API.";

        $r2[3] = "When you add a listener, don\'t forget to remove the listener afterwards:";

        $r2[4] = "  Mockito.framework().removeListener(myListener);";

        $r2[5] = "For more information, see the javadoc for RedundantListenerException class.";

        $r8 = staticinvoke <org.mockito.internal.util.StringUtil: java.lang.String join(java.lang.Object[])>($r2);

        specialinvoke $r1.<org.mockito.exceptions.misusing.RedundantListenerException: void <init>(java.lang.String)>($r8);

        throw $r1;
    }

    public static void unfinishedMockingSession()
    {
        org.mockito.exceptions.misusing.UnfinishedMockingSessionException $r0;
        java.lang.Object[] $r1;
        java.lang.String $r2;

        $r0 = new org.mockito.exceptions.misusing.UnfinishedMockingSessionException;

        $r1 = newarray (java.lang.Object)[3];

        $r1[0] = "Unfinished mocking session detected.";

        $r1[1] = "Previous MockitoSession was not concluded with \'finishMocking()\'.";

        $r1[2] = "For examples of correct usage see javadoc for MockitoSession class.";

        $r2 = staticinvoke <org.mockito.internal.util.StringUtil: java.lang.String join(java.lang.Object[])>($r1);

        specialinvoke $r0.<org.mockito.exceptions.misusing.UnfinishedMockingSessionException: void <init>(java.lang.String)>($r2);

        throw $r0;
    }

    public static void <clinit>()
    {
        <org.mockito.internal.exceptions.Reporter: java.lang.String NON_PUBLIC_PARENT> = "Mocking methods declared on non-public parent classes is not supported.";

        return;
    }
}
