public abstract class org.apache.flink.api.common.typeinfo.TypeInformation extends java.lang.Object implements java.io.Serializable
{
    private static final long serialVersionUID;

    public void <init>()
    {
        org.apache.flink.api.common.typeinfo.TypeInformation r0;

        r0 := @this: org.apache.flink.api.common.typeinfo.TypeInformation;

        specialinvoke r0.<java.lang.Object: void <init>()>();

        return;
    }

    public abstract boolean isBasicType();

    public abstract boolean isTupleType();

    public abstract int getArity();

    public abstract int getTotalFields();

    public abstract java.lang.Class getTypeClass();

    public java.util.Map getGenericParameters()
    {
        org.apache.flink.api.common.typeinfo.TypeInformation r0;
        java.util.Map $r1;

        r0 := @this: org.apache.flink.api.common.typeinfo.TypeInformation;

        $r1 = staticinvoke <java.util.Collections: java.util.Map emptyMap()>();

        return $r1;
    }

    public abstract boolean isKeyType();

    public boolean isSortKeyType()
    {
        org.apache.flink.api.common.typeinfo.TypeInformation r0;
        boolean $z0;

        r0 := @this: org.apache.flink.api.common.typeinfo.TypeInformation;

        $z0 = virtualinvoke r0.<org.apache.flink.api.common.typeinfo.TypeInformation: boolean isKeyType()>();

        return $z0;
    }

    public abstract org.apache.flink.api.common.typeutils.TypeSerializer createSerializer(org.apache.flink.api.common.ExecutionConfig);

    public abstract java.lang.String toString();

    public abstract boolean equals(java.lang.Object);

    public abstract int hashCode();

    public abstract boolean canEqual(java.lang.Object);

    public static org.apache.flink.api.common.typeinfo.TypeInformation of(java.lang.Class)
    {
        java.lang.Class r0;
        org.apache.flink.api.common.typeinfo.TypeInformation $r2;
        org.apache.flink.api.common.functions.InvalidTypesException $r3;
        org.apache.flink.util.FlinkRuntimeException $r4;

        r0 := @parameter0: java.lang.Class;

     label1:
        $r2 = staticinvoke <org.apache.flink.api.java.typeutils.TypeExtractor: org.apache.flink.api.common.typeinfo.TypeInformation createTypeInfo(java.lang.Class)>(r0);

     label2:
        return $r2;

     label3:
        $r3 := @caughtexception;

        $r4 = new org.apache.flink.util.FlinkRuntimeException;

        specialinvoke $r4.<org.apache.flink.util.FlinkRuntimeException: void <init>(java.lang.String)>("Cannot extract TypeInformation from Class alone, because generic parameters are missing. Please use TypeInformation.of(TypeHint) instead, or another equivalent method in the API that accepts a TypeHint instead of a Class. For example for a Tuple2<Long, String> pass a \'new TypeHint<Tuple2<Long, String>>(){}\'.");

        throw $r4;

        catch org.apache.flink.api.common.functions.InvalidTypesException from label1 to label2 with label3;
    }

    public static org.apache.flink.api.common.typeinfo.TypeInformation of(org.apache.flink.api.common.typeinfo.TypeHint)
    {
        org.apache.flink.api.common.typeinfo.TypeHint r0;
        org.apache.flink.api.common.typeinfo.TypeInformation $r1;

        r0 := @parameter0: org.apache.flink.api.common.typeinfo.TypeHint;

        $r1 = virtualinvoke r0.<org.apache.flink.api.common.typeinfo.TypeHint: org.apache.flink.api.common.typeinfo.TypeInformation getTypeInfo()>();

        return $r1;
    }

    public static void <clinit>()
    {
        <org.apache.flink.api.common.typeinfo.TypeInformation: long serialVersionUID> = -7742311969684489493L;

        return;
    }
}
