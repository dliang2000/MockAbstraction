public class javassist.bytecode.StackMapTable extends javassist.bytecode.AttributeInfo
{
    public static final java.lang.String tag;
    public static final int TOP;
    public static final int INTEGER;
    public static final int FLOAT;
    public static final int DOUBLE;
    public static final int LONG;
    public static final int NULL;
    public static final int THIS;
    public static final int OBJECT;
    public static final int UNINIT;

    void <init>(javassist.bytecode.ConstPool, byte[])
    {
        javassist.bytecode.StackMapTable r0;
        javassist.bytecode.ConstPool r1;
        byte[] r2;

        r0 := @this: javassist.bytecode.StackMapTable;

        r1 := @parameter0: javassist.bytecode.ConstPool;

        r2 := @parameter1: byte[];

        specialinvoke r0.<javassist.bytecode.AttributeInfo: void <init>(javassist.bytecode.ConstPool,java.lang.String,byte[])>(r1, "StackMapTable", r2);

        return;
    }

    void <init>(javassist.bytecode.ConstPool, int, java.io.DataInputStream) throws java.io.IOException
    {
        javassist.bytecode.StackMapTable r0;
        javassist.bytecode.ConstPool r1;
        int i0;
        java.io.DataInputStream r2;

        r0 := @this: javassist.bytecode.StackMapTable;

        r1 := @parameter0: javassist.bytecode.ConstPool;

        i0 := @parameter1: int;

        r2 := @parameter2: java.io.DataInputStream;

        specialinvoke r0.<javassist.bytecode.AttributeInfo: void <init>(javassist.bytecode.ConstPool,int,java.io.DataInputStream)>(r1, i0, r2);

        return;
    }

    public javassist.bytecode.AttributeInfo copy(javassist.bytecode.ConstPool, java.util.Map) throws javassist.bytecode.StackMapTable$RuntimeCopyException
    {
        javassist.bytecode.StackMapTable r0, $r4;
        javassist.bytecode.ConstPool r1, $r7;
        java.util.Map r2;
        javassist.bytecode.StackMapTable$Copier $r5;
        byte[] $r6, $r8;
        javassist.bytecode.BadBytecode $r9;
        javassist.bytecode.StackMapTable$RuntimeCopyException $r10;

        r0 := @this: javassist.bytecode.StackMapTable;

        r1 := @parameter0: javassist.bytecode.ConstPool;

        r2 := @parameter1: java.util.Map;

     label1:
        $r4 = new javassist.bytecode.StackMapTable;

        $r5 = new javassist.bytecode.StackMapTable$Copier;

        $r7 = r0.<javassist.bytecode.StackMapTable: javassist.bytecode.ConstPool constPool>;

        $r6 = r0.<javassist.bytecode.StackMapTable: byte[] info>;

        specialinvoke $r5.<javassist.bytecode.StackMapTable$Copier: void <init>(javassist.bytecode.ConstPool,byte[],javassist.bytecode.ConstPool,java.util.Map)>($r7, $r6, r1, r2);

        $r8 = virtualinvoke $r5.<javassist.bytecode.StackMapTable$Copier: byte[] doit()>();

        specialinvoke $r4.<javassist.bytecode.StackMapTable: void <init>(javassist.bytecode.ConstPool,byte[])>(r1, $r8);

     label2:
        return $r4;

     label3:
        $r9 := @caughtexception;

        $r10 = new javassist.bytecode.StackMapTable$RuntimeCopyException;

        specialinvoke $r10.<javassist.bytecode.StackMapTable$RuntimeCopyException: void <init>(java.lang.String)>("bad bytecode. fatal?");

        throw $r10;

        catch javassist.bytecode.BadBytecode from label1 to label2 with label3;
    }

    void write(java.io.DataOutputStream) throws java.io.IOException
    {
        javassist.bytecode.StackMapTable r0;
        java.io.DataOutputStream r1;

        r0 := @this: javassist.bytecode.StackMapTable;

        r1 := @parameter0: java.io.DataOutputStream;

        specialinvoke r0.<javassist.bytecode.AttributeInfo: void write(java.io.DataOutputStream)>(r1);

        return;
    }

    public void insertLocal(int, int, int) throws javassist.bytecode.BadBytecode
    {
        javassist.bytecode.StackMapTable r0;
        int i0, i1, i2;
        byte[] r1, $r3;
        javassist.bytecode.StackMapTable$InsertLocal $r2;

        r0 := @this: javassist.bytecode.StackMapTable;

        i0 := @parameter0: int;

        i1 := @parameter1: int;

        i2 := @parameter2: int;

        $r2 = new javassist.bytecode.StackMapTable$InsertLocal;

        $r3 = virtualinvoke r0.<javassist.bytecode.StackMapTable: byte[] get()>();

        specialinvoke $r2.<javassist.bytecode.StackMapTable$InsertLocal: void <init>(byte[],int,int,int)>($r3, i0, i1, i2);

        r1 = virtualinvoke $r2.<javassist.bytecode.StackMapTable$InsertLocal: byte[] doit()>();

        virtualinvoke r0.<javassist.bytecode.StackMapTable: void set(byte[])>(r1);

        return;
    }

    public static int typeTagOf(char)
    {
        char c0;

        c0 := @parameter0: char;

        lookupswitch(c0)
        {
            case 68: goto label1;
            case 70: goto label2;
            case 74: goto label3;
            case 76: goto label4;
            case 91: goto label4;
            default: goto label5;
        };

     label1:
        return 3;

     label2:
        return 2;

     label3:
        return 4;

     label4:
        return 7;

     label5:
        return 1;
    }

    public void println(java.io.PrintWriter)
    {
        javassist.bytecode.StackMapTable r0;
        java.io.PrintWriter r1;

        r0 := @this: javassist.bytecode.StackMapTable;

        r1 := @parameter0: java.io.PrintWriter;

        staticinvoke <javassist.bytecode.StackMapTable$Printer: void print(javassist.bytecode.StackMapTable,java.io.PrintWriter)>(r0, r1);

        return;
    }

    public void println(java.io.PrintStream)
    {
        javassist.bytecode.StackMapTable r0;
        java.io.PrintStream r1;
        java.io.PrintWriter $r2;

        r0 := @this: javassist.bytecode.StackMapTable;

        r1 := @parameter0: java.io.PrintStream;

        $r2 = new java.io.PrintWriter;

        specialinvoke $r2.<java.io.PrintWriter: void <init>(java.io.OutputStream,boolean)>(r1, 1);

        staticinvoke <javassist.bytecode.StackMapTable$Printer: void print(javassist.bytecode.StackMapTable,java.io.PrintWriter)>(r0, $r2);

        return;
    }

    void shiftPc(int, int, boolean) throws javassist.bytecode.BadBytecode
    {
        javassist.bytecode.StackMapTable r0;
        int i0, i1;
        boolean z0;
        javassist.bytecode.StackMapTable$OffsetShifter $r1;
        javassist.bytecode.StackMapTable$Shifter $r2;

        r0 := @this: javassist.bytecode.StackMapTable;

        i0 := @parameter0: int;

        i1 := @parameter1: int;

        z0 := @parameter2: boolean;

        $r1 = new javassist.bytecode.StackMapTable$OffsetShifter;

        specialinvoke $r1.<javassist.bytecode.StackMapTable$OffsetShifter: void <init>(javassist.bytecode.StackMapTable,int,int)>(r0, i0, i1);

        virtualinvoke $r1.<javassist.bytecode.StackMapTable$OffsetShifter: void parse()>();

        $r2 = new javassist.bytecode.StackMapTable$Shifter;

        specialinvoke $r2.<javassist.bytecode.StackMapTable$Shifter: void <init>(javassist.bytecode.StackMapTable,int,int,boolean)>(r0, i0, i1, z0);

        virtualinvoke $r2.<javassist.bytecode.StackMapTable$Shifter: void doit()>();

        return;
    }

    void shiftForSwitch(int, int) throws javassist.bytecode.BadBytecode
    {
        javassist.bytecode.StackMapTable r0;
        int i0, i1;
        javassist.bytecode.StackMapTable$SwitchShifter $r1;

        r0 := @this: javassist.bytecode.StackMapTable;

        i0 := @parameter0: int;

        i1 := @parameter1: int;

        $r1 = new javassist.bytecode.StackMapTable$SwitchShifter;

        specialinvoke $r1.<javassist.bytecode.StackMapTable$SwitchShifter: void <init>(javassist.bytecode.StackMapTable,int,int)>(r0, i0, i1);

        virtualinvoke $r1.<javassist.bytecode.StackMapTable$SwitchShifter: void doit()>();

        return;
    }

    public void removeNew(int) throws javassist.CannotCompileException
    {
        javassist.bytecode.StackMapTable r0;
        int i0;
        javassist.bytecode.StackMapTable$NewRemover $r1;
        byte[] $r2, r5;
        javassist.bytecode.BadBytecode $r3;
        javassist.CannotCompileException $r4;

        r0 := @this: javassist.bytecode.StackMapTable;

        i0 := @parameter0: int;

     label1:
        $r1 = new javassist.bytecode.StackMapTable$NewRemover;

        $r2 = virtualinvoke r0.<javassist.bytecode.StackMapTable: byte[] get()>();

        specialinvoke $r1.<javassist.bytecode.StackMapTable$NewRemover: void <init>(byte[],int)>($r2, i0);

        r5 = virtualinvoke $r1.<javassist.bytecode.StackMapTable$NewRemover: byte[] doit()>();

        virtualinvoke r0.<javassist.bytecode.StackMapTable: void set(byte[])>(r5);

     label2:
        goto label4;

     label3:
        $r3 := @caughtexception;

        $r4 = new javassist.CannotCompileException;

        specialinvoke $r4.<javassist.CannotCompileException: void <init>(java.lang.String,java.lang.Throwable)>("bad stack map table", $r3);

        throw $r4;

     label4:
        return;

        catch javassist.bytecode.BadBytecode from label1 to label2 with label3;
    }

    public static void <clinit>()
    {
        <javassist.bytecode.StackMapTable: int UNINIT> = 8;

        <javassist.bytecode.StackMapTable: int OBJECT> = 7;

        <javassist.bytecode.StackMapTable: int THIS> = 6;

        <javassist.bytecode.StackMapTable: int NULL> = 5;

        <javassist.bytecode.StackMapTable: int LONG> = 4;

        <javassist.bytecode.StackMapTable: int DOUBLE> = 3;

        <javassist.bytecode.StackMapTable: int FLOAT> = 2;

        <javassist.bytecode.StackMapTable: int INTEGER> = 1;

        <javassist.bytecode.StackMapTable: int TOP> = 0;

        <javassist.bytecode.StackMapTable: java.lang.String tag> = "StackMapTable";

        return;
    }
}
